!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
BOOST_AUTO_TEST_CASE	ARM_test.cpp	/^BOOST_AUTO_TEST_CASE(CoRW_1){$/;"	f
BOOST_AUTO_TEST_CASE	ARM_test.cpp	/^BOOST_AUTO_TEST_CASE(CoRW_2){$/;"	f
BOOST_AUTO_TEST_CASE	ARM_test.cpp	/^BOOST_AUTO_TEST_CASE(CoWR_1){$/;"	f
BOOST_AUTO_TEST_CASE	ARM_test.cpp	/^BOOST_AUTO_TEST_CASE(CoWR_2){$/;"	f
BOOST_AUTO_TEST_CASE	ARM_test.cpp	/^BOOST_AUTO_TEST_CASE(CoWW_1){$/;"	f
BOOST_AUTO_TEST_CASE	ARM_test.cpp	/^BOOST_AUTO_TEST_CASE(CoWW_2){$/;"	f
BOOST_AUTO_TEST_CASE	ARM_test.cpp	/^BOOST_AUTO_TEST_CASE(Commit_fences_1){$/;"	f
BOOST_AUTO_TEST_CASE	ARM_test.cpp	/^BOOST_AUTO_TEST_CASE(Commit_fences_2){$/;"	f
BOOST_AUTO_TEST_CASE	ARM_test.cpp	/^BOOST_AUTO_TEST_CASE(Ctrldep_1){ \/\/ LB+ctrls$/;"	f
BOOST_AUTO_TEST_CASE	ARM_test.cpp	/^BOOST_AUTO_TEST_CASE(Ctrldep_2){ \/\/ LB+ctrl+(ctrl without dep)$/;"	f
BOOST_AUTO_TEST_CASE	ARM_test.cpp	/^BOOST_AUTO_TEST_CASE(Disappearing_sleep_1){$/;"	f
BOOST_AUTO_TEST_CASE	ARM_test.cpp	/^BOOST_AUTO_TEST_CASE(IRIW){$/;"	f
BOOST_AUTO_TEST_CASE	ARM_test.cpp	/^BOOST_AUTO_TEST_CASE(IRIW_addrs){$/;"	f
BOOST_AUTO_TEST_CASE	ARM_test.cpp	/^BOOST_AUTO_TEST_CASE(IRIW_lwsyncs){$/;"	f
BOOST_AUTO_TEST_CASE	ARM_test.cpp	/^BOOST_AUTO_TEST_CASE(IRIW_syncs){$/;"	f
BOOST_AUTO_TEST_CASE	ARM_test.cpp	/^BOOST_AUTO_TEST_CASE(LB_1){$/;"	f
BOOST_AUTO_TEST_CASE	ARM_test.cpp	/^BOOST_AUTO_TEST_CASE(LB_addrpos){$/;"	f
BOOST_AUTO_TEST_CASE	ARM_test.cpp	/^BOOST_AUTO_TEST_CASE(LB_assume_1){$/;"	f
BOOST_AUTO_TEST_CASE	ARM_test.cpp	/^BOOST_AUTO_TEST_CASE(LB_assume_2){$/;"	f
BOOST_AUTO_TEST_CASE	ARM_test.cpp	/^BOOST_AUTO_TEST_CASE(LB_assume_3){$/;"	f
BOOST_AUTO_TEST_CASE	ARM_test.cpp	/^BOOST_AUTO_TEST_CASE(LB_data_1){$/;"	f
BOOST_AUTO_TEST_CASE	ARM_test.cpp	/^BOOST_AUTO_TEST_CASE(LB_data_2){$/;"	f
BOOST_AUTO_TEST_CASE	ARM_test.cpp	/^BOOST_AUTO_TEST_CASE(LB_datas){$/;"	f
BOOST_AUTO_TEST_CASE	ARM_test.cpp	/^BOOST_AUTO_TEST_CASE(LB_isyncs){$/;"	f
BOOST_AUTO_TEST_CASE	ARM_test.cpp	/^BOOST_AUTO_TEST_CASE(LB_lwsyncs){$/;"	f
BOOST_AUTO_TEST_CASE	ARM_test.cpp	/^BOOST_AUTO_TEST_CASE(LB_syncs){$/;"	f
BOOST_AUTO_TEST_CASE	ARM_test.cpp	/^BOOST_AUTO_TEST_CASE(Load_store_1){$/;"	f
BOOST_AUTO_TEST_CASE	ARM_test.cpp	/^BOOST_AUTO_TEST_CASE(Load_store_2){$/;"	f
BOOST_AUTO_TEST_CASE	ARM_test.cpp	/^BOOST_AUTO_TEST_CASE(Load_store_3){$/;"	f
BOOST_AUTO_TEST_CASE	ARM_test.cpp	/^BOOST_AUTO_TEST_CASE(MP3_lwsync_addrpo_addr){$/;"	f
BOOST_AUTO_TEST_CASE	ARM_test.cpp	/^BOOST_AUTO_TEST_CASE(MP3_lwsync_ctrl_addr){$/;"	f
BOOST_AUTO_TEST_CASE	ARM_test.cpp	/^BOOST_AUTO_TEST_CASE(MPWW_lwsyncs){$/;"	f
BOOST_AUTO_TEST_CASE	ARM_test.cpp	/^BOOST_AUTO_TEST_CASE(MPW_lwsyncs){$/;"	f
BOOST_AUTO_TEST_CASE	ARM_test.cpp	/^BOOST_AUTO_TEST_CASE(MP_addr){$/;"	f
BOOST_AUTO_TEST_CASE	ARM_test.cpp	/^BOOST_AUTO_TEST_CASE(MP_addr_1){$/;"	f
BOOST_AUTO_TEST_CASE	ARM_test.cpp	/^BOOST_AUTO_TEST_CASE(MP_lwsync_addr){$/;"	f
BOOST_AUTO_TEST_CASE	ARM_test.cpp	/^BOOST_AUTO_TEST_CASE(MP_lwsync_addrpo){$/;"	f
BOOST_AUTO_TEST_CASE	ARM_test.cpp	/^BOOST_AUTO_TEST_CASE(MP_lwsync_ctrl){$/;"	f
BOOST_AUTO_TEST_CASE	ARM_test.cpp	/^BOOST_AUTO_TEST_CASE(MP_lwsync_ctrlisync){$/;"	f
BOOST_AUTO_TEST_CASE	ARM_test.cpp	/^BOOST_AUTO_TEST_CASE(MP_lwsync_datarfiaddr){$/;"	f
BOOST_AUTO_TEST_CASE	ARM_test.cpp	/^BOOST_AUTO_TEST_CASE(MP_lwsync_isync){$/;"	f
BOOST_AUTO_TEST_CASE	ARM_test.cpp	/^BOOST_AUTO_TEST_CASE(MP_lwsync_isyncctrl){$/;"	f
BOOST_AUTO_TEST_CASE	ARM_test.cpp	/^BOOST_AUTO_TEST_CASE(MP_lwsyncs){$/;"	f
BOOST_AUTO_TEST_CASE	ARM_test.cpp	/^BOOST_AUTO_TEST_CASE(Minimal_computation){$/;"	f
BOOST_AUTO_TEST_CASE	ARM_test.cpp	/^BOOST_AUTO_TEST_CASE(PHI_delayed){$/;"	f
BOOST_AUTO_TEST_CASE	ARM_test.cpp	/^BOOST_AUTO_TEST_CASE(RRW_1){$/;"	f
BOOST_AUTO_TEST_CASE	ARM_test.cpp	/^BOOST_AUTO_TEST_CASE(Reordering_box_1){$/;"	f
BOOST_AUTO_TEST_CASE	ARM_test.cpp	/^BOOST_AUTO_TEST_CASE(Reordering_box_10){$/;"	f
BOOST_AUTO_TEST_CASE	ARM_test.cpp	/^BOOST_AUTO_TEST_CASE(Reordering_box_11){$/;"	f
BOOST_AUTO_TEST_CASE	ARM_test.cpp	/^BOOST_AUTO_TEST_CASE(Reordering_box_12){$/;"	f
BOOST_AUTO_TEST_CASE	ARM_test.cpp	/^BOOST_AUTO_TEST_CASE(Reordering_box_13){$/;"	f
BOOST_AUTO_TEST_CASE	ARM_test.cpp	/^BOOST_AUTO_TEST_CASE(Reordering_box_14){$/;"	f
BOOST_AUTO_TEST_CASE	ARM_test.cpp	/^BOOST_AUTO_TEST_CASE(Reordering_box_15){$/;"	f
BOOST_AUTO_TEST_CASE	ARM_test.cpp	/^BOOST_AUTO_TEST_CASE(Reordering_box_16){$/;"	f
BOOST_AUTO_TEST_CASE	ARM_test.cpp	/^BOOST_AUTO_TEST_CASE(Reordering_box_17){$/;"	f
BOOST_AUTO_TEST_CASE	ARM_test.cpp	/^BOOST_AUTO_TEST_CASE(Reordering_box_18){$/;"	f
BOOST_AUTO_TEST_CASE	ARM_test.cpp	/^BOOST_AUTO_TEST_CASE(Reordering_box_19){$/;"	f
BOOST_AUTO_TEST_CASE	ARM_test.cpp	/^BOOST_AUTO_TEST_CASE(Reordering_box_2){$/;"	f
BOOST_AUTO_TEST_CASE	ARM_test.cpp	/^BOOST_AUTO_TEST_CASE(Reordering_box_3){$/;"	f
BOOST_AUTO_TEST_CASE	ARM_test.cpp	/^BOOST_AUTO_TEST_CASE(Reordering_box_4){$/;"	f
BOOST_AUTO_TEST_CASE	ARM_test.cpp	/^BOOST_AUTO_TEST_CASE(Reordering_box_5){$/;"	f
BOOST_AUTO_TEST_CASE	ARM_test.cpp	/^BOOST_AUTO_TEST_CASE(Reordering_box_6){$/;"	f
BOOST_AUTO_TEST_CASE	ARM_test.cpp	/^BOOST_AUTO_TEST_CASE(Reordering_box_7){$/;"	f
BOOST_AUTO_TEST_CASE	ARM_test.cpp	/^BOOST_AUTO_TEST_CASE(Reordering_box_8){$/;"	f
BOOST_AUTO_TEST_CASE	ARM_test.cpp	/^BOOST_AUTO_TEST_CASE(Reordering_box_9){$/;"	f
BOOST_AUTO_TEST_CASE	ARM_test.cpp	/^BOOST_AUTO_TEST_CASE(SB){$/;"	f
BOOST_AUTO_TEST_CASE	ARM_test.cpp	/^BOOST_AUTO_TEST_CASE(SB_lwsyncs){$/;"	f
BOOST_AUTO_TEST_CASE	ARM_test.cpp	/^BOOST_AUTO_TEST_CASE(SB_syncs){$/;"	f
BOOST_AUTO_TEST_CASE	ARM_test.cpp	/^BOOST_AUTO_TEST_CASE(Store_load_1){$/;"	f
BOOST_AUTO_TEST_CASE	ARM_test.cpp	/^BOOST_AUTO_TEST_CASE(Store_load_2){$/;"	f
BOOST_AUTO_TEST_CASE	ARM_test.cpp	/^BOOST_AUTO_TEST_CASE(Store_load_3){$/;"	f
BOOST_AUTO_TEST_CASE	ARM_test.cpp	/^BOOST_AUTO_TEST_CASE(Store_store_1){$/;"	f
BOOST_AUTO_TEST_CASE	ARM_test.cpp	/^BOOST_AUTO_TEST_CASE(Store_store_2){$/;"	f
BOOST_AUTO_TEST_CASE	ARM_test.cpp	/^BOOST_AUTO_TEST_CASE(Store_store_3){$/;"	f
BOOST_AUTO_TEST_CASE	ARM_test.cpp	/^BOOST_AUTO_TEST_CASE(THREE_2W){$/;"	f
BOOST_AUTO_TEST_CASE	ARM_test.cpp	/^BOOST_AUTO_TEST_CASE(THREE_2W_lwsyncs){$/;"	f
BOOST_AUTO_TEST_CASE	ARM_test.cpp	/^BOOST_AUTO_TEST_CASE(TWO_2W){$/;"	f
BOOST_AUTO_TEST_CASE	ARM_test.cpp	/^BOOST_AUTO_TEST_CASE(TWO_2W_lwsync){$/;"	f
BOOST_AUTO_TEST_CASE	ARM_test.cpp	/^BOOST_AUTO_TEST_CASE(TWO_2W_lwsync_2){$/;"	f
BOOST_AUTO_TEST_CASE	ARM_test.cpp	/^BOOST_AUTO_TEST_CASE(TWO_2W_lwsyncs){$/;"	f
BOOST_AUTO_TEST_CASE	ARM_test.cpp	/^BOOST_AUTO_TEST_CASE(TWO_2W_rfi_datas_noise){$/;"	f
BOOST_AUTO_TEST_CASE	ARM_test.cpp	/^BOOST_AUTO_TEST_CASE(W_RW_2W){$/;"	f
BOOST_AUTO_TEST_CASE	ARM_test.cpp	/^BOOST_AUTO_TEST_CASE(W_RW_2W_lwsyncs){$/;"	f
BOOST_AUTO_TEST_CASE	ARM_test2.cpp	/^BOOST_AUTO_TEST_CASE(Compiler_fence_SB){$/;"	f
BOOST_AUTO_TEST_CASE	ARM_test2.cpp	/^BOOST_AUTO_TEST_CASE(Create_id_1){$/;"	f
BOOST_AUTO_TEST_CASE	ARM_test2.cpp	/^BOOST_AUTO_TEST_CASE(Data_rfi_sleepset){$/;"	f
BOOST_AUTO_TEST_CASE	ARM_test2.cpp	/^BOOST_AUTO_TEST_CASE(Fun_arg_1){$/;"	f
BOOST_AUTO_TEST_CASE	ARM_test2.cpp	/^BOOST_AUTO_TEST_CASE(Fun_arg_2){$/;"	f
BOOST_AUTO_TEST_CASE	ARM_test2.cpp	/^BOOST_AUTO_TEST_CASE(LB_datapoloc_lwsync){$/;"	f
BOOST_AUTO_TEST_CASE	ARM_test2.cpp	/^BOOST_AUTO_TEST_CASE(LB_polocrfiaddr_lwsync){$/;"	f
BOOST_AUTO_TEST_CASE	ARM_test2.cpp	/^BOOST_AUTO_TEST_CASE(MP_double_fence){$/;"	f
BOOST_AUTO_TEST_CASE	ARM_test2.cpp	/^BOOST_AUTO_TEST_CASE(MP_lwsync_overlap){$/;"	f
BOOST_AUTO_TEST_CASE	ARM_test2.cpp	/^BOOST_AUTO_TEST_CASE(MP_lwsync_overlap_2){$/;"	f
BOOST_AUTO_TEST_CASE	ARM_test2.cpp	/^BOOST_AUTO_TEST_CASE(Malloc_free_1){$/;"	f
BOOST_AUTO_TEST_CASE	ARM_test2.cpp	/^BOOST_AUTO_TEST_CASE(Mutex_1){$/;"	f
BOOST_AUTO_TEST_CASE	ARM_test2.cpp	/^BOOST_AUTO_TEST_CASE(Mutex_10){$/;"	f
BOOST_AUTO_TEST_CASE	ARM_test2.cpp	/^BOOST_AUTO_TEST_CASE(Mutex_11){$/;"	f
BOOST_AUTO_TEST_CASE	ARM_test2.cpp	/^BOOST_AUTO_TEST_CASE(Mutex_12){$/;"	f
BOOST_AUTO_TEST_CASE	ARM_test2.cpp	/^BOOST_AUTO_TEST_CASE(Mutex_3){$/;"	f
BOOST_AUTO_TEST_CASE	ARM_test2.cpp	/^BOOST_AUTO_TEST_CASE(Mutex_6){$/;"	f
BOOST_AUTO_TEST_CASE	ARM_test2.cpp	/^BOOST_AUTO_TEST_CASE(Mutex_7){$/;"	f
BOOST_AUTO_TEST_CASE	ARM_test2.cpp	/^BOOST_AUTO_TEST_CASE(Mutex_9){$/;"	f
BOOST_AUTO_TEST_CASE	ARM_test2.cpp	/^BOOST_AUTO_TEST_CASE(Normalise_1){$/;"	f
BOOST_AUTO_TEST_CASE	ARM_test2.cpp	/^BOOST_AUTO_TEST_CASE(Pthread_create_arg_1){$/;"	f
BOOST_AUTO_TEST_CASE	ARM_test2.cpp	/^BOOST_AUTO_TEST_CASE(Pthread_create_arg_2){$/;"	f
BOOST_AUTO_TEST_CASE	ARM_test2.cpp	/^BOOST_AUTO_TEST_CASE(Pthread_exit_1){$/;"	f
BOOST_AUTO_TEST_CASE	ARM_test2.cpp	/^BOOST_AUTO_TEST_CASE(Pthread_exit_2){$/;"	f
BOOST_AUTO_TEST_CASE	ARM_test2.cpp	/^BOOST_AUTO_TEST_CASE(Pthread_exit_3){$/;"	f
BOOST_AUTO_TEST_CASE	ARM_test2.cpp	/^BOOST_AUTO_TEST_CASE(Pthread_exit_4){$/;"	f
BOOST_AUTO_TEST_CASE	ARM_test2.cpp	/^BOOST_AUTO_TEST_CASE(TWO_2W_overlapping_1){$/;"	f
BOOST_AUTO_TEST_CASE	ARM_test2.cpp	/^BOOST_AUTO_TEST_CASE(TWO_2W_overlapping_2){$/;"	f
BOOST_AUTO_TEST_CASE	ARM_test2.cpp	/^BOOST_AUTO_TEST_CASE(TWO_2W_overlapping_3){$/;"	f
BOOST_AUTO_TEST_CASE	ARM_test2.cpp	/^BOOST_AUTO_TEST_CASE(TWO_2W_overlapping_4){$/;"	f
BOOST_AUTO_TEST_CASE	ARM_test2.cpp	/^BOOST_AUTO_TEST_CASE(TWO_W){$/;"	f
BOOST_AUTO_TEST_CASE	ARM_test2.cpp	/^BOOST_AUTO_TEST_CASE(TWO_W_2R){$/;"	f
ID	AddLibPass.cpp	/^char AddLibPass::ID = 0;$/;"	m	class:AddLibPass	file:
getAnalysisUsage	AddLibPass.cpp	/^void AddLibPass::getAnalysisUsage(llvm::AnalysisUsage &AU) const{$/;"	f	class:AddLibPass
optAddFunction	AddLibPass.cpp	/^bool AddLibPass::optAddFunction(llvm::Module &M,$/;"	f	class:AddLibPass
optConstIntFunction	AddLibPass.cpp	/^bool AddLibPass::optConstIntFunction(llvm::Module &M,$/;"	f	class:AddLibPass
optNopFunction	AddLibPass.cpp	/^bool AddLibPass::optNopFunction(llvm::Module &M,$/;"	f	class:AddLibPass
runOnModule	AddLibPass.cpp	/^bool AddLibPass::runOnModule(llvm::Module &M){$/;"	f	class:AddLibPass
AddLibPass	AddLibPass.h	/^  AddLibPass() : llvm::ModulePass(ID) {};$/;"	f	class:AddLibPass
AddLibPass	AddLibPass.h	/^class AddLibPass : public llvm::ModulePass{$/;"	c
ID	AddLibPass.h	/^  static char ID;$/;"	m	class:AddLibPass
__ADD_LIB_PASS_H__	AddLibPass.h	21;"	d
getPassName	AddLibPass.h	/^  virtual const char *getPassName() const { return "AddLibPass"; };$/;"	f	class:AddLibPass
leq	BVClock.cpp	/^bool BVClock::leq(const BVClock &vc) const{$/;"	f	class:BVClock
operator +	BVClock.cpp	/^BVClock BVClock::operator+(const BVClock &vc) const{$/;"	f	class:BVClock
operator +=	BVClock.cpp	/^BVClock &BVClock::operator+=(FBVClock &vc){$/;"	f	class:BVClock
operator =	BVClock.cpp	/^BVClock &BVClock::operator=(FBVClock &vc){$/;"	f	class:BVClock
to_string	BVClock.cpp	/^std::string BVClock::to_string() const{$/;"	f	class:BVClock
BVClock	BVClock.h	/^  BVClock(){};$/;"	f	class:BVClock
BVClock	BVClock.h	/^  BVClock(BVClock &&vc) : vec(std::move(vc.vec)) {};$/;"	f	class:BVClock
BVClock	BVClock.h	/^  BVClock(const BVClock &vc) : vec(vc.vec) {};$/;"	f	class:BVClock
BVClock	BVClock.h	/^class BVClock{$/;"	c
__BVCLOCK_H__	BVClock.h	23;"	d
clear	BVClock.h	/^  void clear() { vec.clear(); };$/;"	f	class:BVClock
operator +=	BVClock.h	/^  BVClock &operator+=(const BVClock &vc){$/;"	f	class:BVClock
operator <<	BVClock.h	/^inline llvm::raw_ostream &operator<<(llvm::raw_ostream &os, const BVClock &vc){$/;"	f
operator <<	BVClock.h	/^inline std::ostream &operator<<(std::ostream &os, const BVClock &vc){$/;"	f
operator =	BVClock.h	/^  BVClock &operator=(BVClock &&vc) { vec = std::move(vc.vec); return *this; };$/;"	f	class:BVClock
operator =	BVClock.h	/^  BVClock &operator=(const BVClock &vc) { vec = vc.vec; return *this; };$/;"	f	class:BVClock
operator []	BVClock.h	/^  bool operator[](int d) const{$/;"	f	class:BVClock
set	BVClock.h	/^  void set(int d) {$/;"	f	class:BVClock
vec	BVClock.h	/^  std::vector<bool> vec;$/;"	m	class:BVClock
CPid	CPid.cpp	/^CPid::CPid() : aux_idx(-1) {}$/;"	f	class:CPid
CPid	CPid.cpp	/^CPid::CPid(const std::initializer_list<int> &il){$/;"	f	class:CPid
CPid	CPid.cpp	/^CPid::CPid(const std::vector<int> &pvec){$/;"	f	class:CPid
CPid	CPid.cpp	/^CPid::CPid(const std::vector<int> &pvec, int i){$/;"	f	class:CPid
CPidSystem	CPid.cpp	/^CPidSystem::CPidSystem(){$/;"	f	class:CPidSystem
aux	CPid.cpp	/^CPid CPid::aux(int i) const{$/;"	f	class:CPid
compare	CPid.cpp	/^int CPid::compare(const CPid &c) const{$/;"	f	class:CPid
get_aux_index	CPid.cpp	/^int CPid::get_aux_index() const{$/;"	f	class:CPid
has_parent	CPid.cpp	/^bool CPid::has_parent() const{$/;"	f	class:CPid
is_auxiliary	CPid.cpp	/^bool CPid::is_auxiliary() const{$/;"	f	class:CPid
new_aux	CPid.cpp	/^CPid CPidSystem::new_aux(const CPid &c){$/;"	f	class:CPidSystem
parent	CPid.cpp	/^CPid CPid::parent() const{$/;"	f	class:CPid
spawn	CPid.cpp	/^CPid CPid::spawn(int pn1) const{$/;"	f	class:CPid
spawn	CPid.cpp	/^CPid CPidSystem::spawn(const CPid &c){$/;"	f	class:CPidSystem
to_string	CPid.cpp	/^std::string CPid::to_string() const{$/;"	f	class:CPid
CPid	CPid.h	/^class CPid{$/;"	c
CPidSystem	CPid.h	/^class CPidSystem{$/;"	c
__CPID_H__	CPid.h	23;"	d
aux_children	CPid.h	/^  std::vector<std::vector<int> > aux_children;$/;"	m	class:CPidSystem
aux_idx	CPid.h	/^  int aux_idx;$/;"	m	class:CPid
cpids	CPid.h	/^  std::vector<CPid> cpids;$/;"	m	class:CPidSystem
identifiers	CPid.h	/^  std::map<CPid,int> identifiers;$/;"	m	class:CPidSystem
operator !=	CPid.h	/^  bool operator!=(const CPid &c) const { return compare(c) != 0; };$/;"	f	class:CPid
operator <	CPid.h	/^  bool operator<(const CPid &c) const { return compare(c) < 0; };$/;"	f	class:CPid
operator <<	CPid.h	/^inline llvm::raw_ostream &operator<<(llvm::raw_ostream &os, const CPid &c){$/;"	f
operator <<	CPid.h	/^inline std::ostream &operator<<(std::ostream &os, const CPid &c){$/;"	f
operator <=	CPid.h	/^  bool operator<=(const CPid &c) const { return compare(c) <= 0; };$/;"	f	class:CPid
operator ==	CPid.h	/^  bool operator==(const CPid &c) const { return compare(c) == 0; };$/;"	f	class:CPid
operator >	CPid.h	/^  bool operator>(const CPid &c) const { return compare(c) > 0; };$/;"	f	class:CPid
operator >=	CPid.h	/^  bool operator>=(const CPid &c) const { return compare(c) >= 0; };$/;"	f	class:CPid
parent	CPid.h	/^  std::vector<int> parent;$/;"	m	class:CPidSystem
proc_seq	CPid.h	/^  std::vector<int> proc_seq;$/;"	m	class:CPid
real_children	CPid.h	/^  std::vector<std::vector<int> > real_children;$/;"	m	class:CPidSystem
BOOST_AUTO_TEST_CASE	CPid_test.cpp	/^BOOST_AUTO_TEST_CASE(CPidSystem_copy){$/;"	f
BOOST_AUTO_TEST_CASE	CPid_test.cpp	/^BOOST_AUTO_TEST_CASE(CPidSystem_copy_construct){$/;"	f
BOOST_AUTO_TEST_CASE	CPid_test.cpp	/^BOOST_AUTO_TEST_CASE(CPidSystem_new_aux){$/;"	f
BOOST_AUTO_TEST_CASE	CPid_test.cpp	/^BOOST_AUTO_TEST_CASE(CPidSystem_spawn){$/;"	f
BOOST_AUTO_TEST_CASE	CPid_test.cpp	/^BOOST_AUTO_TEST_CASE(CPid_parent){$/;"	f
BOOST_AUTO_TEST_CASE	CPid_test.cpp	/^BOOST_AUTO_TEST_CASE(Spawn_Aux){$/;"	f
CheckModule	CheckModule.cpp	/^namespace CheckModule {$/;"	n	file:
check_assume	CheckModule.cpp	/^  static void check_assume(const llvm::Module *M, const std::string &name){$/;"	f	namespace:CheckModule
check_assume	CheckModule.cpp	/^void CheckModule::check_assume(const llvm::Module *M){$/;"	f	class:CheckModule
check_functions	CheckModule.cpp	/^void CheckModule::check_functions(const llvm::Module *M){$/;"	f	class:CheckModule
check_malloc	CheckModule.cpp	/^void CheckModule::check_malloc(const llvm::Module *M){$/;"	f	class:CheckModule
check_nondet_int	CheckModule.cpp	/^  static void check_nondet_int(const llvm::Module *M, const std::string &name){$/;"	f	namespace:CheckModule
check_nondet_int	CheckModule.cpp	/^void CheckModule::check_nondet_int(const llvm::Module *M){$/;"	f	class:CheckModule
check_pthread_cond_broadcast	CheckModule.cpp	/^void CheckModule::check_pthread_cond_broadcast(const llvm::Module *M){$/;"	f	class:CheckModule
check_pthread_cond_destroy	CheckModule.cpp	/^void CheckModule::check_pthread_cond_destroy(const llvm::Module *M){$/;"	f	class:CheckModule
check_pthread_cond_init	CheckModule.cpp	/^void CheckModule::check_pthread_cond_init(const llvm::Module *M){$/;"	f	class:CheckModule
check_pthread_cond_signal	CheckModule.cpp	/^void CheckModule::check_pthread_cond_signal(const llvm::Module *M){$/;"	f	class:CheckModule
check_pthread_cond_wait	CheckModule.cpp	/^void CheckModule::check_pthread_cond_wait(const llvm::Module *M){$/;"	f	class:CheckModule
check_pthread_create	CheckModule.cpp	/^void CheckModule::check_pthread_create(const llvm::Module *M){$/;"	f	class:CheckModule
check_pthread_exit	CheckModule.cpp	/^void CheckModule::check_pthread_exit(const llvm::Module *M){$/;"	f	class:CheckModule
check_pthread_join	CheckModule.cpp	/^void CheckModule::check_pthread_join(const llvm::Module *M){$/;"	f	class:CheckModule
check_pthread_mutex_destroy	CheckModule.cpp	/^void CheckModule::check_pthread_mutex_destroy(const llvm::Module *M){$/;"	f	class:CheckModule
check_pthread_mutex_init	CheckModule.cpp	/^void CheckModule::check_pthread_mutex_init(const llvm::Module *M){$/;"	f	class:CheckModule
check_pthread_mutex_lock	CheckModule.cpp	/^void CheckModule::check_pthread_mutex_lock(const llvm::Module *M){$/;"	f	class:CheckModule
check_pthread_mutex_trylock	CheckModule.cpp	/^void CheckModule::check_pthread_mutex_trylock(const llvm::Module *M){$/;"	f	class:CheckModule
check_pthread_mutex_unlock	CheckModule.cpp	/^void CheckModule::check_pthread_mutex_unlock(const llvm::Module *M){$/;"	f	class:CheckModule
check_pthread_self	CheckModule.cpp	/^void CheckModule::check_pthread_self(const llvm::Module *M){$/;"	f	class:CheckModule
CheckModule	CheckModule.h	/^namespace CheckModule {$/;"	n
CheckModuleError	CheckModule.h	/^    CheckModuleError(const std::string &msg) : msg("CheckModuleError: "+msg) {};$/;"	f	class:CheckModule::CheckModuleError
CheckModuleError	CheckModule.h	/^  class CheckModuleError : public std::exception{$/;"	c	namespace:CheckModule
__CHECK_MODULE_H__	CheckModule.h	23;"	d
msg	CheckModule.h	/^    std::string msg;$/;"	m	class:CheckModule::CheckModuleError
what	CheckModule.h	/^    virtual const char *what() const throw() { return msg.c_str(); };$/;"	f	class:CheckModule::CheckModuleError
~CheckModuleError	CheckModule.h	/^    virtual ~CheckModuleError() throw() {};$/;"	f	class:CheckModule::CheckModuleError
assign_by_commandline	Configuration.cpp	/^void Configuration::assign_by_commandline(){$/;"	f	class:Configuration
check_commandline	Configuration.cpp	/^void Configuration::check_commandline(){$/;"	f	class:Configuration
commandline_opts	Configuration.cpp	/^const std::set<std::string> &Configuration::commandline_opts(){$/;"	f	class:Configuration
default_conf	Configuration.cpp	/^const Configuration Configuration::default_conf;$/;"	m	class:Configuration	file:
ARM	Configuration.h	/^    ARM,$/;"	e	enum:Configuration::MemoryModel
Configuration	Configuration.h	/^  Configuration(){$/;"	f	class:Configuration
Configuration	Configuration.h	/^class Configuration{$/;"	c
MM_UNDEF	Configuration.h	/^    MM_UNDEF, \/\/ No memory model was specified$/;"	e	enum:Configuration::MemoryModel
MemoryModel	Configuration.h	/^  enum MemoryModel{$/;"	g	class:Configuration
POWER	Configuration.h	/^    POWER,$/;"	e	enum:Configuration::MemoryModel
PSO	Configuration.h	/^    PSO,$/;"	e	enum:Configuration::MemoryModel
SC	Configuration.h	/^    SC,$/;"	e	enum:Configuration::MemoryModel
TSO	Configuration.h	/^    TSO$/;"	e	enum:Configuration::MemoryModel
__CONFIGURATION_H__	Configuration.h	23;"	d
check_robustness	Configuration.h	/^  bool check_robustness;$/;"	m	class:Configuration
debug_collect_all_traces	Configuration.h	/^  bool debug_collect_all_traces;$/;"	m	class:Configuration
debug_print_on_error	Configuration.h	/^  bool debug_print_on_error;$/;"	m	class:Configuration
debug_print_on_reset	Configuration.h	/^  bool debug_print_on_reset;$/;"	m	class:Configuration
default_conf	Configuration.h	/^  static const Configuration default_conf;$/;"	m	class:Configuration
ee_store_trace	Configuration.h	/^  bool ee_store_trace;$/;"	m	class:Configuration
explore_all_traces	Configuration.h	/^  bool explore_all_traces;$/;"	m	class:Configuration
extfun_no_fence	Configuration.h	/^  VecSet<std::string> extfun_no_fence;$/;"	m	class:Configuration
extfun_no_full_memory_conflict	Configuration.h	/^  VecSet<std::string> extfun_no_full_memory_conflict;$/;"	m	class:Configuration
malloc_may_fail	Configuration.h	/^  bool malloc_may_fail;$/;"	m	class:Configuration
max_search_depth	Configuration.h	/^  int max_search_depth;$/;"	m	class:Configuration
memory_model	Configuration.h	/^  MemoryModel memory_model;$/;"	m	class:Configuration
mutex_require_init	Configuration.h	/^  bool mutex_require_init;$/;"	m	class:Configuration
preemption_bound	Configuration.h	/^  int preemption_bound;$/;"	m	class:Configuration
print_progress	Configuration.h	/^  bool print_progress;$/;"	m	class:Configuration
print_progress_estimate	Configuration.h	/^  bool print_progress_estimate;$/;"	m	class:Configuration
transform_loop_unroll	Configuration.h	/^  int transform_loop_unroll;$/;"	m	class:Configuration
transform_spin_assume	Configuration.h	/^  bool transform_spin_assume;$/;"	m	class:Configuration
DPORDriver	DPORDriver.cpp	/^DPORDriver::DPORDriver(const Configuration &C) :$/;"	f	class:DPORDriver
create_execution_engine	DPORDriver.cpp	/^llvm::ExecutionEngine *DPORDriver::create_execution_engine(TraceBuilder &TB, const Configuration &conf) const {$/;"	f	class:DPORDriver
parseIR	DPORDriver.cpp	/^DPORDriver *DPORDriver::parseIR(const std::string &llvm_asm,$/;"	f	class:DPORDriver
parseIRFile	DPORDriver.cpp	/^DPORDriver *DPORDriver::parseIRFile(const std::string &filename,$/;"	f	class:DPORDriver
read_file	DPORDriver.cpp	/^void DPORDriver::read_file(const std::string &filename, std::string &tgt){$/;"	f	class:DPORDriver
reparse	DPORDriver.cpp	/^void DPORDriver::reparse(){$/;"	f	class:DPORDriver
run	DPORDriver.cpp	/^DPORDriver::Result DPORDriver::run(){$/;"	f	class:DPORDriver
run_once	DPORDriver.cpp	/^Trace *DPORDriver::run_once(TraceBuilder &TB) const{$/;"	f	class:DPORDriver
~DPORDriver	DPORDriver.cpp	/^DPORDriver::~DPORDriver(){$/;"	f	class:DPORDriver
DPORDriver	DPORDriver.h	/^class DPORDriver{$/;"	c
Result	DPORDriver.h	/^    Result() : trace_count(0), sleepset_blocked_trace_count(0), error_trace(0) {};$/;"	f	class:DPORDriver::Result
Result	DPORDriver.h	/^  class Result{$/;"	c	class:DPORDriver
__DPOR_DRIVER_H__	DPORDriver.h	23;"	d
all_traces	DPORDriver.h	/^    std::vector<Trace*> all_traces;$/;"	m	class:DPORDriver::Result
conf	DPORDriver.h	/^  const Configuration &conf;$/;"	m	class:DPORDriver
error_trace	DPORDriver.h	/^    Trace *error_trace;$/;"	m	class:DPORDriver::Result
has_errors	DPORDriver.h	/^    bool has_errors() const { return error_trace && error_trace->has_errors(); };$/;"	f	class:DPORDriver::Result
llvm	DPORDriver.h	/^namespace llvm{$/;"	n
mod	DPORDriver.h	/^  llvm::Module *mod;$/;"	m	class:DPORDriver
sleepset_blocked_trace_count	DPORDriver.h	/^    int sleepset_blocked_trace_count;$/;"	m	class:DPORDriver::Result
src	DPORDriver.h	/^  std::string src;$/;"	m	class:DPORDriver
trace_count	DPORDriver.h	/^    int trace_count;$/;"	m	class:DPORDriver::Result
~Result	DPORDriver.h	/^    ~Result(){$/;"	f	class:DPORDriver::Result
DPORDriver_test	DPORDriver_test.cpp	/^namespace DPORDriver_test {$/;"	n	file:
all_clocks_increasing	DPORDriver_test.cpp	/^  bool all_clocks_increasing(const IIDSeqTrace *t){$/;"	f	namespace:DPORDriver_test
check_all_traces	DPORDriver_test.cpp	/^  bool check_all_traces(const DPORDriver::Result &res,$/;"	f	namespace:DPORDriver_test
check_trace	DPORDriver_test.cpp	/^  bool check_trace(const IIDSeqTrace *t, const trace_spec &spec){$/;"	f	namespace:DPORDriver_test
find	DPORDriver_test.cpp	/^  int find(const IIDSeqTrace *_t, const IID<CPid> &iid){$/;"	f	namespace:DPORDriver_test
get_arm_conf	DPORDriver_test.cpp	/^  const Configuration &get_arm_conf(){$/;"	f	namespace:DPORDriver_test
get_power_conf	DPORDriver_test.cpp	/^  const Configuration &get_power_conf(){$/;"	f	namespace:DPORDriver_test
get_pso_conf	DPORDriver_test.cpp	/^  const Configuration &get_pso_conf(){$/;"	f	namespace:DPORDriver_test
get_sc_conf	DPORDriver_test.cpp	/^  const Configuration &get_sc_conf(){$/;"	f	namespace:DPORDriver_test
get_tso_conf	DPORDriver_test.cpp	/^  const Configuration &get_tso_conf(){$/;"	f	namespace:DPORDriver_test
print_trace	DPORDriver_test.cpp	/^  void print_trace(const Trace *_t, llvm::raw_ostream &os, int ind){$/;"	f	namespace:DPORDriver_test
trace_spec_to_string	DPORDriver_test.cpp	/^  std::string trace_spec_to_string(const trace_spec &v){$/;"	f	namespace:DPORDriver_test
DPORDriver_test	DPORDriver_test.h	/^namespace DPORDriver_test {$/;"	n
IIDOrder	DPORDriver_test.h	/^  struct IIDOrder{$/;"	s	namespace:DPORDriver_test
__DPOR_DRIVER_TEST_H__	DPORDriver_test.h	24;"	d
a	DPORDriver_test.h	/^    IID<CPid> a;$/;"	m	struct:DPORDriver_test::IIDOrder
b	DPORDriver_test.h	/^    IID<CPid> b;$/;"	m	struct:DPORDriver_test::IIDOrder
trace_set_spec	DPORDriver_test.h	/^  typedef std::vector<trace_spec> trace_set_spec;$/;"	t	namespace:DPORDriver_test
trace_spec	DPORDriver_test.h	/^  typedef std::vector<IIDOrder> trace_spec;$/;"	t	namespace:DPORDriver_test
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
warn	Debug.cpp	/^llvm::raw_ostream &Debug::warn(){$/;"	f	class:Debug
warn	Debug.cpp	/^llvm::raw_ostream &Debug::warn(const std::string &wid){$/;"	f	class:Debug
Debug	Debug.h	/^namespace Debug {$/;"	n
__DEBUG_H__	Debug.h	23;"	d
BOOST_AUTO_TEST_CASE	DryRun_test.cpp	/^BOOST_AUTO_TEST_CASE(DryRunMem_1){$/;"	f
BOOST_AUTO_TEST_CASE	DryRun_test.cpp	/^BOOST_AUTO_TEST_CASE(DryRunMem_2){$/;"	f
BOOST_AUTO_TEST_CASE	DryRun_test.cpp	/^BOOST_AUTO_TEST_CASE(DryRunMem_3){$/;"	f
BOOST_AUTO_TEST_CASE	DryRun_test.cpp	/^BOOST_AUTO_TEST_CASE(DryRunMem_4){$/;"	f
BOOST_AUTO_TEST_CASE	DryRun_test.cpp	/^BOOST_AUTO_TEST_CASE(DryRunMem_5){$/;"	f
BOOST_AUTO_TEST_CASE	DryRun_test.cpp	/^BOOST_AUTO_TEST_CASE(DryRunMem_6){$/;"	f
MMs	DryRun_test.cpp	/^static VecSet<Configuration::MemoryModel> MMs =$/;"	v	file:
check	DryRun_test.cpp	/^static void check(Configuration::MemoryModel MM, const std::string &prog){$/;"	f	file:
check_all	DryRun_test.cpp	/^static void check_all(const std::string &prog_template){$/;"	f	file:
format	DryRun_test.cpp	/^static std::string &format(std::string &s, const std::vector<int> &substs){$/;"	f	file:
CheckedAssign	Execution.cpp	/^template<typename T> bool Interpreter::CheckedAssign(T &tgt, const T *src){$/;"	f	class:Interpreter
CheckedLoadIntFromMemory	Execution.cpp	/^bool Interpreter::CheckedLoadIntFromMemory(APInt &IntVal, uint8_t *Src, unsigned LoadBytes) {$/;"	f	class:Interpreter
CheckedLoadValueFromMemory	Execution.cpp	/^bool Interpreter::CheckedLoadValueFromMemory(GenericValue &Result,$/;"	f	class:Interpreter
CheckedMemCpy	Execution.cpp	/^bool Interpreter::CheckedMemCpy(uint8_t *dst, const uint8_t *src, unsigned n){$/;"	f	class:Interpreter
CheckedMemSet	Execution.cpp	/^bool Interpreter::CheckedMemSet(uint8_t *s, int c, size_t n){$/;"	f	class:Interpreter
CheckedStore	Execution.cpp	/^template<typename T> bool Interpreter::CheckedStore(T *tgt, const T &src){$/;"	f	class:Interpreter
CheckedStoreIntToMemory	Execution.cpp	/^bool Interpreter::CheckedStoreIntToMemory(const APInt &IntVal, uint8_t *Dst,$/;"	f	class:Interpreter
CheckedStoreValueToMemory	Execution.cpp	/^bool Interpreter::CheckedStoreValueToMemory(const GenericValue &Val,$/;"	f	class:Interpreter
DryRunLoadValueFromMemory	Execution.cpp	/^void Interpreter::DryRunLoadValueFromMemory(GenericValue &Val,$/;"	f	class:Interpreter
FLOAT_VECTOR_FUNCTION	Execution.cpp	753;"	d	file:
FLOAT_VECTOR_OP	Execution.cpp	760;"	d	file:
IMPLEMENT_BINARY_OPERATOR	Execution.cpp	95;"	d	file:
IMPLEMENT_FCMP	Execution.cpp	349;"	d	file:
IMPLEMENT_INTEGER_ICMP	Execution.cpp	159;"	d	file:
IMPLEMENT_POINTER_ICMP	Execution.cpp	177;"	d	file:
IMPLEMENT_SCALAR_NANS	Execution.cpp	384;"	d	file:
IMPLEMENT_UNORDERED	Execution.cpp	502;"	d	file:
IMPLEMENT_VAARG	Execution.cpp	2201;"	d	file:
IMPLEMENT_VECTOR_FCMP	Execution.cpp	362;"	d	file:
IMPLEMENT_VECTOR_FCMP_T	Execution.cpp	354;"	d	file:
IMPLEMENT_VECTOR_INTEGER_ICMP	Execution.cpp	164;"	d	file:
IMPLEMENT_VECTOR_UNORDERED	Execution.cpp	513;"	d	file:
INTEGER_VECTOR_FUNCTION	Execution.cpp	746;"	d	file:
INTEGER_VECTOR_OPERATION	Execution.cpp	739;"	d	file:
MASK_VECTOR_NANS	Execution.cpp	409;"	d	file:
MASK_VECTOR_NANS_T	Execution.cpp	397;"	d	file:
SetValue	Execution.cpp	/^static void SetValue(Value *V, GenericValue Val, ExecutionContext &SF) {$/;"	f	file:
SwitchToNewBasicBlock	Execution.cpp	/^void Interpreter::SwitchToNewBasicBlock(BasicBlock *Dest, ExecutionContext &SF){$/;"	f	class:Interpreter
abort	Execution.cpp	/^void Interpreter::abort(){$/;"	f	class:Interpreter
callAssertFail	Execution.cpp	/^void Interpreter::callAssertFail(Function *F,$/;"	f	class:Interpreter
callAssume	Execution.cpp	/^void Interpreter::callAssume(Function *F, const std::vector<GenericValue> &ArgVals){$/;"	f	class:Interpreter
callAtexit	Execution.cpp	/^void Interpreter::callAtexit(Function *F,$/;"	f	class:Interpreter
callFree	Execution.cpp	/^void Interpreter::callFree(Function *F,$/;"	f	class:Interpreter
callFunction	Execution.cpp	/^void Interpreter::callFunction(Function *F,$/;"	f	class:Interpreter
callMalloc	Execution.cpp	/^void Interpreter::callMalloc(Function *F,$/;"	f	class:Interpreter
callNondetInt	Execution.cpp	/^void Interpreter::callNondetInt(Function *F, const std::vector<GenericValue> &ArgVals){$/;"	f	class:Interpreter
callPthreadCondBroadcast	Execution.cpp	/^void Interpreter::callPthreadCondBroadcast(Function *F,$/;"	f	class:Interpreter
callPthreadCondDestroy	Execution.cpp	/^void Interpreter::callPthreadCondDestroy(Function *F,$/;"	f	class:Interpreter
callPthreadCondInit	Execution.cpp	/^void Interpreter::callPthreadCondInit(Function *F,$/;"	f	class:Interpreter
callPthreadCondSignal	Execution.cpp	/^void Interpreter::callPthreadCondSignal(Function *F,$/;"	f	class:Interpreter
callPthreadCondWait	Execution.cpp	/^void Interpreter::callPthreadCondWait(Function *F,$/;"	f	class:Interpreter
callPthreadCreate	Execution.cpp	/^void Interpreter::callPthreadCreate(Function *F,$/;"	f	class:Interpreter
callPthreadExit	Execution.cpp	/^void Interpreter::callPthreadExit(Function *F,$/;"	f	class:Interpreter
callPthreadJoin	Execution.cpp	/^void Interpreter::callPthreadJoin(Function *F,$/;"	f	class:Interpreter
callPthreadMutexDestroy	Execution.cpp	/^void Interpreter::callPthreadMutexDestroy(Function *F,$/;"	f	class:Interpreter
callPthreadMutexInit	Execution.cpp	/^void Interpreter::callPthreadMutexInit(Function *F,$/;"	f	class:Interpreter
callPthreadMutexLock	Execution.cpp	/^void Interpreter::callPthreadMutexLock(Function *F,$/;"	f	class:Interpreter
callPthreadMutexLock	Execution.cpp	/^void Interpreter::callPthreadMutexLock(void *lck){$/;"	f	class:Interpreter
callPthreadMutexTryLock	Execution.cpp	/^void Interpreter::callPthreadMutexTryLock(Function *F,$/;"	f	class:Interpreter
callPthreadMutexUnlock	Execution.cpp	/^void Interpreter::callPthreadMutexUnlock(Function *F,$/;"	f	class:Interpreter
callPthreadSelf	Execution.cpp	/^void Interpreter::callPthreadSelf(Function *F,$/;"	f	class:Interpreter
checkRefuse	Execution.cpp	/^bool Interpreter::checkRefuse(Instruction &I){$/;"	f	class:Interpreter
clearAllStacks	Execution.cpp	/^void Interpreter::clearAllStacks(){$/;"	f	class:Interpreter
executeBitCastInst	Execution.cpp	/^GenericValue Interpreter::executeBitCastInst(Value *SrcVal, Type *DstTy,$/;"	f	class:Interpreter
executeCastOperation	Execution.cpp	/^GenericValue Interpreter::executeCastOperation(Instruction::CastOps opcode, Value *SrcVal,$/;"	f	class:Interpreter
executeCmpInst	Execution.cpp	/^GenericValue Interpreter::executeCmpInst(unsigned predicate, GenericValue Src1,$/;"	f	class:Interpreter
executeFAddInst	Execution.cpp	/^static void executeFAddInst(GenericValue &Dest, GenericValue Src1,$/;"	f	file:
executeFCMP_BOOL	Execution.cpp	/^static GenericValue executeFCMP_BOOL(GenericValue Src1, GenericValue Src2,$/;"	f	file:
executeFCMP_OEQ	Execution.cpp	/^static GenericValue executeFCMP_OEQ(GenericValue Src1, GenericValue Src2,$/;"	f	file:
executeFCMP_OGE	Execution.cpp	/^static GenericValue executeFCMP_OGE(GenericValue Src1, GenericValue Src2,$/;"	f	file:
executeFCMP_OGT	Execution.cpp	/^static GenericValue executeFCMP_OGT(GenericValue Src1, GenericValue Src2,$/;"	f	file:
executeFCMP_OLE	Execution.cpp	/^static GenericValue executeFCMP_OLE(GenericValue Src1, GenericValue Src2,$/;"	f	file:
executeFCMP_OLT	Execution.cpp	/^static GenericValue executeFCMP_OLT(GenericValue Src1, GenericValue Src2,$/;"	f	file:
executeFCMP_ONE	Execution.cpp	/^static GenericValue executeFCMP_ONE(GenericValue Src1, GenericValue Src2,$/;"	f	file:
executeFCMP_ORD	Execution.cpp	/^static GenericValue executeFCMP_ORD(GenericValue Src1, GenericValue Src2,$/;"	f	file:
executeFCMP_UEQ	Execution.cpp	/^static GenericValue executeFCMP_UEQ(GenericValue Src1, GenericValue Src2,$/;"	f	file:
executeFCMP_UGE	Execution.cpp	/^static GenericValue executeFCMP_UGE(GenericValue Src1, GenericValue Src2,$/;"	f	file:
executeFCMP_UGT	Execution.cpp	/^static GenericValue executeFCMP_UGT(GenericValue Src1, GenericValue Src2,$/;"	f	file:
executeFCMP_ULE	Execution.cpp	/^static GenericValue executeFCMP_ULE(GenericValue Src1, GenericValue Src2,$/;"	f	file:
executeFCMP_ULT	Execution.cpp	/^static GenericValue executeFCMP_ULT(GenericValue Src1, GenericValue Src2,$/;"	f	file:
executeFCMP_UNE	Execution.cpp	/^static GenericValue executeFCMP_UNE(GenericValue Src1, GenericValue Src2,$/;"	f	file:
executeFCMP_UNO	Execution.cpp	/^static GenericValue executeFCMP_UNO(GenericValue Src1, GenericValue Src2,$/;"	f	file:
executeFDivInst	Execution.cpp	/^static void executeFDivInst(GenericValue &Dest, GenericValue Src1,$/;"	f	file:
executeFMulInst	Execution.cpp	/^static void executeFMulInst(GenericValue &Dest, GenericValue Src1,$/;"	f	file:
executeFPExtInst	Execution.cpp	/^GenericValue Interpreter::executeFPExtInst(Value *SrcVal, Type *DstTy,$/;"	f	class:Interpreter
executeFPToSIInst	Execution.cpp	/^GenericValue Interpreter::executeFPToSIInst(Value *SrcVal, Type *DstTy,$/;"	f	class:Interpreter
executeFPToUIInst	Execution.cpp	/^GenericValue Interpreter::executeFPToUIInst(Value *SrcVal, Type *DstTy,$/;"	f	class:Interpreter
executeFPTruncInst	Execution.cpp	/^GenericValue Interpreter::executeFPTruncInst(Value *SrcVal, Type *DstTy,$/;"	f	class:Interpreter
executeFRemInst	Execution.cpp	/^static void executeFRemInst(GenericValue &Dest, GenericValue Src1,$/;"	f	file:
executeFSubInst	Execution.cpp	/^static void executeFSubInst(GenericValue &Dest, GenericValue Src1,$/;"	f	file:
executeGEPOperation	Execution.cpp	/^GenericValue Interpreter::executeGEPOperation(Value *Ptr, gep_type_iterator I,$/;"	f	class:Interpreter
executeICMP_EQ	Execution.cpp	/^GenericValue Interpreter::executeICMP_EQ(GenericValue Src1, GenericValue Src2,$/;"	f	class:Interpreter
executeICMP_NE	Execution.cpp	/^static GenericValue executeICMP_NE(GenericValue Src1, GenericValue Src2,$/;"	f	file:
executeICMP_SGE	Execution.cpp	/^static GenericValue executeICMP_SGE(GenericValue Src1, GenericValue Src2,$/;"	f	file:
executeICMP_SGT	Execution.cpp	/^static GenericValue executeICMP_SGT(GenericValue Src1, GenericValue Src2,$/;"	f	file:
executeICMP_SLE	Execution.cpp	/^static GenericValue executeICMP_SLE(GenericValue Src1, GenericValue Src2,$/;"	f	file:
executeICMP_SLT	Execution.cpp	/^static GenericValue executeICMP_SLT(GenericValue Src1, GenericValue Src2,$/;"	f	file:
executeICMP_UGE	Execution.cpp	/^static GenericValue executeICMP_UGE(GenericValue Src1, GenericValue Src2,$/;"	f	file:
executeICMP_UGT	Execution.cpp	/^static GenericValue executeICMP_UGT(GenericValue Src1, GenericValue Src2,$/;"	f	file:
executeICMP_ULE	Execution.cpp	/^static GenericValue executeICMP_ULE(GenericValue Src1, GenericValue Src2,$/;"	f	file:
executeICMP_ULT	Execution.cpp	/^static GenericValue executeICMP_ULT(GenericValue Src1, GenericValue Src2,$/;"	f	file:
executeIntToPtrInst	Execution.cpp	/^GenericValue Interpreter::executeIntToPtrInst(Value *SrcVal, Type *DstTy,$/;"	f	class:Interpreter
executePtrToIntInst	Execution.cpp	/^GenericValue Interpreter::executePtrToIntInst(Value *SrcVal, Type *DstTy,$/;"	f	class:Interpreter
executeSExtInst	Execution.cpp	/^GenericValue Interpreter::executeSExtInst(Value *SrcVal, Type *DstTy,$/;"	f	class:Interpreter
executeSIToFPInst	Execution.cpp	/^GenericValue Interpreter::executeSIToFPInst(Value *SrcVal, Type *DstTy,$/;"	f	class:Interpreter
executeSelectInst	Execution.cpp	/^static GenericValue executeSelectInst(GenericValue Src1, GenericValue Src2,$/;"	f	file:
executeTruncInst	Execution.cpp	/^GenericValue Interpreter::executeTruncInst(Value *SrcVal, Type *DstTy,$/;"	f	class:Interpreter
executeUIToFPInst	Execution.cpp	/^GenericValue Interpreter::executeUIToFPInst(Value *SrcVal, Type *DstTy,$/;"	f	class:Interpreter
executeZExtInst	Execution.cpp	/^GenericValue Interpreter::executeZExtInst(Value *SrcVal, Type *DstTy,$/;"	f	class:Interpreter
exitCalled	Execution.cpp	/^void Interpreter::exitCalled(GenericValue GV) {$/;"	f	class:Interpreter
getConstantExprValue	Execution.cpp	/^GenericValue Interpreter::getConstantExprValue (ConstantExpr *CE,$/;"	f	class:Interpreter
getOperandValue	Execution.cpp	/^GenericValue Interpreter::getOperandValue(Value *V, ExecutionContext &SF) {$/;"	f	class:Interpreter
getShiftAmount	Execution.cpp	/^static unsigned getShiftAmount(uint64_t orgShiftAmount,$/;"	f	file:
isInlineAsm	Execution.cpp	/^bool Interpreter::isInlineAsm(CallSite &CS, std::string *asmstr){$/;"	f	class:Interpreter
isPthreadJoin	Execution.cpp	/^bool Interpreter::isPthreadJoin(Instruction &I, int *tid){$/;"	f	class:Interpreter
isPthreadMutexLock	Execution.cpp	/^bool Interpreter::isPthreadMutexLock(Instruction &I, GenericValue **ptr){$/;"	f	class:Interpreter
isUnknownIntrinsic	Execution.cpp	/^bool Interpreter::isUnknownIntrinsic(Instruction &I){$/;"	f	class:Interpreter
popStackAndReturnValueToCaller	Execution.cpp	/^void Interpreter::popStackAndReturnValueToCaller(Type *RetTy,$/;"	f	class:Interpreter
returnValueToCaller	Execution.cpp	/^void Interpreter::returnValueToCaller(Type *RetTy,$/;"	f	class:Interpreter
run	Execution.cpp	/^void Interpreter::run() {$/;"	f	class:Interpreter
stripws	Execution.cpp	/^static void stripws(std::string &s){$/;"	f	file:
terminate	Execution.cpp	/^void Interpreter::terminate(Type *RetTy, GenericValue Result){$/;"	f	class:Interpreter
visitAShr	Execution.cpp	/^void Interpreter::visitAShr(BinaryOperator &I) {$/;"	f	class:Interpreter
visitAllocaInst	Execution.cpp	/^void Interpreter::visitAllocaInst(AllocaInst &I) {$/;"	f	class:Interpreter
visitAtomicCmpXchgInst	Execution.cpp	/^void Interpreter::visitAtomicCmpXchgInst(AtomicCmpXchgInst &I){$/;"	f	class:Interpreter
visitAtomicRMWInst	Execution.cpp	/^void Interpreter::visitAtomicRMWInst(AtomicRMWInst &I){$/;"	f	class:Interpreter
visitBinaryOperator	Execution.cpp	/^void Interpreter::visitBinaryOperator(BinaryOperator &I) {$/;"	f	class:Interpreter
visitBitCastInst	Execution.cpp	/^void Interpreter::visitBitCastInst(BitCastInst &I) {$/;"	f	class:Interpreter
visitBranchInst	Execution.cpp	/^void Interpreter::visitBranchInst(BranchInst &I) {$/;"	f	class:Interpreter
visitCallSite	Execution.cpp	/^void Interpreter::visitCallSite(CallSite CS) {$/;"	f	class:Interpreter
visitExtractElementInst	Execution.cpp	/^void Interpreter::visitExtractElementInst(ExtractElementInst &I) {$/;"	f	class:Interpreter
visitExtractValueInst	Execution.cpp	/^void Interpreter::visitExtractValueInst(ExtractValueInst &I) {$/;"	f	class:Interpreter
visitFCmpInst	Execution.cpp	/^void Interpreter::visitFCmpInst(FCmpInst &I) {$/;"	f	class:Interpreter
visitFPExtInst	Execution.cpp	/^void Interpreter::visitFPExtInst(FPExtInst &I) {$/;"	f	class:Interpreter
visitFPToSIInst	Execution.cpp	/^void Interpreter::visitFPToSIInst(FPToSIInst &I) {$/;"	f	class:Interpreter
visitFPToUIInst	Execution.cpp	/^void Interpreter::visitFPToUIInst(FPToUIInst &I) {$/;"	f	class:Interpreter
visitFPTruncInst	Execution.cpp	/^void Interpreter::visitFPTruncInst(FPTruncInst &I) {$/;"	f	class:Interpreter
visitGetElementPtrInst	Execution.cpp	/^void Interpreter::visitGetElementPtrInst(GetElementPtrInst &I) {$/;"	f	class:Interpreter
visitICmpInst	Execution.cpp	/^void Interpreter::visitICmpInst(ICmpInst &I) {$/;"	f	class:Interpreter
visitIndirectBrInst	Execution.cpp	/^void Interpreter::visitIndirectBrInst(IndirectBrInst &I) {$/;"	f	class:Interpreter
visitInlineAsm	Execution.cpp	/^void Interpreter::visitInlineAsm(CallSite &CS, const std::string &asmstr){$/;"	f	class:Interpreter
visitInsertElementInst	Execution.cpp	/^void Interpreter::visitInsertElementInst(InsertElementInst &I) {$/;"	f	class:Interpreter
visitInsertValueInst	Execution.cpp	/^void Interpreter::visitInsertValueInst(InsertValueInst &I) {$/;"	f	class:Interpreter
visitIntToPtrInst	Execution.cpp	/^void Interpreter::visitIntToPtrInst(IntToPtrInst &I) {$/;"	f	class:Interpreter
visitLShr	Execution.cpp	/^void Interpreter::visitLShr(BinaryOperator &I) {$/;"	f	class:Interpreter
visitLoadInst	Execution.cpp	/^void Interpreter::visitLoadInst(LoadInst &I) {$/;"	f	class:Interpreter
visitPtrToIntInst	Execution.cpp	/^void Interpreter::visitPtrToIntInst(PtrToIntInst &I) {$/;"	f	class:Interpreter
visitReturnInst	Execution.cpp	/^void Interpreter::visitReturnInst(ReturnInst &I) {$/;"	f	class:Interpreter
visitSExtInst	Execution.cpp	/^void Interpreter::visitSExtInst(SExtInst &I) {$/;"	f	class:Interpreter
visitSIToFPInst	Execution.cpp	/^void Interpreter::visitSIToFPInst(SIToFPInst &I) {$/;"	f	class:Interpreter
visitSelectInst	Execution.cpp	/^void Interpreter::visitSelectInst(SelectInst &I) {$/;"	f	class:Interpreter
visitShl	Execution.cpp	/^void Interpreter::visitShl(BinaryOperator &I) {$/;"	f	class:Interpreter
visitShuffleVectorInst	Execution.cpp	/^void Interpreter::visitShuffleVectorInst(ShuffleVectorInst &I){$/;"	f	class:Interpreter
visitStoreInst	Execution.cpp	/^void Interpreter::visitStoreInst(StoreInst &I) {$/;"	f	class:Interpreter
visitSwitchInst	Execution.cpp	/^void Interpreter::visitSwitchInst(SwitchInst &I) {$/;"	f	class:Interpreter
visitTruncInst	Execution.cpp	/^void Interpreter::visitTruncInst(TruncInst &I) {$/;"	f	class:Interpreter
visitUIToFPInst	Execution.cpp	/^void Interpreter::visitUIToFPInst(UIToFPInst &I) {$/;"	f	class:Interpreter
visitUnreachableInst	Execution.cpp	/^void Interpreter::visitUnreachableInst(UnreachableInst &I) {$/;"	f	class:Interpreter
visitVAArgInst	Execution.cpp	/^void Interpreter::visitVAArgInst(VAArgInst &I) {$/;"	f	class:Interpreter
visitZExtInst	Execution.cpp	/^void Interpreter::visitZExtInst(ZExtInst &I) {$/;"	f	class:Interpreter
ExFunc	ExternalFunctions.cpp	/^typedef GenericValue (*ExFunc)(FunctionType *,$/;"	t	file:
ExportedFunctions	ExternalFunctions.cpp	/^static ManagedStatic<std::map<const Function *, ExFunc> > ExportedFunctions;$/;"	v	file:
FuncNames	ExternalFunctions.cpp	/^static std::map<std::string, ExFunc> FuncNames;$/;"	v	file:
FunctionsLock	ExternalFunctions.cpp	/^static ManagedStatic<sys::Mutex> FunctionsLock;$/;"	v	file:
RawFunc	ExternalFunctions.cpp	/^typedef void (*RawFunc)();$/;"	t	file:
RawFunctions	ExternalFunctions.cpp	/^static ManagedStatic<std::map<const Function *, RawFunc> > RawFunctions;$/;"	v	file:
TheInterpreter	ExternalFunctions.cpp	/^static Interpreter *TheInterpreter;$/;"	v	file:
USE_LIBFFI	ExternalFunctions.cpp	72;"	d	file:
USE_LIBFFI	ExternalFunctions.cpp	75;"	d	file:
callExternalFunction	ExternalFunctions.cpp	/^GenericValue Interpreter::callExternalFunction(Function *F,$/;"	f	class:Interpreter
ffiInvoke	ExternalFunctions.cpp	/^static bool ffiInvoke(RawFunc Fn, Function *F,$/;"	f	file:
ffiTypeFor	ExternalFunctions.cpp	/^static ffi_type *ffiTypeFor(Type *Ty) {$/;"	f	file:
ffiValueFor	ExternalFunctions.cpp	/^static void *ffiValueFor(Type *Ty, const GenericValue &AV,$/;"	f	file:
getTypeID	ExternalFunctions.cpp	/^static char getTypeID(Type *Ty) {$/;"	f	file:
initializeExternalFunctions	ExternalFunctions.cpp	/^void Interpreter::initializeExternalFunctions() {$/;"	f	class:Interpreter
lle_X_abort	ExternalFunctions.cpp	/^GenericValue lle_X_abort(FunctionType *FT,$/;"	f	file:
lle_X_atexit	ExternalFunctions.cpp	/^GenericValue lle_X_atexit(FunctionType *FT,$/;"	f	file:
lle_X_exit	ExternalFunctions.cpp	/^GenericValue lle_X_exit(FunctionType *FT,$/;"	f	file:
lle_X_fprintf	ExternalFunctions.cpp	/^GenericValue lle_X_fprintf(FunctionType *FT,$/;"	f	file:
lle_X_memcpy	ExternalFunctions.cpp	/^static GenericValue lle_X_memcpy(FunctionType *FT,$/;"	f	file:
lle_X_memset	ExternalFunctions.cpp	/^static GenericValue lle_X_memset(FunctionType *FT,$/;"	f	file:
lle_X_printf	ExternalFunctions.cpp	/^GenericValue lle_X_printf(FunctionType *FT,$/;"	f	file:
lle_X_scanf	ExternalFunctions.cpp	/^GenericValue lle_X_scanf(FunctionType *FT,$/;"	f	file:
lle_X_sprintf	ExternalFunctions.cpp	/^GenericValue lle_X_sprintf(FunctionType *FT,$/;"	f	file:
lle_X_sscanf	ExternalFunctions.cpp	/^GenericValue lle_X_sscanf(FunctionType *FT,$/;"	f	file:
lookupFunction	ExternalFunctions.cpp	/^static ExFunc lookupFunction(const Function *F) {$/;"	f	file:
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
FBVClock	FBVClock.cpp	/^FBVClock::FBVClock(ClockSystemID cid, int idx) : cid(cid), idx(idx) {$/;"	f	class:FBVClock
add_clock	FBVClock.cpp	/^void FBVClock::add_clock(std::vector<bool> &dst, std::vector<bool> &src){$/;"	f	class:FBVClock
delete_clock_system	FBVClock.cpp	/^void FBVClock::delete_clock_system(ClockSystemID cid){$/;"	f	class:FBVClock
new_clock_system	FBVClock.cpp	/^FBVClock::ClockSystemID FBVClock::new_clock_system(){$/;"	f	class:FBVClock
operator +=	FBVClock.cpp	/^FBVClock &FBVClock::operator+=(FBVClock &c){$/;"	f	class:FBVClock
operator []	FBVClock.cpp	/^bool FBVClock::operator[](int i){$/;"	f	class:FBVClock
sys	FBVClock.cpp	/^std::vector<FBVClock::ClockSystem> FBVClock::sys;$/;"	m	class:FBVClock	file:
to_string	FBVClock.cpp	/^std::string FBVClock::to_string() const{$/;"	f	class:FBVClock
update	FBVClock.cpp	/^void FBVClock::update(ClockSystemID cid, int id){$/;"	f	class:FBVClock
ClockSystem	FBVClock.h	/^    ClockSystem() : allocated(true), time(0) {};$/;"	f	struct:FBVClock::ClockSystem
ClockSystem	FBVClock.h	/^  struct ClockSystem{$/;"	s	class:FBVClock
ClockSystemID	FBVClock.h	/^  typedef int ClockSystemID;$/;"	t	class:FBVClock
FBVClock	FBVClock.h	/^class FBVClock{$/;"	c
__FBVCLOCK_H__	FBVClock.h	23;"	d
allocated	FBVClock.h	/^    bool allocated;$/;"	m	struct:FBVClock::ClockSystem
change_ts	FBVClock.h	/^    std::vector<int> change_ts;$/;"	m	struct:FBVClock::ClockSystem
cid	FBVClock.h	/^  ClockSystemID cid;$/;"	m	class:FBVClock
clocks	FBVClock.h	/^    std::vector<std::vector<bool> > clocks;$/;"	m	struct:FBVClock::ClockSystem
id	FBVClock.h	/^  int id;$/;"	m	class:FBVClock
idx	FBVClock.h	/^  int idx;$/;"	m	class:FBVClock
idx_to_id	FBVClock.h	/^    std::vector<int> idx_to_id;$/;"	m	struct:FBVClock::ClockSystem
invalidate	FBVClock.h	/^  void invalidate() { cid = id = -1; };$/;"	f	class:FBVClock
operator <<	FBVClock.h	/^inline llvm::raw_ostream &operator<<(llvm::raw_ostream &os, FBVClock &c){$/;"	f
operator <<	FBVClock.h	/^inline std::ostream &operator<<(std::ostream &os, FBVClock &c){$/;"	f
size	FBVClock.h	/^  int size() const { return sys[cid].idx_to_id.size(); };$/;"	f	class:FBVClock
sys	FBVClock.h	/^  static std::vector<ClockSystem> sys;$/;"	m	class:FBVClock
time	FBVClock.h	/^    int time;$/;"	m	struct:FBVClock::ClockSystem
update	FBVClock.h	/^  void update() const { update(cid,id); };$/;"	f	class:FBVClock
update_ts	FBVClock.h	/^    std::vector<int> update_ts;$/;"	m	struct:FBVClock::ClockSystem
BOOST_AUTO_TEST_CASE	FBVClock_test.cpp	/^BOOST_AUTO_TEST_CASE(Addition_1){$/;"	f
BOOST_AUTO_TEST_CASE	FBVClock_test.cpp	/^BOOST_AUTO_TEST_CASE(Addition_2){$/;"	f
BOOST_AUTO_TEST_CASE	FBVClock_test.cpp	/^BOOST_AUTO_TEST_CASE(Addition_3){$/;"	f
BOOST_AUTO_TEST_CASE	FBVClock_test.cpp	/^BOOST_AUTO_TEST_CASE(Addition_4){$/;"	f
BOOST_AUTO_TEST_CASE	FBVClock_test.cpp	/^BOOST_AUTO_TEST_CASE(Elem_access_1){$/;"	f
BOOST_AUTO_TEST_CASE	FBVClock_test.cpp	/^BOOST_AUTO_TEST_CASE(Initialization){$/;"	f
GlobalContext	GlobalContext.cpp	/^namespace GlobalContext {$/;"	n	file:
destroy	GlobalContext.cpp	/^  void destroy(){$/;"	f	namespace:GlobalContext
get	GlobalContext.cpp	/^  llvm::LLVMContext &get(){$/;"	f	namespace:GlobalContext
theContext	GlobalContext.cpp	/^    llvm::LLVMContext *theContext = 0;$/;"	m	namespace:GlobalContext::__anon1	file:
GlobalContext	GlobalContext.h	/^namespace GlobalContext {$/;"	n
IID	IID.h	/^  IID() : idx(0) {};$/;"	f	class:IID
IID	IID.h	/^  IID(const Pid_t &p, int i) : pid(p), idx(i) { assert(i >= 0); };$/;"	f	class:IID
IID	IID.h	/^class IID{$/;"	c
__IID_H__	IID.h	23;"	d
get_index	IID.h	/^  int get_index() const { return idx; };$/;"	f	class:IID
get_pid	IID.h	/^  const Pid_t &get_pid() const { return pid; };$/;"	f	class:IID
idx	IID.h	/^  int idx;$/;"	m	class:IID
is_null	IID.h	/^  bool is_null() const { return idx == 0; };$/;"	f	class:IID
operator !=	IID.h	/^  bool operator!=(const IID &iid) const { return !((*this) == iid); };$/;"	f	class:IID
operator +	IID.h	/^  IID operator+(int d) const { return IID(pid,idx+d); };$/;"	f	class:IID
operator ++	IID.h	/^  IID &operator++() { ++idx; return *this; };$/;"	f	class:IID
operator ++	IID.h	/^  IID operator++(int) { return IID(pid,idx++); };$/;"	f	class:IID
operator -	IID.h	/^  IID operator-(int d) const { return IID(pid,idx-d); };$/;"	f	class:IID
operator --	IID.h	/^  IID &operator--() { assert(idx > 0); --idx; return *this; };$/;"	f	class:IID
operator --	IID.h	/^  IID operator--(int) { assert(idx > 0); return IID(pid,idx--); };$/;"	f	class:IID
operator <	IID.h	/^  bool operator<(const IID &iid) const {$/;"	f	class:IID
operator <<	IID.h	/^llvm::raw_ostream &operator<<(llvm::raw_ostream &os, const IID<Pid_t> &iid){$/;"	f
operator <<	IID.h	/^std::ostream &operator<<(std::ostream &os, const IID<Pid_t> &iid){$/;"	f
operator <=	IID.h	/^  bool operator<=(const IID &iid) const { return (*this) < iid || (*this) == iid; };$/;"	f	class:IID
operator ==	IID.h	/^  bool operator==(const IID &iid) const {$/;"	f	class:IID
operator >	IID.h	/^  bool operator>(const IID &iid) const { return iid < (*this); };$/;"	f	class:IID
operator >=	IID.h	/^  bool operator>=(const IID &iid) const { return iid <= (*this); };$/;"	f	class:IID
pid	IID.h	/^  Pid_t pid;$/;"	m	class:IID
valid	IID.h	/^  bool valid() const { return idx > 0; };$/;"	f	class:IID
CheckedFree	Interpreter.cpp	/^static void CheckedFree(void *ptr, std::function<void()> &on_error){$/;"	f	file:
Interpreter	Interpreter.cpp	/^Interpreter::Interpreter(Module *M, TSOPSOTraceBuilder &TB,$/;"	f	class:Interpreter
cf_env	Interpreter.cpp	/^static sigjmp_buf cf_env;$/;"	v	file:
cf_handler	Interpreter.cpp	/^static void cf_handler(int signum){$/;"	f	file:
create	Interpreter.cpp	/^ExecutionEngine *Interpreter::create(Module *M, TSOPSOTraceBuilder &TB,$/;"	f	class:Interpreter
runAtExitHandlers	Interpreter.cpp	/^void Interpreter::runAtExitHandlers () {$/;"	f	class:Interpreter
runFunction	Interpreter.cpp	/^Interpreter::runFunction(Function *F,$/;"	f	class:Interpreter
~Interpreter	Interpreter.cpp	/^Interpreter::~Interpreter() {$/;"	f	class:Interpreter
AllocatedMemHeap	Interpreter.h	/^  std::set<void*> AllocatedMemHeap;$/;"	m	class:llvm::Interpreter
AllocatedMemStack	Interpreter.h	/^  std::set<void*> AllocatedMemStack;$/;"	m	class:llvm::Interpreter
AtExitHandlers	Interpreter.h	/^  std::vector<Function*> AtExitHandlers;$/;"	m	class:llvm::Interpreter
AtomicFunctionCall	Interpreter.h	/^  int AtomicFunctionCall;$/;"	m	class:llvm::Interpreter
AwaitingJoin	Interpreter.h	/^    std::vector<int> AwaitingJoin;$/;"	m	class:llvm::Interpreter::Thread
CPS	Interpreter.h	/^  CPidSystem CPS;$/;"	m	class:llvm::Interpreter
Caller	Interpreter.h	/^  CallSite             Caller;     \/\/ Holds the call that called subframes.$/;"	m	struct:llvm::ExecutionContext
CurBB	Interpreter.h	/^  BasicBlock           *CurBB;      \/\/ The currently executing BB$/;"	m	struct:llvm::ExecutionContext
CurFunction	Interpreter.h	/^  Function             *CurFunction;\/\/ The currently executing function$/;"	m	struct:llvm::ExecutionContext
CurInst	Interpreter.h	/^  BasicBlock::iterator  CurInst;    \/\/ The next instruction to execute$/;"	m	struct:llvm::ExecutionContext
CurrentAlt	Interpreter.h	/^  int CurrentAlt;$/;"	m	class:llvm::Interpreter
CurrentThread	Interpreter.h	/^  int CurrentThread;$/;"	m	class:llvm::Interpreter
DryRun	Interpreter.h	/^  bool DryRun;$/;"	m	class:llvm::Interpreter
DryRunMem	Interpreter.h	/^  std::vector<MBlock> DryRunMem;$/;"	m	class:llvm::Interpreter
ECStack	Interpreter.h	/^    std::vector<ExecutionContext> ECStack;$/;"	m	class:llvm::Interpreter::Thread
ECStack	Interpreter.h	/^  std::vector<ExecutionContext> *ECStack() { return &Threads[CurrentThread].ECStack; };$/;"	f	class:llvm::Interpreter
ExecutionContext	Interpreter.h	/^struct ExecutionContext {$/;"	s	namespace:llvm
ExitValue	Interpreter.h	/^  GenericValue ExitValue;          \/\/ The return value of the called function$/;"	m	class:llvm::Interpreter
FreedMem	Interpreter.h	/^  std::map<void*,IID<CPid> > FreedMem;$/;"	m	class:llvm::Interpreter
GetConstMRef	Interpreter.h	/^  ConstMRef GetConstMRef(void const *Ptr, Type *Ty){$/;"	f	class:llvm::Interpreter
GetMBlock	Interpreter.h	/^  MBlock GetMBlock(void *Ptr, Type *Ty, const GenericValue &Val){$/;"	f	class:llvm::Interpreter
GetMRef	Interpreter.h	/^  MRef GetMRef(void *Ptr, Type *Ty){$/;"	f	class:llvm::Interpreter
IL	Interpreter.h	/^  IntrinsicLowering *IL;$/;"	m	class:llvm::Interpreter
Interpreter	Interpreter.h	/^class Interpreter : public ExecutionEngine, public InstVisitor<Interpreter> {$/;"	c	namespace:llvm
PthreadMutex	Interpreter.h	/^    PthreadMutex() : owner(-1) {};$/;"	f	class:llvm::Interpreter::PthreadMutex
PthreadMutex	Interpreter.h	/^  class PthreadMutex{$/;"	c	class:llvm::Interpreter
PthreadMutexes	Interpreter.h	/^  std::map<void*,PthreadMutex> PthreadMutexes;$/;"	m	class:llvm::Interpreter
RandEng	Interpreter.h	/^    std::minstd_rand RandEng;$/;"	m	class:llvm::Interpreter::Thread
RetVal	Interpreter.h	/^    GenericValue RetVal;$/;"	m	class:llvm::Interpreter::Thread
TB	Interpreter.h	/^  TSOPSOTraceBuilder &TB;$/;"	m	class:llvm::Interpreter
TD	Interpreter.h	/^  DataLayout TD;$/;"	m	class:llvm::Interpreter
Thread	Interpreter.h	/^    Thread() : RandEng(42), pending_mutex_lock(0) {};$/;"	f	class:llvm::Interpreter::Thread
Thread	Interpreter.h	/^  class Thread{$/;"	c	class:llvm::Interpreter
ThreadLocalValues	Interpreter.h	/^    std::map<GlobalValue*,GenericValue> ThreadLocalValues;$/;"	m	class:llvm::Interpreter::Thread
Threads	Interpreter.h	/^  std::vector<Thread> Threads;$/;"	m	class:llvm::Interpreter
ValuePlaneTy	Interpreter.h	/^typedef std::vector<GenericValue> ValuePlaneTy;$/;"	t	namespace:llvm
Values	Interpreter.h	/^  std::map<Value *, GenericValue> Values; \/\/ LLVM values used in this invocation$/;"	m	struct:llvm::ExecutionContext
VarArgs	Interpreter.h	/^  std::vector<GenericValue>  VarArgs; \/\/ Values passed through an ellipsis$/;"	m	struct:llvm::ExecutionContext
__INTERPRETER_H__	Interpreter.h	38;"	d
addAtExitHandler	Interpreter.h	/^  virtual void addAtExitHandler(Function *F) {$/;"	f	class:llvm::Interpreter
checkForCycles	Interpreter.h	/^  virtual bool checkForCycles() const { return TB.check_for_cycles(); };$/;"	f	class:llvm::Interpreter
conf	Interpreter.h	/^  const Configuration &conf;$/;"	m	class:llvm::Interpreter
cpid	Interpreter.h	/^    CPid cpid;$/;"	m	class:llvm::Interpreter::Thread
freeMachineCodeForFunction	Interpreter.h	/^  virtual void freeMachineCodeForFunction(Function *F) { }$/;"	f	class:llvm::Interpreter
gep_type_iterator	Interpreter.h	/^typedef generic_gep_type_iterator<User::const_op_iterator> gep_type_iterator;$/;"	t	namespace:llvm
getFirstVarArg	Interpreter.h	/^  virtual GenericValue *getFirstVarArg () {$/;"	f	class:llvm::Interpreter
getPointerToBasicBlock	Interpreter.h	/^  virtual void *getPointerToBasicBlock(BasicBlock *BB) { return (void*)BB; }$/;"	f	class:llvm::Interpreter
getPointerToFunction	Interpreter.h	/^  virtual void *getPointerToFunction(Function *F) { return (void*)F; }$/;"	f	class:llvm::Interpreter
getPointerToNamedFunction	Interpreter.h	/^  void *getPointerToNamedFunction(const std::string &Name,$/;"	f	class:llvm::Interpreter
getPointerToNamedFunction	Interpreter.h	/^  void *getPointerToNamedFunction(llvm::StringRef Name,$/;"	f	class:llvm::Interpreter
initializeExecutionEngine	Interpreter.h	/^  virtual void initializeExecutionEngine() { }$/;"	f	class:llvm::Interpreter
isLocked	Interpreter.h	/^    bool isLocked() const { return 0 <= owner; };$/;"	f	class:llvm::Interpreter::PthreadMutex
isUnlocked	Interpreter.h	/^    bool isUnlocked() const { return owner < 0; };$/;"	f	class:llvm::Interpreter::PthreadMutex
llvm	Interpreter.h	/^namespace llvm {$/;"	n
lock	Interpreter.h	/^    void lock(int Proc) { assert(owner < 0); owner = Proc; };$/;"	f	class:llvm::Interpreter::PthreadMutex
newThread	Interpreter.h	/^  virtual int newThread(const CPid &cpid){$/;"	f	class:llvm::Interpreter
owner	Interpreter.h	/^    int owner;$/;"	m	class:llvm::Interpreter::PthreadMutex
pending_mutex_lock	Interpreter.h	/^    void *pending_mutex_lock;$/;"	m	class:llvm::Interpreter::Thread
recompileAndRelinkFunction	Interpreter.h	/^  virtual void *recompileAndRelinkFunction(Function *F) {$/;"	f	class:llvm::Interpreter
runAux	Interpreter.h	/^  virtual void runAux(int proc, int aux){$/;"	f	class:llvm::Interpreter
unlock	Interpreter.h	/^    void unlock() { owner = -1; };$/;"	f	class:llvm::Interpreter::PthreadMutex
visitCallInst	Interpreter.h	/^  virtual void visitCallInst(CallInst &I) { visitCallSite (CallSite (&I)); }$/;"	f	class:llvm::Interpreter
visitFenceInst	Interpreter.h	/^  virtual void visitFenceInst(FenceInst &I) { \/* Do nothing *\/ };$/;"	f	class:llvm::Interpreter
visitInstruction	Interpreter.h	/^  virtual void visitInstruction(Instruction &I) {$/;"	f	class:llvm::Interpreter
visitInvokeInst	Interpreter.h	/^  virtual void visitInvokeInst(InvokeInst &I) { visitCallSite (CallSite (&I)); }$/;"	f	class:llvm::Interpreter
visitPHINode	Interpreter.h	/^  virtual void visitPHINode(PHINode &PN) {$/;"	f	class:llvm::Interpreter
waiting	Interpreter.h	/^    VecSet<int> waiting;$/;"	m	class:llvm::Interpreter::PthreadMutex
ID	LoopUnrollPass.cpp	/^char LoopUnrollPass::ID = 0;$/;"	m	class:LoopUnrollPass	file:
getAnalysisUsage	LoopUnrollPass.cpp	/^void LoopUnrollPass::getAnalysisUsage(llvm::AnalysisUsage &AU) const{$/;"	f	class:LoopUnrollPass
make_diverge_block	LoopUnrollPass.cpp	/^llvm::BasicBlock *LoopUnrollPass::make_diverge_block(llvm::Loop *L){$/;"	f	class:LoopUnrollPass
runOnLoop	LoopUnrollPass.cpp	/^bool LoopUnrollPass::runOnLoop(llvm::Loop *L, llvm::LPPassManager &LPM){$/;"	f	class:LoopUnrollPass
ID	LoopUnrollPass.h	/^  static char ID;$/;"	m	class:LoopUnrollPass
LoopUnrollPass	LoopUnrollPass.h	/^  LoopUnrollPass(int depth) : llvm::LoopPass(ID), unroll_depth(depth) {$/;"	f	class:LoopUnrollPass
LoopUnrollPass	LoopUnrollPass.h	/^class LoopUnrollPass : public llvm::LoopPass{$/;"	c
__LOOP_UNROLL_PASS_H__	LoopUnrollPass.h	21;"	d
getPassName	LoopUnrollPass.h	/^  virtual const char *getPassName() const { return "LoopUnrollPass"; };$/;"	f	class:LoopUnrollPass
unroll_depth	LoopUnrollPass.h	/^  int unroll_depth;$/;"	m	class:LoopUnrollPass
MBlock	MRef.cpp	/^MBlock::MBlock(const MBlock &B)$/;"	f	class:MBlock
MBlock	MRef.cpp	/^MBlock::MBlock(const MRef &r) : ref(r), ptr_counter(0) {$/;"	f	class:MBlock
MBlock	MRef.cpp	/^MBlock::MBlock(const MRef &r, int alloc_size) : ref(r) {$/;"	f	class:MBlock
operator =	MRef.cpp	/^MBlock &MBlock::operator=(const MBlock &B){$/;"	f	class:MBlock
overlaps	MRef.cpp	/^bool ConstMRef::overlaps(const ConstMRef &mr) const{$/;"	f	class:ConstMRef
overlaps	MRef.cpp	/^bool ConstMRef::overlaps(const MRef &mr) const{$/;"	f	class:ConstMRef
overlaps	MRef.cpp	/^bool MRef::overlaps(const ConstMRef &mr) const{$/;"	f	class:MRef
overlaps	MRef.cpp	/^bool MRef::overlaps(const MRef &mr) const{$/;"	f	class:MRef
subsetof	MRef.cpp	/^bool ConstMRef::subsetof(const ConstMRef &mr) const{$/;"	f	class:ConstMRef
subsetof	MRef.cpp	/^bool ConstMRef::subsetof(const MRef &mr) const{$/;"	f	class:ConstMRef
subsetof	MRef.cpp	/^bool MRef::subsetof(const ConstMRef &mr) const{$/;"	f	class:MRef
subsetof	MRef.cpp	/^bool MRef::subsetof(const MRef &mr) const{$/;"	f	class:MRef
~MBlock	MRef.cpp	/^MBlock::~MBlock(){$/;"	f	class:MBlock
ConstMRef	MRef.h	/^  ConstMRef(const MRef &R) : ref(R.ref), size(R.size) { assert(0 < size); };$/;"	f	class:ConstMRef
ConstMRef	MRef.h	/^  ConstMRef(const void *r, int sz) : ref(r), size(sz) { assert(0 < size); };$/;"	f	class:ConstMRef
ConstMRef	MRef.h	/^class ConstMRef {$/;"	c
MBlock	MRef.h	/^class MBlock{$/;"	c
MRef	MRef.h	/^  MRef(void *r, int sz) : ref(r), size(sz) { assert(0 < size); };$/;"	f	class:MRef
MRef	MRef.h	/^class MRef {$/;"	c
__MREF_H__	MRef.h	23;"	d
begin	MRef.h	/^  MRef::const_iterator begin() const { return MRef::const_iterator(ref,size,0); };$/;"	f	class:ConstMRef
begin	MRef.h	/^  const_iterator begin() const { return const_iterator(ref,size,0); };$/;"	f	class:MRef
block	MRef.h	/^  void *block;$/;"	m	class:MBlock
const_iterator	MRef.h	/^    const_iterator(void const *ref, int sz, int i) {$/;"	f	class:MRef::const_iterator
const_iterator	MRef.h	/^  class const_iterator{$/;"	c	class:MRef
difference_type	MRef.h	/^    typedef unsigned difference_type;$/;"	t	class:MRef::const_iterator
end	MRef.h	/^  MRef::const_iterator end() const { return MRef::const_iterator(ref,size,size); };$/;"	f	class:ConstMRef
end	MRef.h	/^  const_iterator end() const { return const_iterator(ref,size,size); };$/;"	f	class:MRef
get_block	MRef.h	/^  void *get_block() const { return block; };$/;"	f	class:MBlock
get_ref	MRef.h	/^  const MRef &get_ref() const { return ref; };$/;"	f	class:MBlock
includes	MRef.h	/^  bool includes(void const *bptr) const {$/;"	f	class:ConstMRef
includes	MRef.h	/^  bool includes(void const *bptr) const {$/;"	f	class:MRef
iterator_category	MRef.h	/^    typedef std::bidirectional_iterator_tag iterator_category;$/;"	t	class:MRef::const_iterator
operator !=	MRef.h	/^    bool operator!=(const const_iterator &it) const { return ptr != it.ptr; };$/;"	f	class:MRef::const_iterator
operator !=	MRef.h	/^  bool operator!=(const ConstMRef &ml) const { return ref != ml.ref || size != ml.size; };$/;"	f	class:ConstMRef
operator !=	MRef.h	/^  bool operator!=(const MRef &ml) const { return ref != ml.ref || size != ml.size; };$/;"	f	class:MRef
operator *	MRef.h	/^    void const *operator*() const{ return ptr; };$/;"	f	class:MRef::const_iterator
operator ++	MRef.h	/^    const_iterator &operator++() {$/;"	f	class:MRef::const_iterator
operator ++	MRef.h	/^    const_iterator operator++(int) {$/;"	f	class:MRef::const_iterator
operator --	MRef.h	/^    const_iterator &operator--() {$/;"	f	class:MRef::const_iterator
operator --	MRef.h	/^    const_iterator operator--(int) {$/;"	f	class:MRef::const_iterator
operator <	MRef.h	/^    bool operator<(const const_iterator &it) const { return ptr < it.ptr; };$/;"	f	class:MRef::const_iterator
operator <	MRef.h	/^  bool operator<(const ConstMRef &ml) const { return ref < ml.ref || (ref == ml.ref && size < ml.size); };$/;"	f	class:ConstMRef
operator <	MRef.h	/^  bool operator<(const MRef &ml) const { return ref < ml.ref || (ref == ml.ref && size < ml.size); };$/;"	f	class:MRef
operator <=	MRef.h	/^    bool operator<=(const const_iterator &it) const { return ptr <= it.ptr; };$/;"	f	class:MRef::const_iterator
operator <=	MRef.h	/^  bool operator<=(const ConstMRef &ml) const { return ref <= ml.ref && (ref != ml.ref || size <= ml.size); };$/;"	f	class:ConstMRef
operator <=	MRef.h	/^  bool operator<=(const MRef &ml) const { return ref <= ml.ref && (ref != ml.ref || size <= ml.size); };$/;"	f	class:MRef
operator ==	MRef.h	/^    bool operator==(const const_iterator &it) const { return ptr == it.ptr; };$/;"	f	class:MRef::const_iterator
operator ==	MRef.h	/^  bool operator==(const ConstMRef &ml) const { return ref == ml.ref && size == ml.size; };$/;"	f	class:ConstMRef
operator ==	MRef.h	/^  bool operator==(const MRef &ml) const { return ref == ml.ref && size == ml.size; };$/;"	f	class:MRef
operator >	MRef.h	/^    bool operator>(const const_iterator &it) const { return ptr > it.ptr; };$/;"	f	class:MRef::const_iterator
operator >	MRef.h	/^  bool operator>(const ConstMRef &ml) const { return ref > ml.ref || (ref == ml.ref && size > ml.size); };$/;"	f	class:ConstMRef
operator >	MRef.h	/^  bool operator>(const MRef &ml) const { return ref > ml.ref || (ref == ml.ref && size > ml.size); };$/;"	f	class:MRef
operator >=	MRef.h	/^    bool operator>=(const const_iterator &it) const { return ptr >= it.ptr; };$/;"	f	class:MRef::const_iterator
operator >=	MRef.h	/^  bool operator>=(const ConstMRef &ml) const { return ref >=ml.ref && (ref != ml.ref || size >= ml.size); };$/;"	f	class:ConstMRef
operator >=	MRef.h	/^  bool operator>=(const MRef &ml) const { return ref >=ml.ref && (ref != ml.ref || size >= ml.size); };$/;"	f	class:MRef
pointer	MRef.h	/^    typedef void const ** pointer;$/;"	t	class:MRef::const_iterator
ptr	MRef.h	/^    uint8_t const *ptr;$/;"	m	class:MRef::const_iterator
ptr_counter	MRef.h	/^  int *ptr_counter;$/;"	m	class:MBlock
ref	MRef.h	/^  MRef ref;$/;"	m	class:MBlock
ref	MRef.h	/^  const void *ref;$/;"	m	class:ConstMRef
ref	MRef.h	/^  void *ref;$/;"	m	class:MRef
reference	MRef.h	/^    typedef void const *& reference;$/;"	t	class:MRef::const_iterator
size	MRef.h	/^  int size;$/;"	m	class:ConstMRef
size	MRef.h	/^  int size;$/;"	m	class:MRef
value_type	MRef.h	/^    typedef void const * value_type;$/;"	t	class:MRef::const_iterator
--run_test	Makefile	/^	.\/unittest $(BOOSTTESTFLAGS) --run_test='$(UTEST)'$/;"	m
-leak-check	Makefile	/^	valgrind --leak-check=full .\/unittest $(BOOSTTESTFLAGS) --show_progress --run_test='$(UTEST)'$/;"	m
ACLOCAL	Makefile	/^ACLOCAL = ${SHELL} \/home\/yannis\/Diplomatiki\/nidhugg\/missing aclocal-1.15$/;"	m
ACLOCAL_M4	Makefile	/^ACLOCAL_M4 = $(top_srcdir)\/aclocal.m4$/;"	m
AMTAR	Makefile	/^AMTAR = $${TAR-tar}$/;"	m
AM_DEFAULT_VERBOSITY	Makefile	/^AM_DEFAULT_VERBOSITY = 1$/;"	m
AM_RECURSIVE_TARGETS	Makefile	/^AM_RECURSIVE_TARGETS = check recheck$/;"	m
AM_V_AR	Makefile	/^AM_V_AR = $(am__v_AR_$(V))$/;"	m
AM_V_CC	Makefile	/^AM_V_CC = $(am__v_CC_$(V))$/;"	m
AM_V_CCLD	Makefile	/^AM_V_CCLD = $(am__v_CCLD_$(V))$/;"	m
AM_V_CXX	Makefile	/^AM_V_CXX = $(am__v_CXX_$(V))$/;"	m
AM_V_CXXLD	Makefile	/^AM_V_CXXLD = $(am__v_CXXLD_$(V))$/;"	m
AM_V_GEN	Makefile	/^AM_V_GEN = $(am__v_GEN_$(V))$/;"	m
AM_V_P	Makefile	/^AM_V_P = $(am__v_P_$(V))$/;"	m
AM_V_at	Makefile	/^AM_V_at = $(am__v_at_$(V))$/;"	m
AM_V_lt	Makefile	/^AM_V_lt = $(am__v_lt_$(V))$/;"	m
AR	Makefile	/^AR = ar$/;"	m
ARFLAGS	Makefile	/^ARFLAGS = cru$/;"	m
AUTOCONF	Makefile	/^AUTOCONF = ${SHELL} \/home\/yannis\/Diplomatiki\/nidhugg\/missing autoconf$/;"	m
AUTOHEADER	Makefile	/^AUTOHEADER = ${SHELL} \/home\/yannis\/Diplomatiki\/nidhugg\/missing autoheader$/;"	m
AUTOMAKE	Makefile	/^AUTOMAKE = ${SHELL} \/home\/yannis\/Diplomatiki\/nidhugg\/missing automake-1.15$/;"	m
AUTOMAKE_OPTIONS	Makefile	/^AUTOMAKE_OPTIONS = -Wno-override ## Make autotools quit complaining about explicit rule for nidhuggc.$/;"	m
AWK	Makefile	/^AWK = mawk$/;"	m
BOOSTTESTFLAGS	Makefile	/^BOOSTTESTFLAGS = --report_level=short --log_level=warning$/;"	m
BOOST_CPPFLAGS	Makefile	/^BOOST_CPPFLAGS = -I\/usr\/include$/;"	m
BOOST_LDFLAGS	Makefile	/^BOOST_LDFLAGS = -L\/usr\/lib\/x86_64-linux-gnu$/;"	m
BOOST_UNIT_TEST_FRAMEWORK_LIB	Makefile	/^BOOST_UNIT_TEST_FRAMEWORK_LIB = -lboost_unit_test_framework$/;"	m
CC	Makefile	/^CC = gcc$/;"	m
CCDEPMODE	Makefile	/^CCDEPMODE = depmode=gcc3$/;"	m
CCLD	Makefile	/^CCLD = $(CC)$/;"	m
CFLAGS	Makefile	/^CFLAGS = -g -O2$/;"	m
CLANG	Makefile	/^CLANG = \/usr\/bin\/clang-3.8$/;"	m
CLANGXX	Makefile	/^CLANGXX = \/usr\/bin\/clang++-3.8$/;"	m
COMPILE	Makefile	/^COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \\$/;"	m
CONFIG_CLEAN_FILES	Makefile	/^CONFIG_CLEAN_FILES =$/;"	m
CONFIG_CLEAN_VPATH_FILES	Makefile	/^CONFIG_CLEAN_VPATH_FILES =$/;"	m
CONFIG_HEADER	Makefile	/^CONFIG_HEADER = $(top_builddir)\/config.h$/;"	m
CPPFLAGS	Makefile	/^CPPFLAGS = $/;"	m
CTAGS	Makefile	/^CTAGS = ctags$/;"	m
CXX	Makefile	/^CXX = g++$/;"	m
CXXCOMPILE	Makefile	/^CXXCOMPILE = $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) \\$/;"	m
CXXCPP	Makefile	/^CXXCPP = g++ -E$/;"	m
CXXDEPMODE	Makefile	/^CXXDEPMODE = depmode=gcc3$/;"	m
CXXFLAGS	Makefile	/^CXXFLAGS =  -DNDEBUG -std=c++11 -I\/usr\/lib\/llvm-3.8\/include -std=c++0x -fPIC -fvisibility-inlines-hidden -Wall -W -Wno-unused-parameter -Wwrite-strings -Wcast-qual -Wno-missing-field-initializers -pedantic -Wno-long-long -Wno-maybe-uninitialized -Wdelete-non-virtual-dtor -Wno-comment -std=c++11 -ffunction-sections -fdata-sections -O2 -g -DNDEBUG  -D_GNU_SOURCE -D__STDC_CONSTANT_MACROS -D__STDC_FORMAT_MACROS -D__STDC_LIMIT_MACROS  -DNDEBUG$/;"	m
CXXLD	Makefile	/^CXXLD = $(CXX)$/;"	m
CXXLINK	Makefile	/^CXXLINK = $(CXXLD) $(AM_CXXFLAGS) $(CXXFLAGS) $(AM_LDFLAGS) $(LDFLAGS) \\$/;"	m
CYGPATH_W	Makefile	/^CYGPATH_W = echo$/;"	m
DEFAULT_INCLUDES	Makefile	/^DEFAULT_INCLUDES = -I. -I$(top_builddir)$/;"	m
DEFS	Makefile	/^DEFS = -DHAVE_CONFIG_H$/;"	m
DEPDIR	Makefile	/^DEPDIR = .deps$/;"	m
DISTFILES	Makefile	/^DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)$/;"	m
DIST_COMMON	Makefile	/^DIST_COMMON = $(srcdir)\/Makefile.am $(am__DIST_COMMON)$/;"	m
DIST_SOURCES	Makefile	/^DIST_SOURCES = $(libnidhugg_a_SOURCES) $(nidhugg_SOURCES) \\$/;"	m
ECHO_C	Makefile	/^ECHO_C = $/;"	m
ECHO_N	Makefile	/^ECHO_N = -n$/;"	m
ECHO_T	Makefile	/^ECHO_T = $/;"	m
EGREP	Makefile	/^EGREP = \/bin\/grep -E$/;"	m
ETAGS	Makefile	/^ETAGS = etags$/;"	m
EXEEXT	Makefile	/^EXEEXT = $/;"	m
EXTRA_PROGRAMS	Makefile	/^EXTRA_PROGRAMS = nidhuggc$(EXEEXT)$/;"	m
GIT	Makefile	/^GIT = \/usr\/bin\/git$/;"	m
GREP	Makefile	/^GREP = \/bin\/grep$/;"	m
HAVE_CXX11	Makefile	/^HAVE_CXX11 = $/;"	m
INSTALL	Makefile	/^INSTALL = \/usr\/bin\/install -c$/;"	m
INSTALL_DATA	Makefile	/^INSTALL_DATA = ${INSTALL} -m 644$/;"	m
INSTALL_HEADER	Makefile	/^INSTALL_HEADER = $(INSTALL_DATA)$/;"	m
INSTALL_PROGRAM	Makefile	/^INSTALL_PROGRAM = ${INSTALL}$/;"	m
INSTALL_SCRIPT	Makefile	/^INSTALL_SCRIPT = ${INSTALL}$/;"	m
INSTALL_STRIP_PROGRAM	Makefile	/^INSTALL_STRIP_PROGRAM = $(install_sh) -c -s$/;"	m
LDFLAGS	Makefile	/^LDFLAGS =  -L\/usr\/lib\/llvm-3.8\/lib  -lrt -ldl -ltinfo -lpthread -lz -lm$/;"	m
LIBOBJS	Makefile	/^LIBOBJS = $/;"	m
LIBRARIES	Makefile	/^LIBRARIES = $(noinst_LIBRARIES)$/;"	m
LIBS	Makefile	/^LIBS = -lffi -ldl -lm -lz -lpthread -ltinfo -ldl -lrt  -lLLVMLTO -lLLVMObjCARCOpts -lLLVMSymbolize -lLLVMDebugInfoPDB -lLLVMDebugInfoDWARF -lLLVMXCoreDisassembler -lLLVMXCoreCodeGen -lLLVMXCoreDesc -lLLVMXCoreInfo -lLLVMXCoreAsmPrinter -lLLVMSystemZDisassembler -lLLVMSystemZCodeGen -lLLVMSystemZAsmParser -lLLVMSystemZDesc -lLLVMSystemZInfo -lLLVMSystemZAsmPrinter -lLLVMSparcDisassembler -lLLVMSparcCodeGen -lLLVMSparcAsmParser -lLLVMSparcDesc -lLLVMSparcInfo -lLLVMSparcAsmPrinter -lLLVMPowerPCDisassembler -lLLVMPowerPCCodeGen -lLLVMPowerPCAsmParser -lLLVMPowerPCDesc -lLLVMPowerPCInfo -lLLVMPowerPCAsmPrinter -lLLVMNVPTXCodeGen -lLLVMNVPTXDesc -lLLVMNVPTXInfo -lLLVMNVPTXAsmPrinter -lLLVMMSP430CodeGen -lLLVMMSP430Desc -lLLVMMSP430Info -lLLVMMSP430AsmPrinter -lLLVMMipsDisassembler -lLLVMMipsCodeGen -lLLVMMipsAsmParser -lLLVMMipsDesc -lLLVMMipsInfo -lLLVMMipsAsmPrinter -lLLVMHexagonDisassembler -lLLVMHexagonCodeGen -lLLVMHexagonAsmParser -lLLVMHexagonDesc -lLLVMHexagonInfo -lLLVMCppBackendCodeGen -lLLVMCppBackendInfo -lLLVMBPFCodeGen -lLLVMBPFDesc -lLLVMBPFInfo -lLLVMBPFAsmPrinter -lLLVMARMDisassembler -lLLVMARMCodeGen -lLLVMARMAsmParser -lLLVMARMDesc -lLLVMARMInfo -lLLVMARMAsmPrinter -lLLVMAMDGPUCodeGen -lLLVMAMDGPUAsmParser -lLLVMAMDGPUDesc -lLLVMAMDGPUUtils -lLLVMAMDGPUInfo -lLLVMAMDGPUAsmPrinter -lLLVMAArch64Disassembler -lLLVMAArch64CodeGen -lLLVMAArch64AsmParser -lLLVMAArch64Desc -lLLVMAArch64Info -lLLVMAArch64AsmPrinter -lLLVMAArch64Utils -lLLVMMIRParser -lLLVMLibDriver -lLLVMOption -lLLVMTableGen -lLLVMLineEditor -lLLVMX86Disassembler -lLLVMX86AsmParser -lLLVMX86CodeGen -lLLVMSelectionDAG -lLLVMAsmPrinter -lLLVMX86Desc -lLLVMMCDisassembler -lLLVMX86Info -lLLVMX86AsmPrinter -lLLVMX86Utils -lLLVMMCJIT -lLLVMPasses -lLLVMipo -lLLVMVectorize -lLLVMLinker -lLLVMIRReader -lLLVMAsmParser -lLLVMDebugInfoCodeView -lLLVMInterpreter -lLLVMCodeGen -lLLVMScalarOpts -lLLVMInstCombine -lLLVMInstrumentation -lLLVMProfileData -lLLVMBitWriter -lLLVMOrcJIT -lLLVMTransformUtils -lLLVMExecutionEngine -lLLVMTarget -lLLVMAnalysis -lLLVMRuntimeDyld -lLLVMObject -lLLVMMCParser -lLLVMBitReader -lLLVMMC -lLLVMCore -lLLVMSupport -L\/usr\/lib\/llvm-3.8\/lib  -lrt -ldl -ltinfo -lpthread -lz -lm$/;"	m
LINK	Makefile	/^LINK = $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) $(LDFLAGS) -o $@$/;"	m
LLVMCONFIG	Makefile	/^LLVMCONFIG = \/usr\/bin\/llvm-config$/;"	m
LOG_COMPILE	Makefile	/^LOG_COMPILE = $(LOG_COMPILER) $(AM_LOG_FLAGS) $(LOG_FLAGS)$/;"	m
LOG_DRIVER	Makefile	/^LOG_DRIVER = $(SHELL) $(top_srcdir)\/test-driver$/;"	m
LTLIBOBJS	Makefile	/^LTLIBOBJS = $/;"	m
MAKEINFO	Makefile	/^MAKEINFO = ${SHELL} \/home\/yannis\/Diplomatiki\/nidhugg\/missing makeinfo$/;"	m
MKDIR_P	Makefile	/^MKDIR_P = \/bin\/mkdir -p$/;"	m
NIDHUGGCBIN	Makefile	/^NIDHUGGCBIN = nidhuggc$/;"	m
NORMAL_INSTALL	Makefile	/^NORMAL_INSTALL = :$/;"	m
NORMAL_UNINSTALL	Makefile	/^NORMAL_UNINSTALL = :$/;"	m
OBJEXT	Makefile	/^OBJEXT = o$/;"	m
PACKAGE	Makefile	/^PACKAGE = nidhugg$/;"	m
PACKAGE_BUGREPORT	Makefile	/^PACKAGE_BUGREPORT = carl.leonardsson@gmail.com$/;"	m
PACKAGE_NAME	Makefile	/^PACKAGE_NAME = Nidhugg$/;"	m
PACKAGE_STRING	Makefile	/^PACKAGE_STRING = Nidhugg 0.2$/;"	m
PACKAGE_TARNAME	Makefile	/^PACKAGE_TARNAME = nidhugg$/;"	m
PACKAGE_URL	Makefile	/^PACKAGE_URL = $/;"	m
PACKAGE_VERSION	Makefile	/^PACKAGE_VERSION = 0.2$/;"	m
PATH_SEPARATOR	Makefile	/^PATH_SEPARATOR = :$/;"	m
POST_INSTALL	Makefile	/^POST_INSTALL = :$/;"	m
POST_UNINSTALL	Makefile	/^POST_UNINSTALL = :$/;"	m
PRE_INSTALL	Makefile	/^PRE_INSTALL = :$/;"	m
PRE_UNINSTALL	Makefile	/^PRE_UNINSTALL = :$/;"	m
PROGRAMS	Makefile	/^PROGRAMS = $(bin_PROGRAMS)$/;"	m
PYTHON	Makefile	/^PYTHON = \/usr\/bin\/python3$/;"	m
PYTHON_EXEC_PREFIX	Makefile	/^PYTHON_EXEC_PREFIX = ${exec_prefix}$/;"	m
PYTHON_PLATFORM	Makefile	/^PYTHON_PLATFORM = linux$/;"	m
PYTHON_PREFIX	Makefile	/^PYTHON_PREFIX = ${prefix}$/;"	m
PYTHON_VERSION	Makefile	/^PYTHON_VERSION = 3.5$/;"	m
RANLIB	Makefile	/^RANLIB = ranlib$/;"	m
RECHECK_LOGS	Makefile	/^RECHECK_LOGS = $(TEST_LOGS)$/;"	m
SET_MAKE	Makefile	/^SET_MAKE = $/;"	m
SHELL	Makefile	/^SHELL = \/bin\/bash$/;"	m
SOURCES	Makefile	/^SOURCES = $(libnidhugg_a_SOURCES) $(nidhugg_SOURCES) \\$/;"	m
STRIP	Makefile	/^STRIP = $/;"	m
TESTS	Makefile	/^TESTS = unittest$(EXEEXT)$/;"	m
TEST_EXTENSIONS	Makefile	/^TEST_EXTENSIONS =  .test$/;"	m
TEST_LOGS	Makefile	/^TEST_LOGS = $(am__test_logs2:.test.log=.log)$/;"	m
TEST_LOG_COMPILE	Makefile	/^TEST_LOG_COMPILE = $(TEST_LOG_COMPILER) $(AM_TEST_LOG_FLAGS) \\$/;"	m
TEST_LOG_DRIVER	Makefile	/^TEST_LOG_DRIVER = $(SHELL) $(top_srcdir)\/test-driver$/;"	m
TEST_SUITE_LOG	Makefile	/^TEST_SUITE_LOG = test-suite.log$/;"	m
UTEST	Makefile	/^UTEST ?= *$/;"	m
VERSION	Makefile	/^VERSION = 0.2$/;"	m
abs_builddir	Makefile	/^abs_builddir = \/home\/yannis\/Diplomatiki\/nidhugg\/src$/;"	m
abs_srcdir	Makefile	/^abs_srcdir = \/home\/yannis\/Diplomatiki\/nidhugg\/src$/;"	m
abs_top_builddir	Makefile	/^abs_top_builddir = \/home\/yannis\/Diplomatiki\/nidhugg$/;"	m
abs_top_srcdir	Makefile	/^abs_top_srcdir = \/home\/yannis\/Diplomatiki\/nidhugg$/;"	m
ac_ct_AR	Makefile	/^ac_ct_AR = ar$/;"	m
ac_ct_CC	Makefile	/^ac_ct_CC = gcc$/;"	m
ac_ct_CXX	Makefile	/^ac_ct_CXX = g++$/;"	m
am__DIST_COMMON	Makefile	/^am__DIST_COMMON = $(srcdir)\/Makefile.in $(top_srcdir)\/depcomp \\$/;"	m
am__aclocal_m4_deps	Makefile	/^am__aclocal_m4_deps = $(top_srcdir)\/m4\/ax_cxx_compile_stdcxx_11.m4 \\$/;"	m
am__base_list	Makefile	/^am__base_list = \\$/;"	m
am__can_run_installinfo	Makefile	/^am__can_run_installinfo = \\$/;"	m
am__cd	Makefile	/^am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd$/;"	m
am__check_pre	Makefile	/^am__check_pre = \\$/;"	m
am__common_driver_flags	Makefile	/^am__common_driver_flags = \\$/;"	m
am__configure_deps	Makefile	/^am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \\$/;"	m
am__copy_in_global_log_rx	Makefile	/^am__copy_in_global_log_rx = ^[ 	]*:copy-in-global-log:[ 	]*$/;"	m
am__create_global_log	Makefile	/^am__create_global_log = $(AWK) ' \\$/;"	m
am__define_uniq_tagged_files	Makefile	/^am__define_uniq_tagged_files = \\$/;"	m
am__depfiles_maybe	Makefile	/^am__depfiles_maybe = depfiles$/;"	m
am__global_test_result_rx	Makefile	/^am__global_test_result_rx = ^[ 	]*:global-test-result:[ 	]*$/;"	m
am__include	Makefile	/^am__include = include$/;"	m
am__install_max	Makefile	/^am__install_max = 40$/;"	m
am__installdirs	Makefile	/^am__installdirs = "$(DESTDIR)$(bindir)"$/;"	m
am__is_gnu_make	Makefile	/^am__is_gnu_make = { \\$/;"	m
am__leading_dot	Makefile	/^am__leading_dot = .$/;"	m
am__list_recheck_tests	Makefile	/^am__list_recheck_tests = $(AWK) '{ \\$/;"	m
am__make_dryrun	Makefile	/^am__make_dryrun = (target_option=n; $(am__make_running_with_option))$/;"	m
am__make_keepgoing	Makefile	/^am__make_keepgoing = (target_option=k; $(am__make_running_with_option))$/;"	m
am__make_running_with_option	Makefile	/^am__make_running_with_option = \\$/;"	m
am__mv	Makefile	/^am__mv = mv -f$/;"	m
am__nobase_list	Makefile	/^am__nobase_list = $(am__nobase_strip_setup); \\$/;"	m
am__nobase_strip	Makefile	/^am__nobase_strip = \\$/;"	m
am__nobase_strip_setup	Makefile	/^am__nobase_strip_setup = \\$/;"	m
am__quote	Makefile	/^am__quote = $/;"	m
am__recheck_rx	Makefile	/^am__recheck_rx = ^[ 	]*:recheck:[ 	]*$/;"	m
am__rst_title	Makefile	/^am__rst_title = { sed 's\/.*\/   &   \/;h;s\/.\/=\/g;p;x;s\/ *$$\/\/;p;g' && echo; }$/;"	m
am__set_TESTS_bases	Makefile	/^am__set_TESTS_bases = \\$/;"	m
am__set_b	Makefile	/^am__set_b = \\$/;"	m
am__sh_e_setup	Makefile	/^am__sh_e_setup = case $$- in *e*) set +e;; esac$/;"	m
am__strip_dir	Makefile	/^am__strip_dir = f=`echo $$p | sed -e 's|^.*\/||'`;$/;"	m
am__tagged_files	Makefile	/^am__tagged_files = $(HEADERS) $(SOURCES) $(TAGS_FILES) $(LISP)$/;"	m
am__tar	Makefile	/^am__tar = $${TAR-tar} chof - "$$tardir"$/;"	m
am__test_logs1	Makefile	/^am__test_logs1 = $(TESTS:=.log)$/;"	m
am__test_logs2	Makefile	/^am__test_logs2 = $(am__test_logs1:.log=.log)$/;"	m
am__tty_colors	Makefile	/^am__tty_colors = { \\$/;"	m
am__tty_colors_dummy	Makefile	/^am__tty_colors_dummy = \\$/;"	m
am__uninstall_files_from_dir	Makefile	/^am__uninstall_files_from_dir = { \\$/;"	m
am__uniquify_input	Makefile	/^am__uniquify_input = $(AWK) '\\$/;"	m
am__untar	Makefile	/^am__untar = $${TAR-tar} xf -$/;"	m
am__v_AR_	Makefile	/^am__v_AR_ = $(am__v_AR_$(AM_DEFAULT_VERBOSITY))$/;"	m
am__v_AR_0	Makefile	/^am__v_AR_0 = @echo "  AR      " $@;$/;"	m
am__v_AR_1	Makefile	/^am__v_AR_1 = $/;"	m
am__v_CCLD_	Makefile	/^am__v_CCLD_ = $(am__v_CCLD_$(AM_DEFAULT_VERBOSITY))$/;"	m
am__v_CCLD_0	Makefile	/^am__v_CCLD_0 = @echo "  CCLD    " $@;$/;"	m
am__v_CCLD_1	Makefile	/^am__v_CCLD_1 = $/;"	m
am__v_CC_	Makefile	/^am__v_CC_ = $(am__v_CC_$(AM_DEFAULT_VERBOSITY))$/;"	m
am__v_CC_0	Makefile	/^am__v_CC_0 = @echo "  CC      " $@;$/;"	m
am__v_CC_1	Makefile	/^am__v_CC_1 = $/;"	m
am__v_CXXLD_	Makefile	/^am__v_CXXLD_ = $(am__v_CXXLD_$(AM_DEFAULT_VERBOSITY))$/;"	m
am__v_CXXLD_0	Makefile	/^am__v_CXXLD_0 = @echo "  CXXLD   " $@;$/;"	m
am__v_CXXLD_1	Makefile	/^am__v_CXXLD_1 = $/;"	m
am__v_CXX_	Makefile	/^am__v_CXX_ = $(am__v_CXX_$(AM_DEFAULT_VERBOSITY))$/;"	m
am__v_CXX_0	Makefile	/^am__v_CXX_0 = @echo "  CXX     " $@;$/;"	m
am__v_CXX_1	Makefile	/^am__v_CXX_1 = $/;"	m
am__v_GEN_	Makefile	/^am__v_GEN_ = $(am__v_GEN_$(AM_DEFAULT_VERBOSITY))$/;"	m
am__v_GEN_0	Makefile	/^am__v_GEN_0 = @echo "  GEN     " $@;$/;"	m
am__v_GEN_1	Makefile	/^am__v_GEN_1 = $/;"	m
am__v_P_	Makefile	/^am__v_P_ = $(am__v_P_$(AM_DEFAULT_VERBOSITY))$/;"	m
am__v_P_0	Makefile	/^am__v_P_0 = false$/;"	m
am__v_P_1	Makefile	/^am__v_P_1 = :$/;"	m
am__v_at_	Makefile	/^am__v_at_ = $(am__v_at_$(AM_DEFAULT_VERBOSITY))$/;"	m
am__v_at_0	Makefile	/^am__v_at_0 = @$/;"	m
am__v_at_1	Makefile	/^am__v_at_1 = $/;"	m
am__v_lt_	Makefile	/^am__v_lt_ = $(am__v_lt_$(AM_DEFAULT_VERBOSITY))$/;"	m
am__v_lt_0	Makefile	/^am__v_lt_0 = --silent$/;"	m
am__v_lt_1	Makefile	/^am__v_lt_1 = $/;"	m
am__vpath_adj	Makefile	/^am__vpath_adj = case $$p in \\$/;"	m
am__vpath_adj_setup	Makefile	/^am__vpath_adj_setup = srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`;$/;"	m
am_libnidhugg_a_OBJECTS	Makefile	/^am_libnidhugg_a_OBJECTS = libnidhugg_a-AddLibPass.$(OBJEXT) \\$/;"	m
am_nidhugg_OBJECTS	Makefile	/^am_nidhugg_OBJECTS = nidhugg-main.$(OBJEXT)$/;"	m
am_nidhuggc_OBJECTS	Makefile	/^am_nidhuggc_OBJECTS =$/;"	m
am_unittest_OBJECTS	Makefile	/^am_unittest_OBJECTS = ARM_test.$(OBJEXT) ARM_test2.$(OBJEXT) \\$/;"	m
bin_PROGRAMS	Makefile	/^bin_PROGRAMS = nidhugg$(EXEEXT) nidhuggc$/;"	m
bindir	Makefile	/^bindir = ${exec_prefix}\/bin$/;"	m
build	Makefile	/^build = x86_64-pc-linux-gnu$/;"	m
build_alias	Makefile	/^build_alias = $/;"	m
build_cpu	Makefile	/^build_cpu = x86_64$/;"	m
build_os	Makefile	/^build_os = linux-gnu$/;"	m
build_triplet	Makefile	/^build_triplet = x86_64-pc-linux-gnu$/;"	m
build_vendor	Makefile	/^build_vendor = pc$/;"	m
builddir	Makefile	/^builddir = .$/;"	m
check_PROGRAMS	Makefile	/^check_PROGRAMS = unittest$(EXEEXT)$/;"	m
datadir	Makefile	/^datadir = ${datarootdir}$/;"	m
datarootdir	Makefile	/^datarootdir = ${prefix}\/share$/;"	m
depcomp	Makefile	/^depcomp = $(SHELL) $(top_srcdir)\/depcomp$/;"	m
docdir	Makefile	/^docdir = ${datarootdir}\/doc\/${PACKAGE_TARNAME}$/;"	m
dvidir	Makefile	/^dvidir = ${docdir}$/;"	m
exec_prefix	Makefile	/^exec_prefix = ${prefix}$/;"	m
host	Makefile	/^host = x86_64-pc-linux-gnu$/;"	m
host_alias	Makefile	/^host_alias = $/;"	m
host_cpu	Makefile	/^host_cpu = x86_64$/;"	m
host_os	Makefile	/^host_os = linux-gnu$/;"	m
host_triplet	Makefile	/^host_triplet = x86_64-pc-linux-gnu$/;"	m
host_vendor	Makefile	/^host_vendor = pc$/;"	m
htmldir	Makefile	/^htmldir = ${docdir}$/;"	m
includedir	Makefile	/^includedir = ${prefix}\/include$/;"	m
infodir	Makefile	/^infodir = ${datarootdir}\/info$/;"	m
install_sh	Makefile	/^install_sh = ${SHELL} \/home\/yannis\/Diplomatiki\/nidhugg\/install-sh$/;"	m
install_sh_DATA	Makefile	/^install_sh_DATA = $(install_sh) -c -m 644$/;"	m
install_sh_PROGRAM	Makefile	/^install_sh_PROGRAM = $(install_sh) -c$/;"	m
install_sh_SCRIPT	Makefile	/^install_sh_SCRIPT = $(install_sh) -c$/;"	m
libdir	Makefile	/^libdir = ${exec_prefix}\/lib$/;"	m
libexecdir	Makefile	/^libexecdir = ${exec_prefix}\/libexec$/;"	m
libnidhugg_a_AR	Makefile	/^libnidhugg_a_AR = $(AR) $(ARFLAGS)$/;"	m
libnidhugg_a_CXXFLAGS	Makefile	/^libnidhugg_a_CXXFLAGS = -fno-rtti$/;"	m
libnidhugg_a_LIBADD	Makefile	/^libnidhugg_a_LIBADD =$/;"	m
libnidhugg_a_OBJECTS	Makefile	/^libnidhugg_a_OBJECTS = $(am_libnidhugg_a_OBJECTS)$/;"	m
libnidhugg_a_SOURCES	Makefile	/^libnidhugg_a_SOURCES = \\$/;"	m
localedir	Makefile	/^localedir = ${datarootdir}\/locale$/;"	m
localstatedir	Makefile	/^localstatedir = ${prefix}\/var$/;"	m
mandir	Makefile	/^mandir = ${datarootdir}\/man$/;"	m
mkdir_p	Makefile	/^mkdir_p = $(MKDIR_P)$/;"	m
mkinstalldirs	Makefile	/^mkinstalldirs = $(install_sh) -d$/;"	m
nidhugg_CXXFLAGS	Makefile	/^nidhugg_CXXFLAGS = -fno-rtti$/;"	m
nidhugg_DEPENDENCIES	Makefile	/^nidhugg_DEPENDENCIES = libnidhugg.a$/;"	m
nidhugg_LDADD	Makefile	/^nidhugg_LDADD = libnidhugg.a$/;"	m
nidhugg_LINK	Makefile	/^nidhugg_LINK = $(CXXLD) $(nidhugg_CXXFLAGS) $(CXXFLAGS) $(AM_LDFLAGS) \\$/;"	m
nidhugg_OBJECTS	Makefile	/^nidhugg_OBJECTS = $(am_nidhugg_OBJECTS)$/;"	m
nidhugg_SOURCES	Makefile	/^nidhugg_SOURCES = main.cpp$/;"	m
nidhuggc_LDADD	Makefile	/^nidhuggc_LDADD = $(LDADD)$/;"	m
nidhuggc_OBJECTS	Makefile	/^nidhuggc_OBJECTS = $(am_nidhuggc_OBJECTS)$/;"	m
nidhuggc_SOURCES	Makefile	/^nidhuggc_SOURCES = nidhuggc.py$/;"	m
noinst_LIBRARIES	Makefile	/^noinst_LIBRARIES = libnidhugg.a$/;"	m
oldincludedir	Makefile	/^oldincludedir = \/usr\/include$/;"	m
pdfdir	Makefile	/^pdfdir = ${docdir}$/;"	m
pkgdatadir	Makefile	/^pkgdatadir = $(datadir)\/nidhugg$/;"	m
pkgincludedir	Makefile	/^pkgincludedir = $(includedir)\/nidhugg$/;"	m
pkglibdir	Makefile	/^pkglibdir = $(libdir)\/nidhugg$/;"	m
pkglibexecdir	Makefile	/^pkglibexecdir = $(libexecdir)\/nidhugg$/;"	m
pkgpyexecdir	Makefile	/^pkgpyexecdir = ${pyexecdir}\/nidhugg$/;"	m
pkgpythondir	Makefile	/^pkgpythondir = ${pythondir}\/nidhugg$/;"	m
prefix	Makefile	/^prefix = \/usr\/local$/;"	m
program_transform_name	Makefile	/^program_transform_name = s,x,x,$/;"	m
psdir	Makefile	/^psdir = ${docdir}$/;"	m
pyexecdir	Makefile	/^pyexecdir = ${exec_prefix}\/lib\/python3.5\/site-packages$/;"	m
pythondir	Makefile	/^pythondir = ${prefix}\/lib\/python3.5\/site-packages$/;"	m
runstatedir	Makefile	/^runstatedir = ${localstatedir}\/run$/;"	m
sbindir	Makefile	/^sbindir = ${exec_prefix}\/sbin$/;"	m
sharedstatedir	Makefile	/^sharedstatedir = ${prefix}\/com$/;"	m
srcdir	Makefile	/^srcdir = .$/;"	m
subdir	Makefile	/^subdir = src$/;"	m
sysconfdir	Makefile	/^sysconfdir = ${prefix}\/etc$/;"	m
target_alias	Makefile	/^target_alias = $/;"	m
top_build_prefix	Makefile	/^top_build_prefix = ..\/$/;"	m
top_builddir	Makefile	/^top_builddir = ..$/;"	m
top_srcdir	Makefile	/^top_srcdir = ..$/;"	m
transform	Makefile	/^transform = $(program_transform_name)$/;"	m
unittest_DEPENDENCIES	Makefile	/^unittest_DEPENDENCIES = libnidhugg.a$/;"	m
unittest_LDADD	Makefile	/^unittest_LDADD = -lboost_unit_test_framework libnidhugg.a$/;"	m
unittest_OBJECTS	Makefile	/^unittest_OBJECTS = $(am_unittest_OBJECTS)$/;"	m
unittest_SOURCES	Makefile	/^unittest_SOURCES = \\$/;"	m
TB	POWERARMTraceBuilder.cpp	/^template class PATB_impl::TB<PATB_impl::ARM,PATB_impl::CB_ARM,PATB_impl::ARMEvent>;$/;"	m	class:PATB_impl	typeref:class:PATB_impl::	file:
TB	POWERARMTraceBuilder.cpp	/^template class PATB_impl::TB<PATB_impl::POWER,PATB_impl::CB_POWER,PATB_impl::POWEREvent>;$/;"	m	class:PATB_impl	typeref:class:PATB_impl::	file:
get_indentation	POWERARMTraceBuilder.cpp	/^static std::vector<std::string> get_indentation(int n_procs, int ind){$/;"	f	file:
source_line	POWERARMTraceBuilder.cpp	/^bool PATB_impl::TraceRecorder::source_line(int proc, const llvm::MDNode *md, std::string *srcln, int *id_len){$/;"	f	class:PATB_impl::TraceRecorder
to_string	POWERARMTraceBuilder.cpp	/^std::string PATB_impl::PATrace::to_string(int _ind) const{$/;"	f	class:PATB_impl::PATrace
to_string	POWERARMTraceBuilder.cpp	/^std::string PATB_impl::TraceRecorder::to_string(int ind) const{$/;"	f	class:PATB_impl::TraceRecorder
trace_commit	POWERARMTraceBuilder.cpp	/^void PATB_impl::TraceRecorder::trace_commit(const IID<int> &iid,$/;"	f	class:PATB_impl::TraceRecorder
trace_register_error	POWERARMTraceBuilder.cpp	/^void PATB_impl::TraceRecorder::trace_register_error(int proc, const std::string &err_msg){$/;"	f	class:PATB_impl::TraceRecorder
trace_register_external_function_call	POWERARMTraceBuilder.cpp	/^void PATB_impl::TraceRecorder::trace_register_external_function_call(int proc, const std::string &fname, const llvm::MDNode *md){$/;"	f	class:PATB_impl::TraceRecorder
trace_register_function_entry	POWERARMTraceBuilder.cpp	/^void PATB_impl::TraceRecorder::trace_register_function_entry(int proc, const std::string &fname, const llvm::MDNode *md){$/;"	f	class:PATB_impl::TraceRecorder
trace_register_function_exit	POWERARMTraceBuilder.cpp	/^void PATB_impl::TraceRecorder::trace_register_function_exit(int proc){$/;"	f	class:PATB_impl::TraceRecorder
trace_register_metadata	POWERARMTraceBuilder.cpp	/^void PATB_impl::TraceRecorder::trace_register_metadata(int proc, const llvm::MDNode *md){$/;"	f	class:PATB_impl::TraceRecorder
ARM	POWERARMTraceBuilder.h	/^    ARM,$/;"	e	enum:PATB_impl::MemoryModel
ARMTraceBuilder	POWERARMTraceBuilder.h	/^typedef PATB_impl::TB<PATB_impl::ARM,PATB_impl::CB_ARM,PATB_impl::ARMEvent> ARMTraceBuilder;$/;"	t
Accid	POWERARMTraceBuilder.h	/^  typedef int Accid;$/;"	t	class:POWERARMTraceBuilder
CB_0	POWERARMTraceBuilder.h	/^    CB_0,$/;"	e	enum:PATB_impl::CB_T
CB_ARM	POWERARMTraceBuilder.h	/^    CB_ARM,$/;"	e	enum:PATB_impl::CB_T
CB_POWER	POWERARMTraceBuilder.h	/^    CB_POWER$/;"	e	enum:PATB_impl::CB_T
CB_T	POWERARMTraceBuilder.h	/^  enum CB_T {$/;"	g	namespace:PATB_impl
EIEIO	POWERARMTraceBuilder.h	/^  enum FenceType { ISYNC, EIEIO, LWSYNC, SYNC };$/;"	e	enum:POWERARMTraceBuilder::FenceType
FenceType	POWERARMTraceBuilder.h	/^  enum FenceType { ISYNC, EIEIO, LWSYNC, SYNC };$/;"	g	class:POWERARMTraceBuilder
ISYNC	POWERARMTraceBuilder.h	/^  enum FenceType { ISYNC, EIEIO, LWSYNC, SYNC };$/;"	e	enum:POWERARMTraceBuilder::FenceType
LWSYNC	POWERARMTraceBuilder.h	/^  enum FenceType { ISYNC, EIEIO, LWSYNC, SYNC };$/;"	e	enum:POWERARMTraceBuilder::FenceType
Ldaccid	POWERARMTraceBuilder.h	/^  typedef int Ldaccid;$/;"	t	class:POWERARMTraceBuilder
MemoryModel	POWERARMTraceBuilder.h	/^  enum MemoryModel {$/;"	g	namespace:PATB_impl
PATB_impl	POWERARMTraceBuilder.h	/^namespace PATB_impl{$/;"	n
POWER	POWERARMTraceBuilder.h	/^    POWER$/;"	e	enum:PATB_impl::MemoryModel
POWERARMTraceBuilder	POWERARMTraceBuilder.h	/^  POWERARMTraceBuilder(const Configuration &conf = Configuration::default_conf)$/;"	f	class:POWERARMTraceBuilder
POWERARMTraceBuilder	POWERARMTraceBuilder.h	/^class POWERARMTraceBuilder : public TraceBuilder {$/;"	c
POWERTraceBuilder	POWERARMTraceBuilder.h	/^typedef PATB_impl::TB<PATB_impl::POWER,PATB_impl::CB_POWER,PATB_impl::POWEREvent> POWERTraceBuilder;$/;"	t
SYNC	POWERARMTraceBuilder.h	/^  enum FenceType { ISYNC, EIEIO, LWSYNC, SYNC };$/;"	e	enum:POWERARMTraceBuilder::FenceType
Staccid	POWERARMTraceBuilder.h	/^  typedef int Staccid;$/;"	t	class:POWERARMTraceBuilder
__POWER_TRACE_BUILDER_H__	POWERARMTraceBuilder.h	23;"	d
check_for_cycles	POWERARMTraceBuilder.h	/^  virtual bool check_for_cycles(){$/;"	f	class:POWERARMTraceBuilder
ldreqfun_t	POWERARMTraceBuilder.h	/^  typedef std::function<bool(const MBlock&)> ldreqfun_t;$/;"	t	class:POWERARMTraceBuilder
~POWERARMTraceBuilder	POWERARMTraceBuilder.h	/^  virtual ~POWERARMTraceBuilder(){};$/;"	f	class:POWERARMTraceBuilder
ARMEvent	POWERARMTraceBuilder_decl.h	/^    ARMEvent(int load_count, int store_count,$/;"	f	class:PATB_impl::ARMEvent
ARMEvent	POWERARMTraceBuilder_decl.h	/^  class ARMEvent : public PAEvent{$/;"	c	namespace:PATB_impl
Access	POWERARMTraceBuilder_decl.h	/^    Access(Type tp)$/;"	f	class:PATB_impl::Access
Access	POWERARMTraceBuilder_decl.h	/^  class Access{$/;"	c	namespace:PATB_impl
Branch	POWERARMTraceBuilder_decl.h	/^  class Branch{$/;"	c	namespace:PATB_impl
ByteAccess	POWERARMTraceBuilder_decl.h	/^    ByteAccess(Type tp, void *addr) \/\/ Load or store$/;"	f	class:PATB_impl::ByteAccess
ByteAccess	POWERARMTraceBuilder_decl.h	/^    ByteAccess(void *addr, char data) \/\/ Store$/;"	f	class:PATB_impl::ByteAccess
ByteAccess	POWERARMTraceBuilder_decl.h	/^  class ByteAccess{$/;"	c	namespace:PATB_impl
C	POWERARMTraceBuilder_decl.h	/^    VecSet<IID<int> > C;$/;"	m	struct:PATB_impl::ExtraHB
CPS	POWERARMTraceBuilder_decl.h	/^    CPidSystem CPS;$/;"	m	class:PATB_impl::TB
Choice	POWERARMTraceBuilder_decl.h	/^      Choice(IID<int> src) : co_pos(-1), src(src) {}; \/\/ source choice$/;"	f	class:PATB_impl::Param::Choice
Choice	POWERARMTraceBuilder_decl.h	/^      Choice(int cp) : co_pos(cp) { assert(0 <= cp); }; \/\/ coherence choice$/;"	f	class:PATB_impl::Param::Choice
Choice	POWERARMTraceBuilder_decl.h	/^    class Choice{$/;"	c	class:PATB_impl::Param
Committed	POWERARMTraceBuilder_decl.h	/^      Committed() : consumed(true) {};$/;"	f	struct:PATB_impl::TraceRecorder::Committed
Committed	POWERARMTraceBuilder_decl.h	/^    struct Committed{$/;"	s	class:PATB_impl::TraceRecorder
EHB	POWERARMTraceBuilder_decl.h	/^    ExtraHB EHB;$/;"	m	struct:PATB_impl::ExtraRel
ER	POWERARMTraceBuilder_decl.h	/^    ExtraRel ER;$/;"	m	class:PATB_impl::Param
EventFilledStatus	POWERARMTraceBuilder_decl.h	/^    enum EventFilledStatus {$/;"	g	class:PATB_impl::PAEvent
Evt	POWERARMTraceBuilder_decl.h	/^    struct Evt{$/;"	s	class:PATB_impl::PATrace
ExtraHB	POWERARMTraceBuilder_decl.h	/^  struct ExtraHB{$/;"	s	namespace:PATB_impl
ExtraRel	POWERARMTraceBuilder_decl.h	/^  struct ExtraRel{$/;"	s	namespace:PATB_impl
I	POWERARMTraceBuilder_decl.h	/^    VecSet<IID<int> > I;$/;"	m	struct:PATB_impl::ExtraHB
LOAD	POWERARMTraceBuilder_decl.h	/^      LOAD,$/;"	e	enum:PATB_impl::Access::Type
LOAD	POWERARMTraceBuilder_decl.h	/^      LOAD,$/;"	e	enum:PATB_impl::ByteAccess::Type
Line	POWERARMTraceBuilder_decl.h	/^    struct Line{$/;"	s	class:PATB_impl::TraceRecorder
Mem	POWERARMTraceBuilder_decl.h	/^    Mem() : loads(1) {};$/;"	f	class:PATB_impl::Mem
Mem	POWERARMTraceBuilder_decl.h	/^  class Mem{$/;"	c	namespace:PATB_impl
PAEvent	POWERARMTraceBuilder_decl.h	/^    PAEvent(int load_count, int store_count,$/;"	f	class:PATB_impl::PAEvent
PAEvent	POWERARMTraceBuilder_decl.h	/^  class PAEvent{$/;"	c	namespace:PATB_impl
PARAM_STAR	POWERARMTraceBuilder_decl.h	/^      PARAM_STAR$/;"	e	enum:PATB_impl::Branch::ParamType
PARAM_WR	POWERARMTraceBuilder_decl.h	/^      PARAM_WR,$/;"	e	enum:PATB_impl::Branch::ParamType
PATB_impl	POWERARMTraceBuilder_decl.h	/^namespace PATB_impl{$/;"	n
PATrace	POWERARMTraceBuilder_decl.h	/^    PATrace(const std::vector<Evt> &events,$/;"	f	class:PATB_impl::PATrace
PATrace	POWERARMTraceBuilder_decl.h	/^  class PATrace : public Trace {$/;"	c	namespace:PATB_impl
PEvent	POWERARMTraceBuilder_decl.h	/^    struct PEvent{$/;"	s	class:PATB_impl::Branch
POWEREvent	POWERARMTraceBuilder_decl.h	/^    POWEREvent(int load_count, int store_count,$/;"	f	class:PATB_impl::POWEREvent
POWEREvent	POWERARMTraceBuilder_decl.h	/^  class POWEREvent : public PAEvent{$/;"	c	namespace:PATB_impl
Param	POWERARMTraceBuilder_decl.h	/^  class Param{$/;"	c	namespace:PATB_impl
ParamType	POWERARMTraceBuilder_decl.h	/^    enum ParamType {$/;"	g	class:PATB_impl::Branch
RECALC_LOAD	POWERARMTraceBuilder_decl.h	/^      RECALC_LOAD,$/;"	e	enum:PATB_impl::PAEvent::RecalcParams
RECALC_NO	POWERARMTraceBuilder_decl.h	/^      RECALC_NO,$/;"	e	enum:PATB_impl::PAEvent::RecalcParams
RECALC_PARAM	POWERARMTraceBuilder_decl.h	/^      RECALC_PARAM$/;"	e	enum:PATB_impl::PAEvent::RecalcParams
RECALC_STAR	POWERARMTraceBuilder_decl.h	/^      RECALC_STAR,$/;"	e	enum:PATB_impl::PAEvent::RecalcParams
RecalcParams	POWERARMTraceBuilder_decl.h	/^    enum RecalcParams {$/;"	g	class:PATB_impl::PAEvent
Rel	POWERARMTraceBuilder_decl.h	/^  class Rel{$/;"	c	namespace:PATB_impl
Relations	POWERARMTraceBuilder_decl.h	/^  class Relations{$/;"	c	namespace:PATB_impl
STATUS_COMPLETE	POWERARMTraceBuilder_decl.h	/^      STATUS_COMPLETE$/;"	e	enum:PATB_impl::PAEvent::EventFilledStatus
STATUS_EMPTY	POWERARMTraceBuilder_decl.h	/^      STATUS_EMPTY,$/;"	e	enum:PATB_impl::PAEvent::EventFilledStatus
STATUS_PARAMETER	POWERARMTraceBuilder_decl.h	/^      STATUS_PARAMETER,$/;"	e	enum:PATB_impl::PAEvent::EventFilledStatus
STORE	POWERARMTraceBuilder_decl.h	/^      STORE$/;"	e	enum:PATB_impl::Access::Type
STORE	POWERARMTraceBuilder_decl.h	/^      STORE$/;"	e	enum:PATB_impl::ByteAccess::Type
TB	POWERARMTraceBuilder_decl.h	/^  class TB : public POWERARMTraceBuilder {$/;"	c	namespace:PATB_impl
TRec	POWERARMTraceBuilder_decl.h	/^    TraceRecorder TRec;$/;"	m	class:PATB_impl::TB
Thread	POWERARMTraceBuilder_decl.h	/^      Thread()$/;"	f	class:PATB_impl::TB::Thread
Thread	POWERARMTraceBuilder_decl.h	/^    class Thread{$/;"	c	class:PATB_impl::TB
TraceRecorder	POWERARMTraceBuilder_decl.h	/^    TraceRecorder(const std::vector<CPid> *cpids) : Trace({}), cpids(cpids), active(false) {};$/;"	f	class:PATB_impl::TraceRecorder
TraceRecorder	POWERARMTraceBuilder_decl.h	/^  class TraceRecorder : public Trace{$/;"	c	namespace:PATB_impl
Type	POWERARMTraceBuilder_decl.h	/^    enum Type {$/;"	g	class:PATB_impl::Access
Type	POWERARMTraceBuilder_decl.h	/^    enum Type {$/;"	g	class:PATB_impl::ByteAccess
__POWERARM_TRACE_BUILDER_H__	POWERARMTraceBuilder_decl.h	26;"	d
access_tgts	POWERARMTraceBuilder_decl.h	/^    VecSet<void*> access_tgts;$/;"	m	class:PATB_impl::PAEvent
accesses	POWERARMTraceBuilder_decl.h	/^      std::vector<Access> accesses;$/;"	m	struct:PATB_impl::TraceRecorder::Committed
accesses	POWERARMTraceBuilder_decl.h	/^    std::vector<Access> accesses;$/;"	m	class:PATB_impl::PAEvent
activate	POWERARMTraceBuilder_decl.h	/^    void activate() { active = true; };$/;"	f	class:PATB_impl::TraceRecorder
active	POWERARMTraceBuilder_decl.h	/^    bool active;$/;"	m	class:PATB_impl::TraceRecorder
addr	POWERARMTraceBuilder_decl.h	/^    MRef addr;$/;"	m	class:PATB_impl::Access
addr	POWERARMTraceBuilder_decl.h	/^    void *addr;$/;"	m	class:PATB_impl::ByteAccess
addr_deps	POWERARMTraceBuilder_decl.h	/^    VecSet<int> addr_deps;$/;"	m	class:PATB_impl::PAEvent
addr_known	POWERARMTraceBuilder_decl.h	/^    bool addr_known;$/;"	m	class:PATB_impl::Access
addr_known_prefix	POWERARMTraceBuilder_decl.h	/^      int addr_known_prefix;$/;"	m	class:PATB_impl::TB::Thread
after_C	POWERARMTraceBuilder_decl.h	/^    VecSet<IID<int> > after_C;$/;"	m	struct:PATB_impl::ExtraHB
after_I	POWERARMTraceBuilder_decl.h	/^    VecSet<IID<int> > after_I;$/;"	m	struct:PATB_impl::ExtraHB
all_addr_and_data_known	POWERARMTraceBuilder_decl.h	/^    bool all_addr_and_data_known() const {$/;"	f	class:PATB_impl::PAEvent
baccesses	POWERARMTraceBuilder_decl.h	/^      std::vector<ByteAccess> baccesses;$/;"	m	struct:PATB_impl::TraceRecorder::Committed
baccesses	POWERARMTraceBuilder_decl.h	/^    std::vector<ByteAccess> baccesses;$/;"	m	class:PATB_impl::PAEvent
branch	POWERARMTraceBuilder_decl.h	/^    std::vector<PEvent> branch;$/;"	m	class:PATB_impl::Branch
branch_end	POWERARMTraceBuilder_decl.h	/^    int branch_start, branch_end;$/;"	m	class:PATB_impl::PAEvent
branch_start	POWERARMTraceBuilder_decl.h	/^    int branch_start, branch_end;$/;"	m	class:PATB_impl::PAEvent
bwd	POWERARMTraceBuilder_decl.h	/^    VecSet<IID<int> > bwd;$/;"	m	class:PATB_impl::Rel
cb_bwd	POWERARMTraceBuilder_decl.h	/^    BVClock cb_bwd;$/;"	m	class:PATB_impl::PAEvent
cc0	POWERARMTraceBuilder_decl.h	/^    Rel cc0;$/;"	m	class:PATB_impl::Relations
check_for_cycles	POWERARMTraceBuilder_decl.h	/^    virtual bool check_for_cycles(){$/;"	f	class:PATB_impl::TB
choices	POWERARMTraceBuilder_decl.h	/^    std::vector<Choice> choices;$/;"	m	class:PATB_impl::Param
ci0	POWERARMTraceBuilder_decl.h	/^    Rel ci0;$/;"	m	class:PATB_impl::Relations
clear	POWERARMTraceBuilder_decl.h	/^    void clear() { lines.clear(); last_committed.consumed = true; fun_call_stack.clear(); };$/;"	f	class:PATB_impl::TraceRecorder
clock_index	POWERARMTraceBuilder_decl.h	/^    int clock_index;$/;"	m	class:PATB_impl::PAEvent
co	POWERARMTraceBuilder_decl.h	/^    Rel co;$/;"	m	class:PATB_impl::Relations
co_pos	POWERARMTraceBuilder_decl.h	/^      int co_pos;$/;"	m	class:PATB_impl::Param::Choice
coherence	POWERARMTraceBuilder_decl.h	/^    std::vector<IID<int> > coherence;$/;"	m	class:PATB_impl::Mem
colour	POWERARMTraceBuilder_decl.h	/^    int colour;$/;"	m	class:PATB_impl::PAEvent
com	POWERARMTraceBuilder_decl.h	/^    Rel com;$/;"	m	class:PATB_impl::Relations
committed	POWERARMTraceBuilder_decl.h	/^    bool committed;$/;"	m	class:PATB_impl::PAEvent
committed_prefix	POWERARMTraceBuilder_decl.h	/^      int committed_prefix;$/;"	m	class:PATB_impl::TB::Thread
conf	POWERARMTraceBuilder_decl.h	/^    Configuration conf;$/;"	m	class:PATB_impl::PATrace
consumed	POWERARMTraceBuilder_decl.h	/^      bool consumed;$/;"	m	struct:PATB_impl::TraceRecorder::Committed
cpids	POWERARMTraceBuilder_decl.h	/^    const std::vector<CPid> *cpids;$/;"	m	class:PATB_impl::TraceRecorder
cpids	POWERARMTraceBuilder_decl.h	/^    std::vector<CPid> cpids;$/;"	m	class:PATB_impl::PATrace
cpids	POWERARMTraceBuilder_decl.h	/^    std::vector<CPid> cpids;$/;"	m	class:PATB_impl::TB
ctrl_deps	POWERARMTraceBuilder_decl.h	/^      VecSet<int> ctrl_deps;$/;"	m	class:PATB_impl::TB::Thread
ctrl_deps	POWERARMTraceBuilder_decl.h	/^    VecSet<int> ctrl_deps;$/;"	m	class:PATB_impl::PAEvent
ctrl_isync_deps	POWERARMTraceBuilder_decl.h	/^      VecSet<int> ctrl_isync_deps;$/;"	m	class:PATB_impl::TB::Thread
ctrl_isync_deps	POWERARMTraceBuilder_decl.h	/^    VecSet<int> ctrl_isync_deps;$/;"	m	class:PATB_impl::PAEvent
cur_branch	POWERARMTraceBuilder_decl.h	/^    Branch cur_branch;$/;"	m	class:PATB_impl::PAEvent
cur_param	POWERARMTraceBuilder_decl.h	/^    Param cur_param;$/;"	m	class:PATB_impl::PAEvent
data	POWERARMTraceBuilder_decl.h	/^    MBlock data;$/;"	m	class:PATB_impl::Access
data	POWERARMTraceBuilder_decl.h	/^    char data;$/;"	m	class:PATB_impl::ByteAccess
data_deps	POWERARMTraceBuilder_decl.h	/^    VecSet<int> data_deps;$/;"	m	class:PATB_impl::PAEvent
data_known	POWERARMTraceBuilder_decl.h	/^    bool data_known;$/;"	m	class:PATB_impl::Access
data_known	POWERARMTraceBuilder_decl.h	/^    bool data_known;$/;"	m	class:PATB_impl::ByteAccess
deactivate	POWERARMTraceBuilder_decl.h	/^    void deactivate() { active = false; };$/;"	f	class:PATB_impl::TraceRecorder
eieio_idx_after	POWERARMTraceBuilder_decl.h	/^    int eieio_idx_after;$/;"	m	class:PATB_impl::PAEvent
eieio_idx_before	POWERARMTraceBuilder_decl.h	/^    int eieio_idx_before;$/;"	m	class:PATB_impl::PAEvent
error_is_real	POWERARMTraceBuilder_decl.h	/^    bool error_is_real(Error &e) const {$/;"	f	class:PATB_impl::TB
events	POWERARMTraceBuilder_decl.h	/^    std::vector<Evt> events;$/;"	m	class:PATB_impl::PATrace
fch	POWERARMTraceBuilder_decl.h	/^    std::vector<std::vector<Event> > fch;$/;"	m	class:PATB_impl::TB
fch_count	POWERARMTraceBuilder_decl.h	/^      int fch_count;$/;"	m	class:PATB_impl::TB::Thread
fetch_count	POWERARMTraceBuilder_decl.h	/^    int fetch_count;$/;"	m	class:PATB_impl::TB
filled_status	POWERARMTraceBuilder_decl.h	/^    EventFilledStatus filled_status;$/;"	m	class:PATB_impl::PAEvent
fun_call_stack	POWERARMTraceBuilder_decl.h	/^    std::vector<std::vector<std::string> > fun_call_stack;$/;"	m	class:PATB_impl::TraceRecorder
fwd	POWERARMTraceBuilder_decl.h	/^    VecSet<IID<int> > fwd;$/;"	m	class:PATB_impl::Rel
get_evt	POWERARMTraceBuilder_decl.h	/^    Event &get_evt(const IID<int> &iid) {$/;"	f	class:PATB_impl::TB
get_evt	POWERARMTraceBuilder_decl.h	/^    const Event &get_evt(const IID<int> &iid) const {$/;"	f	class:PATB_impl::TB
get_prefix_index	POWERARMTraceBuilder_decl.h	/^    int get_prefix_index(const IID<int> &iid){$/;"	f	class:PATB_impl::TB
has_load	POWERARMTraceBuilder_decl.h	/^    bool has_load;$/;"	m	class:PATB_impl::PAEvent
has_load_req	POWERARMTraceBuilder_decl.h	/^    bool has_load_req() const {$/;"	f	class:PATB_impl::PAEvent
has_store	POWERARMTraceBuilder_decl.h	/^    bool has_store;$/;"	m	class:PATB_impl::PAEvent
hb	POWERARMTraceBuilder_decl.h	/^    Rel hb; \/\/ Actually the transitive, irreflexive closure hb+$/;"	m	class:PATB_impl::Relations
ii0	POWERARMTraceBuilder_decl.h	/^    Rel ii0;$/;"	m	class:PATB_impl::Relations
iid	POWERARMTraceBuilder_decl.h	/^      IID<int> iid;$/;"	m	struct:PATB_impl::Branch::PEvent
iid	POWERARMTraceBuilder_decl.h	/^      IID<int> iid;$/;"	m	struct:PATB_impl::PATrace::Evt
iid	POWERARMTraceBuilder_decl.h	/^      IID<int> iid;$/;"	m	struct:PATB_impl::TraceRecorder::Committed
iid	POWERARMTraceBuilder_decl.h	/^    IID<int> iid;$/;"	m	class:PATB_impl::PAEvent
in_locked_branch	POWERARMTraceBuilder_decl.h	/^    bool in_locked_branch() const { return 0 <= branch_start; };$/;"	f	class:PATB_impl::PAEvent
is_aborted	POWERARMTraceBuilder_decl.h	/^    bool is_aborted;$/;"	m	class:PATB_impl::TB
is_active	POWERARMTraceBuilder_decl.h	/^    bool is_active() const { return active; };$/;"	f	class:PATB_impl::TraceRecorder
is_coherence_choice	POWERARMTraceBuilder_decl.h	/^      bool is_coherence_choice() const { return 0 <= co_pos; };$/;"	f	class:PATB_impl::Param::Choice
is_source_choice	POWERARMTraceBuilder_decl.h	/^      bool is_source_choice() const { return !is_coherence_choice(); };$/;"	f	class:PATB_impl::Param::Choice
last_committed	POWERARMTraceBuilder_decl.h	/^    Committed last_committed;$/;"	m	class:PATB_impl::TraceRecorder
last_fetched_eieio_idx	POWERARMTraceBuilder_decl.h	/^      int last_fetched_eieio_idx;$/;"	m	class:PATB_impl::TB::Thread
last_fetched_lwsync_idx	POWERARMTraceBuilder_decl.h	/^      int last_fetched_lwsync_idx;$/;"	m	class:PATB_impl::TB::Thread
last_fetched_sync_idx	POWERARMTraceBuilder_decl.h	/^      int last_fetched_sync_idx;$/;"	m	class:PATB_impl::TB::Thread
lines	POWERARMTraceBuilder_decl.h	/^    std::vector<Line> lines;$/;"	m	class:PATB_impl::TraceRecorder
ln	POWERARMTraceBuilder_decl.h	/^      std::string ln;$/;"	m	struct:PATB_impl::TraceRecorder::Line
load_count	POWERARMTraceBuilder_decl.h	/^    int load_count;$/;"	m	class:PATB_impl::PAEvent
load_req	POWERARMTraceBuilder_decl.h	/^    POWERARMTraceBuilder::ldreqfun_t *load_req;$/;"	m	class:PATB_impl::Access
loads	POWERARMTraceBuilder_decl.h	/^    std::vector<VecSet<IID<int> > > loads;$/;"	m	class:PATB_impl::Mem
lwsync_idx_after	POWERARMTraceBuilder_decl.h	/^    int lwsync_idx_after;$/;"	m	class:PATB_impl::PAEvent
lwsync_idx_before	POWERARMTraceBuilder_decl.h	/^    int lwsync_idx_before;$/;"	m	class:PATB_impl::PAEvent
mem	POWERARMTraceBuilder_decl.h	/^    std::map<void*,Mem<MemMod,CB,Event> > mem;$/;"	m	class:PATB_impl::TB
new_branches	POWERARMTraceBuilder_decl.h	/^    VecSet<Branch> new_branches;$/;"	m	class:PATB_impl::PAEvent
new_params	POWERARMTraceBuilder_decl.h	/^    std::vector<Param> new_params;$/;"	m	class:PATB_impl::PAEvent
next_clock_index	POWERARMTraceBuilder_decl.h	/^    int next_clock_index;$/;"	m	class:PATB_impl::TB
operator <	POWERARMTraceBuilder_decl.h	/^      bool operator<(const Choice &C) const{$/;"	f	class:PATB_impl::Param::Choice
operator <	POWERARMTraceBuilder_decl.h	/^      bool operator<(const PEvent &e) const { return iid < e.iid || (iid == e.iid && param < e.param); };$/;"	f	struct:PATB_impl::Branch::PEvent
operator <	POWERARMTraceBuilder_decl.h	/^    bool operator<(const Branch &B) const{$/;"	f	class:PATB_impl::Branch
operator <	POWERARMTraceBuilder_decl.h	/^    bool operator<(const Param &B) const { return choices < B.choices; };$/;"	f	class:PATB_impl::Param
operator ==	POWERARMTraceBuilder_decl.h	/^      bool operator==(const Choice &C) const{$/;"	f	class:PATB_impl::Param::Choice
operator ==	POWERARMTraceBuilder_decl.h	/^      bool operator==(const PEvent &e) const { return iid == e.iid && param == e.param; };$/;"	f	struct:PATB_impl::Branch::PEvent
operator ==	POWERARMTraceBuilder_decl.h	/^    bool operator==(const Branch &B) const{$/;"	f	class:PATB_impl::Branch
operator ==	POWERARMTraceBuilder_decl.h	/^    bool operator==(const Param &B) const { return choices == B.choices; };$/;"	f	class:PATB_impl::Param
param	POWERARMTraceBuilder_decl.h	/^      Param param;$/;"	m	struct:PATB_impl::Branch::PEvent
param	POWERARMTraceBuilder_decl.h	/^      Param param;$/;"	m	struct:PATB_impl::PATrace::Evt
param	POWERARMTraceBuilder_decl.h	/^      Param param;$/;"	m	struct:PATB_impl::TraceRecorder::Committed
param_type	POWERARMTraceBuilder_decl.h	/^    ParamType param_type;$/;"	m	class:PATB_impl::Branch
poloc	POWERARMTraceBuilder_decl.h	/^    Rel poloc;$/;"	m	class:PATB_impl::Relations
poloc_bwd_computed	POWERARMTraceBuilder_decl.h	/^    bool poloc_bwd_computed;$/;"	m	class:PATB_impl::PAEvent
prefix	POWERARMTraceBuilder_decl.h	/^    std::vector<IID<int> > prefix;$/;"	m	class:PATB_impl::TB
proc	POWERARMTraceBuilder_decl.h	/^      int proc;$/;"	m	struct:PATB_impl::TraceRecorder::Line
prop	POWERARMTraceBuilder_decl.h	/^    Rel prop;$/;"	m	class:PATB_impl::Relations
prop	POWERARMTraceBuilder_decl.h	/^    std::map<IID<int>,VecSet<IID<int> > > prop;$/;"	m	struct:PATB_impl::ExtraRel
recalc_params	POWERARMTraceBuilder_decl.h	/^    RecalcParams recalc_params;$/;"	m	class:PATB_impl::PAEvent
recalc_params_load_src	POWERARMTraceBuilder_decl.h	/^    IID<int> recalc_params_load_src;$/;"	m	class:PATB_impl::PAEvent
rel	POWERARMTraceBuilder_decl.h	/^    Relations rel;$/;"	m	class:PATB_impl::PAEvent
rel	POWERARMTraceBuilder_decl.h	/^    Relations rel;$/;"	m	class:PATB_impl::Param
rf	POWERARMTraceBuilder_decl.h	/^    Rel rf;$/;"	m	class:PATB_impl::Relations
satisfied	POWERARMTraceBuilder_decl.h	/^    bool satisfied() const { return addr_known && (type != STORE || data_known); };$/;"	f	class:PATB_impl::Access
satisfied	POWERARMTraceBuilder_decl.h	/^    bool satisfied() const { return type != STORE || data_known; };$/;"	f	class:PATB_impl::ByteAccess
sched_count	POWERARMTraceBuilder_decl.h	/^    int sched_count;$/;"	m	class:PATB_impl::TB
src	POWERARMTraceBuilder_decl.h	/^      IID<int> src;$/;"	m	class:PATB_impl::Param::Choice
string_rep	POWERARMTraceBuilder_decl.h	/^    std::string string_rep;$/;"	m	class:PATB_impl::PATrace
sync_idx_after	POWERARMTraceBuilder_decl.h	/^    int sync_idx_after;$/;"	m	class:PATB_impl::PAEvent
sync_idx_before	POWERARMTraceBuilder_decl.h	/^    int sync_idx_before;$/;"	m	class:PATB_impl::PAEvent
threads	POWERARMTraceBuilder_decl.h	/^    std::vector<Thread> threads;$/;"	m	class:PATB_impl::TB
to_string	POWERARMTraceBuilder_decl.h	/^    std::string to_string(const Param &B) const{$/;"	f	class:PATB_impl::PAEvent
type	POWERARMTraceBuilder_decl.h	/^    Type type;$/;"	m	class:PATB_impl::Access
type	POWERARMTraceBuilder_decl.h	/^    Type type;$/;"	m	class:PATB_impl::ByteAccess
uncommitted_nonblocking_count	POWERARMTraceBuilder_decl.h	/^    int uncommitted_nonblocking_count;$/;"	m	class:PATB_impl::TB
unknown_addr_count	POWERARMTraceBuilder_decl.h	/^    int unknown_addr_count;$/;"	m	class:PATB_impl::PAEvent
unknown_data_count	POWERARMTraceBuilder_decl.h	/^    int unknown_data_count;$/;"	m	class:PATB_impl::PAEvent
values	POWERARMTraceBuilder_decl.h	/^      std::vector<MBlock> values;$/;"	m	struct:PATB_impl::TraceRecorder::Committed
~PATrace	POWERARMTraceBuilder_decl.h	/^    virtual ~PATrace(){};$/;"	f	class:PATB_impl::PATrace
FLOAT_VECTOR_FUNCTION	POWERExecution.cpp	749;"	d	file:
FLOAT_VECTOR_OP	POWERExecution.cpp	756;"	d	file:
IMPLEMENT_BINARY_OPERATOR	POWERExecution.cpp	94;"	d	file:
IMPLEMENT_FCMP	POWERExecution.cpp	347;"	d	file:
IMPLEMENT_INTEGER_ICMP	POWERExecution.cpp	158;"	d	file:
IMPLEMENT_POINTER_ICMP	POWERExecution.cpp	176;"	d	file:
IMPLEMENT_SCALAR_NANS	POWERExecution.cpp	382;"	d	file:
IMPLEMENT_UNORDERED	POWERExecution.cpp	500;"	d	file:
IMPLEMENT_VAARG	POWERExecution.cpp	1846;"	d	file:
IMPLEMENT_VECTOR_FCMP	POWERExecution.cpp	360;"	d	file:
IMPLEMENT_VECTOR_FCMP_T	POWERExecution.cpp	352;"	d	file:
IMPLEMENT_VECTOR_INTEGER_ICMP	POWERExecution.cpp	163;"	d	file:
IMPLEMENT_VECTOR_UNORDERED	POWERExecution.cpp	511;"	d	file:
INTEGER_VECTOR_FUNCTION	POWERExecution.cpp	742;"	d	file:
INTEGER_VECTOR_OPERATION	POWERExecution.cpp	735;"	d	file:
MASK_VECTOR_NANS	POWERExecution.cpp	407;"	d	file:
MASK_VECTOR_NANS_T	POWERExecution.cpp	395;"	d	file:
SwitchToNewBasicBlock	POWERExecution.cpp	/^void POWERInterpreter::SwitchToNewBasicBlock(llvm::BasicBlock *Dest, ExecutionContext &SF){$/;"	f	class:POWERInterpreter
abort	POWERExecution.cpp	/^void POWERInterpreter::abort(){$/;"	f	class:POWERInterpreter
callAssertFail	POWERExecution.cpp	/^void POWERInterpreter::callAssertFail(llvm::Function *F){$/;"	f	class:POWERInterpreter
callAssume	POWERExecution.cpp	/^void POWERInterpreter::callAssume(llvm::Function *F){$/;"	f	class:POWERInterpreter
callFunction	POWERExecution.cpp	/^void POWERInterpreter::callFunction(llvm::Function *F,$/;"	f	class:POWERInterpreter
callMalloc	POWERExecution.cpp	/^void POWERInterpreter::callMalloc(llvm::Function *F){$/;"	f	class:POWERInterpreter
callPthreadCreate	POWERExecution.cpp	/^void POWERInterpreter::callPthreadCreate(llvm::Function *F){$/;"	f	class:POWERInterpreter
callPthreadExit	POWERExecution.cpp	/^void POWERInterpreter::callPthreadExit(llvm::Function *F){$/;"	f	class:POWERInterpreter
callPthreadJoin	POWERExecution.cpp	/^void POWERInterpreter::callPthreadJoin(llvm::Function *F){$/;"	f	class:POWERInterpreter
callPutchar	POWERExecution.cpp	/^void POWERInterpreter::callPutchar(llvm::Function *F){$/;"	f	class:POWERInterpreter
commit	POWERExecution.cpp	/^void POWERInterpreter::commit(){$/;"	f	class:POWERInterpreter
commitAllLocal	POWERExecution.cpp	/^bool POWERInterpreter::commitAllLocal(){$/;"	f	class:POWERInterpreter
commitLocalAndFetchAll	POWERExecution.cpp	/^void POWERInterpreter::commitLocalAndFetchAll(){$/;"	f	class:POWERInterpreter
executeBitCastInst	POWERExecution.cpp	/^llvm::GenericValue POWERInterpreter::executeBitCastInst(llvm::Value *SrcVal,$/;"	f	class:POWERInterpreter
executeCmpInst	POWERExecution.cpp	/^static llvm::GenericValue executeCmpInst(unsigned predicate, llvm::GenericValue Src1,$/;"	f	file:
executeFAddInst	POWERExecution.cpp	/^static void executeFAddInst(llvm::GenericValue &Dest, llvm::GenericValue Src1,$/;"	f	file:
executeFCMP_BOOL	POWERExecution.cpp	/^static llvm::GenericValue executeFCMP_BOOL(llvm::GenericValue Src1, llvm::GenericValue Src2,$/;"	f	file:
executeFCMP_OEQ	POWERExecution.cpp	/^static llvm::GenericValue executeFCMP_OEQ(llvm::GenericValue Src1, llvm::GenericValue Src2,$/;"	f	file:
executeFCMP_OGE	POWERExecution.cpp	/^static llvm::GenericValue executeFCMP_OGE(llvm::GenericValue Src1, llvm::GenericValue Src2,$/;"	f	file:
executeFCMP_OGT	POWERExecution.cpp	/^static llvm::GenericValue executeFCMP_OGT(llvm::GenericValue Src1, llvm::GenericValue Src2,$/;"	f	file:
executeFCMP_OLE	POWERExecution.cpp	/^static llvm::GenericValue executeFCMP_OLE(llvm::GenericValue Src1, llvm::GenericValue Src2,$/;"	f	file:
executeFCMP_OLT	POWERExecution.cpp	/^static llvm::GenericValue executeFCMP_OLT(llvm::GenericValue Src1, llvm::GenericValue Src2,$/;"	f	file:
executeFCMP_ONE	POWERExecution.cpp	/^static llvm::GenericValue executeFCMP_ONE(llvm::GenericValue Src1, llvm::GenericValue Src2,$/;"	f	file:
executeFCMP_ORD	POWERExecution.cpp	/^static llvm::GenericValue executeFCMP_ORD(llvm::GenericValue Src1, llvm::GenericValue Src2,$/;"	f	file:
executeFCMP_UEQ	POWERExecution.cpp	/^static llvm::GenericValue executeFCMP_UEQ(llvm::GenericValue Src1, llvm::GenericValue Src2,$/;"	f	file:
executeFCMP_UGE	POWERExecution.cpp	/^static llvm::GenericValue executeFCMP_UGE(llvm::GenericValue Src1, llvm::GenericValue Src2,$/;"	f	file:
executeFCMP_UGT	POWERExecution.cpp	/^static llvm::GenericValue executeFCMP_UGT(llvm::GenericValue Src1, llvm::GenericValue Src2,$/;"	f	file:
executeFCMP_ULE	POWERExecution.cpp	/^static llvm::GenericValue executeFCMP_ULE(llvm::GenericValue Src1, llvm::GenericValue Src2,$/;"	f	file:
executeFCMP_ULT	POWERExecution.cpp	/^static llvm::GenericValue executeFCMP_ULT(llvm::GenericValue Src1, llvm::GenericValue Src2,$/;"	f	file:
executeFCMP_UNE	POWERExecution.cpp	/^static llvm::GenericValue executeFCMP_UNE(llvm::GenericValue Src1, llvm::GenericValue Src2,$/;"	f	file:
executeFCMP_UNO	POWERExecution.cpp	/^static llvm::GenericValue executeFCMP_UNO(llvm::GenericValue Src1, llvm::GenericValue Src2,$/;"	f	file:
executeFDivInst	POWERExecution.cpp	/^static void executeFDivInst(llvm::GenericValue &Dest, llvm::GenericValue Src1,$/;"	f	file:
executeFMulInst	POWERExecution.cpp	/^static void executeFMulInst(llvm::GenericValue &Dest, llvm::GenericValue Src1,$/;"	f	file:
executeFPExtInst	POWERExecution.cpp	/^llvm::GenericValue POWERInterpreter::executeFPExtInst(llvm::Value *SrcVal,$/;"	f	class:POWERInterpreter
executeFPToSIInst	POWERExecution.cpp	/^llvm::GenericValue POWERInterpreter::executeFPToSIInst(llvm::Value *SrcVal,$/;"	f	class:POWERInterpreter
executeFPToUIInst	POWERExecution.cpp	/^llvm::GenericValue POWERInterpreter::executeFPToUIInst(llvm::Value *SrcVal,$/;"	f	class:POWERInterpreter
executeFPTruncInst	POWERExecution.cpp	/^llvm::GenericValue POWERInterpreter::executeFPTruncInst(llvm::Value *SrcVal,$/;"	f	class:POWERInterpreter
executeFRemInst	POWERExecution.cpp	/^static void executeFRemInst(llvm::GenericValue &Dest, llvm::GenericValue Src1,$/;"	f	file:
executeFSubInst	POWERExecution.cpp	/^static void executeFSubInst(llvm::GenericValue &Dest, llvm::GenericValue Src1,$/;"	f	file:
executeGEPOperation	POWERExecution.cpp	/^llvm::GenericValue POWERInterpreter::executeGEPOperation(llvm::Value *PtrVal,$/;"	f	class:POWERInterpreter
executeICMP_EQ	POWERExecution.cpp	/^static llvm::GenericValue executeICMP_EQ(llvm::GenericValue Src1, llvm::GenericValue Src2,$/;"	f	file:
executeICMP_NE	POWERExecution.cpp	/^static llvm::GenericValue executeICMP_NE(llvm::GenericValue Src1, llvm::GenericValue Src2,$/;"	f	file:
executeICMP_SGE	POWERExecution.cpp	/^static llvm::GenericValue executeICMP_SGE(llvm::GenericValue Src1, llvm::GenericValue Src2,$/;"	f	file:
executeICMP_SGT	POWERExecution.cpp	/^static llvm::GenericValue executeICMP_SGT(llvm::GenericValue Src1, llvm::GenericValue Src2,$/;"	f	file:
executeICMP_SLE	POWERExecution.cpp	/^static llvm::GenericValue executeICMP_SLE(llvm::GenericValue Src1, llvm::GenericValue Src2,$/;"	f	file:
executeICMP_SLT	POWERExecution.cpp	/^static llvm::GenericValue executeICMP_SLT(llvm::GenericValue Src1, llvm::GenericValue Src2,$/;"	f	file:
executeICMP_UGE	POWERExecution.cpp	/^static llvm::GenericValue executeICMP_UGE(llvm::GenericValue Src1, llvm::GenericValue Src2,$/;"	f	file:
executeICMP_UGT	POWERExecution.cpp	/^static llvm::GenericValue executeICMP_UGT(llvm::GenericValue Src1, llvm::GenericValue Src2,$/;"	f	file:
executeICMP_ULE	POWERExecution.cpp	/^static llvm::GenericValue executeICMP_ULE(llvm::GenericValue Src1, llvm::GenericValue Src2,$/;"	f	file:
executeICMP_ULT	POWERExecution.cpp	/^static llvm::GenericValue executeICMP_ULT(llvm::GenericValue Src1, llvm::GenericValue Src2,$/;"	f	file:
executeIntToPtrInst	POWERExecution.cpp	/^llvm::GenericValue POWERInterpreter::executeIntToPtrInst(llvm::Value *SrcVal,$/;"	f	class:POWERInterpreter
executePtrToIntInst	POWERExecution.cpp	/^llvm::GenericValue POWERInterpreter::executePtrToIntInst(llvm::Value *SrcVal,$/;"	f	class:POWERInterpreter
executeSExtInst	POWERExecution.cpp	/^llvm::GenericValue POWERInterpreter::executeSExtInst(llvm::Value *SrcVal,$/;"	f	class:POWERInterpreter
executeSIToFPInst	POWERExecution.cpp	/^llvm::GenericValue POWERInterpreter::executeSIToFPInst(llvm::Value *SrcVal,$/;"	f	class:POWERInterpreter
executeSelectInst	POWERExecution.cpp	/^static llvm::GenericValue executeSelectInst(llvm::GenericValue Src1, llvm::GenericValue Src2,$/;"	f	file:
executeTruncInst	POWERExecution.cpp	/^llvm::GenericValue POWERInterpreter::executeTruncInst(llvm::Value *SrcVal, const llvm::GenericValue &Src, llvm::Type *DstTy) {$/;"	f	class:POWERInterpreter
executeUIToFPInst	POWERExecution.cpp	/^llvm::GenericValue POWERInterpreter::executeUIToFPInst(llvm::Value *SrcVal,$/;"	f	class:POWERInterpreter
executeZExtInst	POWERExecution.cpp	/^llvm::GenericValue POWERInterpreter::executeZExtInst(llvm::Value *SrcVal,$/;"	f	class:POWERInterpreter
exitCalled	POWERExecution.cpp	/^void POWERInterpreter::exitCalled(llvm::GenericValue GV) {$/;"	f	class:POWERInterpreter
fetch	POWERExecution.cpp	/^std::shared_ptr<POWERInterpreter::FetchedInstruction> POWERInterpreter::fetch(llvm::Instruction &I){$/;"	f	class:POWERInterpreter
fetchAll	POWERExecution.cpp	/^void POWERInterpreter::fetchAll(){$/;"	f	class:POWERInterpreter
fetchThreadExit	POWERExecution.cpp	/^void POWERInterpreter::fetchThreadExit(){$/;"	f	class:POWERInterpreter
getAddrOpIdx	POWERExecution.cpp	/^int POWERInterpreter::getAddrOpIdx(const llvm::Instruction &I){$/;"	f	class:POWERInterpreter
getCallee	POWERExecution.cpp	/^llvm::Function *POWERInterpreter::getCallee(){$/;"	f	class:POWERInterpreter
getCallee	POWERExecution.cpp	/^llvm::Function *POWERInterpreter::getCallee(llvm::Instruction &I){$/;"	f	class:POWERInterpreter
getCalleeOpIdx	POWERExecution.cpp	/^int POWERInterpreter::getCalleeOpIdx(const llvm::Instruction &I){$/;"	f	class:POWERInterpreter
getConstantExprValue	POWERExecution.cpp	/^llvm::GenericValue POWERInterpreter::getConstantExprValue (llvm::ConstantExpr *CE) {$/;"	f	class:POWERInterpreter
getConstantOperandValue	POWERExecution.cpp	/^llvm::GenericValue POWERInterpreter::getConstantOperandValue(llvm::Value *V) {$/;"	f	class:POWERInterpreter
getConstantValue	POWERExecution.cpp	/^llvm::GenericValue POWERInterpreter::getConstantValue(llvm::Constant *CPV){$/;"	f	class:POWERInterpreter
getShiftAmount	POWERExecution.cpp	/^static unsigned getShiftAmount(uint64_t orgShiftAmount,$/;"	f	file:
isInlineAsm	POWERExecution.cpp	/^bool POWERInterpreter::isInlineAsm(llvm::CallSite &CS, std::string *asmstr){$/;"	f	class:POWERInterpreter
isInlineAsm	POWERExecution.cpp	/^bool POWERInterpreter::isInlineAsm(llvm::Instruction &I, std::string *asmstr){$/;"	f	class:POWERInterpreter
popStackAndReturnValueToCaller	POWERExecution.cpp	/^void POWERInterpreter::popStackAndReturnValueToCaller(llvm::Type *RetTy,$/;"	f	class:POWERInterpreter
registerOperand	POWERExecution.cpp	/^void POWERInterpreter::registerOperand(int proc, FetchedInstruction &FI, int idx){$/;"	f	class:POWERInterpreter
run	POWERExecution.cpp	/^void POWERInterpreter::run() {$/;"	f	class:POWERInterpreter
setCurInstrValue	POWERExecution.cpp	/^void POWERInterpreter::setCurInstrValue(const llvm::GenericValue &Val) {$/;"	f	class:POWERInterpreter
stripws	POWERExecution.cpp	/^static void stripws(std::string &s){$/;"	f	file:
visitAShr	POWERExecution.cpp	/^void POWERInterpreter::visitAShr(llvm::BinaryOperator &I) {$/;"	f	class:POWERInterpreter
visitAllocaInst	POWERExecution.cpp	/^void POWERInterpreter::visitAllocaInst(llvm::AllocaInst &I) {$/;"	f	class:POWERInterpreter
visitBinaryOperator	POWERExecution.cpp	/^void POWERInterpreter::visitBinaryOperator(llvm::BinaryOperator &I) {$/;"	f	class:POWERInterpreter
visitBitCastInst	POWERExecution.cpp	/^void POWERInterpreter::visitBitCastInst(llvm::BitCastInst &I) {$/;"	f	class:POWERInterpreter
visitBranchInst	POWERExecution.cpp	/^void POWERInterpreter::visitBranchInst(llvm::BranchInst &I) {$/;"	f	class:POWERInterpreter
visitCallSite	POWERExecution.cpp	/^void POWERInterpreter::visitCallSite(llvm::CallSite CS) {$/;"	f	class:POWERInterpreter
visitExtractElementInst	POWERExecution.cpp	/^void POWERInterpreter::visitExtractElementInst(llvm::ExtractElementInst &I) {$/;"	f	class:POWERInterpreter
visitExtractValueInst	POWERExecution.cpp	/^void POWERInterpreter::visitExtractValueInst(llvm::ExtractValueInst &I) {$/;"	f	class:POWERInterpreter
visitFCmpInst	POWERExecution.cpp	/^void POWERInterpreter::visitFCmpInst(llvm::FCmpInst &I) {$/;"	f	class:POWERInterpreter
visitFPExtInst	POWERExecution.cpp	/^void POWERInterpreter::visitFPExtInst(llvm::FPExtInst &I) {$/;"	f	class:POWERInterpreter
visitFPToSIInst	POWERExecution.cpp	/^void POWERInterpreter::visitFPToSIInst(llvm::FPToSIInst &I) {$/;"	f	class:POWERInterpreter
visitFPToUIInst	POWERExecution.cpp	/^void POWERInterpreter::visitFPToUIInst(llvm::FPToUIInst &I) {$/;"	f	class:POWERInterpreter
visitFPTruncInst	POWERExecution.cpp	/^void POWERInterpreter::visitFPTruncInst(llvm::FPTruncInst &I) {$/;"	f	class:POWERInterpreter
visitGetElementPtrInst	POWERExecution.cpp	/^void POWERInterpreter::visitGetElementPtrInst(llvm::GetElementPtrInst &I) {$/;"	f	class:POWERInterpreter
visitICmpInst	POWERExecution.cpp	/^void POWERInterpreter::visitICmpInst(llvm::ICmpInst &I) {$/;"	f	class:POWERInterpreter
visitIndirectBrInst	POWERExecution.cpp	/^void POWERInterpreter::visitIndirectBrInst(llvm::IndirectBrInst &I) {$/;"	f	class:POWERInterpreter
visitInlineAsm	POWERExecution.cpp	/^void POWERInterpreter::visitInlineAsm(llvm::CallSite &CS, const std::string &asmstr){$/;"	f	class:POWERInterpreter
visitInsertElementInst	POWERExecution.cpp	/^void POWERInterpreter::visitInsertElementInst(llvm::InsertElementInst &I) {$/;"	f	class:POWERInterpreter
visitInsertValueInst	POWERExecution.cpp	/^void POWERInterpreter::visitInsertValueInst(llvm::InsertValueInst &I) {$/;"	f	class:POWERInterpreter
visitIntToPtrInst	POWERExecution.cpp	/^void POWERInterpreter::visitIntToPtrInst(llvm::IntToPtrInst &I) {$/;"	f	class:POWERInterpreter
visitLShr	POWERExecution.cpp	/^void POWERInterpreter::visitLShr(llvm::BinaryOperator &I) {$/;"	f	class:POWERInterpreter
visitLoadInst	POWERExecution.cpp	/^void POWERInterpreter::visitLoadInst(llvm::LoadInst &I) {$/;"	f	class:POWERInterpreter
visitPtrToIntInst	POWERExecution.cpp	/^void POWERInterpreter::visitPtrToIntInst(llvm::PtrToIntInst &I) {$/;"	f	class:POWERInterpreter
visitReturnInst	POWERExecution.cpp	/^void POWERInterpreter::visitReturnInst(llvm::ReturnInst &I) {$/;"	f	class:POWERInterpreter
visitSExtInst	POWERExecution.cpp	/^void POWERInterpreter::visitSExtInst(llvm::SExtInst &I) {$/;"	f	class:POWERInterpreter
visitSIToFPInst	POWERExecution.cpp	/^void POWERInterpreter::visitSIToFPInst(llvm::SIToFPInst &I) {$/;"	f	class:POWERInterpreter
visitSelectInst	POWERExecution.cpp	/^void POWERInterpreter::visitSelectInst(llvm::SelectInst &I) {$/;"	f	class:POWERInterpreter
visitShl	POWERExecution.cpp	/^void POWERInterpreter::visitShl(llvm::BinaryOperator &I) {$/;"	f	class:POWERInterpreter
visitShuffleVectorInst	POWERExecution.cpp	/^void POWERInterpreter::visitShuffleVectorInst(llvm::ShuffleVectorInst &I){$/;"	f	class:POWERInterpreter
visitStoreInst	POWERExecution.cpp	/^void POWERInterpreter::visitStoreInst(llvm::StoreInst &I) {$/;"	f	class:POWERInterpreter
visitSwitchInst	POWERExecution.cpp	/^void POWERInterpreter::visitSwitchInst(llvm::SwitchInst &I) {$/;"	f	class:POWERInterpreter
visitTruncInst	POWERExecution.cpp	/^void POWERInterpreter::visitTruncInst(llvm::TruncInst &I) {$/;"	f	class:POWERInterpreter
visitUIToFPInst	POWERExecution.cpp	/^void POWERInterpreter::visitUIToFPInst(llvm::UIToFPInst &I) {$/;"	f	class:POWERInterpreter
visitUnreachableInst	POWERExecution.cpp	/^void POWERInterpreter::visitUnreachableInst(llvm::UnreachableInst &I) {$/;"	f	class:POWERInterpreter
visitVAArgInst	POWERExecution.cpp	/^void POWERInterpreter::visitVAArgInst(llvm::VAArgInst &I) {$/;"	f	class:POWERInterpreter
visitZExtInst	POWERExecution.cpp	/^void POWERInterpreter::visitZExtInst(llvm::ZExtInst &I) {$/;"	f	class:POWERInterpreter
POWERInterpreter	POWERInterpreter.cpp	/^POWERInterpreter::POWERInterpreter(llvm::Module *M, POWERARMTraceBuilder &TB, const Configuration &conf)$/;"	f	class:POWERInterpreter
create	POWERInterpreter.cpp	/^llvm::ExecutionEngine *POWERInterpreter::create(llvm::Module *M, POWERARMTraceBuilder &TB,$/;"	f	class:POWERInterpreter
runAtExitHandlers	POWERInterpreter.cpp	/^void POWERInterpreter::runAtExitHandlers () {$/;"	f	class:POWERInterpreter
runFunction	POWERInterpreter.cpp	/^POWERInterpreter::runFunction(llvm::Function *F,$/;"	f	class:POWERInterpreter
~POWERInterpreter	POWERInterpreter.cpp	/^POWERInterpreter::~POWERInterpreter() {$/;"	f	class:POWERInterpreter
AddrDeps	POWERInterpreter.h	/^    VecSet<int> AddrDeps;$/;"	m	class:POWERInterpreter::FetchedInstruction
AllocaHolder	POWERInterpreter.h	/^    AllocaHolder() {}$/;"	f	class:POWERInterpreter::AllocaHolder
AllocaHolder	POWERInterpreter.h	/^    AllocaHolder(AllocaHolder &&RHS) : Allocations(std::move(RHS.Allocations)) {}$/;"	f	class:POWERInterpreter::AllocaHolder
AllocaHolder	POWERInterpreter.h	/^  class AllocaHolder {$/;"	c	class:POWERInterpreter
Allocas	POWERInterpreter.h	/^    AllocaHolder Allocas;            \/\/ Track memory allocated by alloca$/;"	m	class:POWERInterpreter::Thread
Allocations	POWERInterpreter.h	/^    std::vector<void *> Allocations;$/;"	m	class:POWERInterpreter::AllocaHolder
AtExitHandlers	POWERInterpreter.h	/^  std::vector<llvm::Function*> AtExitHandlers;$/;"	m	class:POWERInterpreter
Available	POWERInterpreter.h	/^      bool Available;$/;"	m	struct:POWERInterpreter::FetchedInstruction::Operand
CPS	POWERInterpreter.h	/^  CPidSystem CPS;$/;"	m	class:POWERInterpreter
Caller	POWERInterpreter.h	/^    std::shared_ptr<FetchedInstruction> Caller; \/\/ The function call to the currently executing function$/;"	m	struct:POWERInterpreter::ExecutionContext
CommittableEvents	POWERInterpreter.h	/^    VecSet<std::shared_ptr<FetchedInstruction> > CommittableEvents;$/;"	m	class:POWERInterpreter::Thread
CommittableLocal	POWERInterpreter.h	/^  std::vector<std::shared_ptr<FetchedInstruction> > CommittableLocal;$/;"	m	class:POWERInterpreter
Committed	POWERInterpreter.h	/^    bool Committed;$/;"	m	class:POWERInterpreter::FetchedInstruction
CreateEvent	POWERInterpreter.h	/^    IID<int> CreateEvent;$/;"	m	class:POWERInterpreter::Thread
CurBB	POWERInterpreter.h	/^    llvm::BasicBlock            *CurBB;      \/\/ The currently executing BB$/;"	m	struct:POWERInterpreter::ExecutionContext
CurFunction	POWERInterpreter.h	/^    llvm::Function              *CurFunction;\/\/ The currently executing function$/;"	m	struct:POWERInterpreter::ExecutionContext
CurInst	POWERInterpreter.h	/^    llvm::BasicBlock::iterator  CurInst;    \/\/ The next instruction to execute$/;"	m	struct:POWERInterpreter::ExecutionContext
CurInstr	POWERInterpreter.h	/^  std::shared_ptr<FetchedInstruction> CurInstr;$/;"	m	class:POWERInterpreter
CurrentThread	POWERInterpreter.h	/^  int CurrentThread;$/;"	m	class:POWERInterpreter
DataDeps	POWERInterpreter.h	/^    VecSet<int> DataDeps;$/;"	m	class:POWERInterpreter::FetchedInstruction
Dependent	POWERInterpreter.h	/^    struct Dependent{$/;"	s	class:POWERInterpreter::FetchedInstruction
Dependents	POWERInterpreter.h	/^    VecSet<Dependent> Dependents; \/\/ The instructions which depend on this instruction$/;"	m	class:POWERInterpreter::FetchedInstruction
ECStack	POWERInterpreter.h	/^    std::vector<ExecutionContext> ECStack;$/;"	m	class:POWERInterpreter::Thread
EventIndex	POWERInterpreter.h	/^    int EventIndex; \/\/ 0 if not an event$/;"	m	class:POWERInterpreter::FetchedInstruction
ExecutionContext	POWERInterpreter.h	/^    ExecutionContext() : CurFunction(nullptr), CurBB(nullptr), PrevBB(nullptr), CurInst(nullptr) {}$/;"	f	struct:POWERInterpreter::ExecutionContext
ExecutionContext	POWERInterpreter.h	/^  struct ExecutionContext {$/;"	s	class:POWERInterpreter
ExitValue	POWERInterpreter.h	/^  llvm::GenericValue ExitValue;          \/\/ The return value of the called function$/;"	m	class:POWERInterpreter
FI	POWERInterpreter.h	/^      std::shared_ptr<FetchedInstruction> FI;$/;"	m	struct:POWERInterpreter::FetchedInstruction::Dependent
FetchedInstruction	POWERInterpreter.h	/^    FetchedInstruction(llvm::Instruction &I)$/;"	f	class:POWERInterpreter::FetchedInstruction
FetchedInstruction	POWERInterpreter.h	/^  class FetchedInstruction {$/;"	c	class:POWERInterpreter
GetConstMRef	POWERInterpreter.h	/^  ConstMRef GetConstMRef(void const *Ptr, llvm::Type *Ty){$/;"	f	class:POWERInterpreter
GetMBlock	POWERInterpreter.h	/^  MBlock GetMBlock(void *Ptr, llvm::Type *Ty, const llvm::GenericValue &Val){$/;"	f	class:POWERInterpreter
GetMRef	POWERInterpreter.h	/^  MRef GetMRef(void *Ptr, llvm::Type *Ty){$/;"	f	class:POWERInterpreter
I	POWERInterpreter.h	/^    llvm::Instruction &I;$/;"	m	class:POWERInterpreter::FetchedInstruction
IL	POWERInterpreter.h	/^  llvm::IntrinsicLowering *IL;$/;"	m	class:POWERInterpreter
IsAddrOf	POWERInterpreter.h	/^      int IsAddrOf; \/\/ This operand holds the address for the IsAddrOf:th access of this instruction. -1 if not an address.$/;"	m	struct:POWERInterpreter::FetchedInstruction::Operand
IsBranch	POWERInterpreter.h	/^    bool IsBranch; \/\/ This instruction should be interpreted as branching$/;"	m	class:POWERInterpreter::FetchedInstruction
IsDataOf	POWERInterpreter.h	/^      int IsDataOf; \/\/ This operand holds the data for the IsDataOf:th access of this instruction. -1 if not data for an access.$/;"	m	struct:POWERInterpreter::FetchedInstruction::Operand
Operand	POWERInterpreter.h	/^      Operand() : Available(false), IsAddrOf(-1), IsDataOf(-1) {};$/;"	f	struct:POWERInterpreter::FetchedInstruction::Operand
Operand	POWERInterpreter.h	/^      Operand(const llvm::GenericValue &Value) : Value(Value), Available(true), IsAddrOf(-1), IsDataOf(-1) {};$/;"	f	struct:POWERInterpreter::FetchedInstruction::Operand
Operand	POWERInterpreter.h	/^    struct Operand{$/;"	s	class:POWERInterpreter::FetchedInstruction
Operands	POWERInterpreter.h	/^    std::vector<Operand> Operands;$/;"	m	class:POWERInterpreter::FetchedInstruction
POWERInterpreter	POWERInterpreter.h	/^class POWERInterpreter : public llvm::ExecutionEngine, public llvm::InstVisitor<POWERInterpreter> {$/;"	c
PrevBB	POWERInterpreter.h	/^    llvm::BasicBlock            *PrevBB;     \/\/ The previously executing BB$/;"	m	struct:POWERInterpreter::ExecutionContext
TB	POWERInterpreter.h	/^  POWERARMTraceBuilder &TB;$/;"	m	class:POWERInterpreter
TD	POWERInterpreter.h	/^  llvm::DataLayout TD;$/;"	m	class:POWERInterpreter
Thread	POWERInterpreter.h	/^    Thread(const CPid &cpid)$/;"	f	class:POWERInterpreter::Thread
Thread	POWERInterpreter.h	/^  class Thread{$/;"	c	class:POWERInterpreter
Threads	POWERInterpreter.h	/^  std::vector<Thread> Threads;$/;"	m	class:POWERInterpreter
Value	POWERInterpreter.h	/^      llvm::GenericValue Value;$/;"	m	struct:POWERInterpreter::FetchedInstruction::Operand
Value	POWERInterpreter.h	/^    llvm::GenericValue Value;$/;"	m	class:POWERInterpreter::FetchedInstruction
ValuePlaneTy	POWERInterpreter.h	/^  typedef std::vector<llvm::GenericValue> ValuePlaneTy;$/;"	t	class:POWERInterpreter
Values	POWERInterpreter.h	/^    std::map<llvm::Value *, std::shared_ptr<FetchedInstruction> > Values; \/\/ LLVM values used in this invocation$/;"	m	struct:POWERInterpreter::ExecutionContext
VarArgs	POWERInterpreter.h	/^    std::vector<llvm::GenericValue>  VarArgs; \/\/ Values passed through an ellipsis$/;"	m	struct:POWERInterpreter::ExecutionContext
__POWER_INTERPRETER_H__	POWERInterpreter.h	38;"	d
add	POWERInterpreter.h	/^    void add(void *Mem) { Allocations.push_back(Mem); }$/;"	f	class:POWERInterpreter::AllocaHolder
addAtExitHandler	POWERInterpreter.h	/^  void addAtExitHandler(llvm::Function *F) {$/;"	f	class:POWERInterpreter
commit	POWERInterpreter.h	/^  void commit(const std::shared_ptr<FetchedInstruction> &FI){$/;"	f	class:POWERInterpreter
committable	POWERInterpreter.h	/^    bool committable() const {$/;"	f	class:POWERInterpreter::FetchedInstruction
conf	POWERInterpreter.h	/^  const Configuration &conf;$/;"	m	class:POWERInterpreter
cpid	POWERInterpreter.h	/^    CPid cpid;$/;"	m	class:POWERInterpreter::Thread
dummy_load8	POWERInterpreter.h	/^  llvm::Instruction *dummy_load8;$/;"	m	class:POWERInterpreter
dummy_store	POWERInterpreter.h	/^  llvm::Instruction *dummy_store;$/;"	m	class:POWERInterpreter
freeMachineCodeForFunction	POWERInterpreter.h	/^  virtual void freeMachineCodeForFunction(llvm::Function *F) { }$/;"	f	class:POWERInterpreter
gep_type_iterator	POWERInterpreter.h	/^  typedef llvm::generic_gep_type_iterator<llvm::User::const_op_iterator> gep_type_iterator;$/;"	t	class:POWERInterpreter
getFirstVarArg	POWERInterpreter.h	/^  llvm::GenericValue *getFirstVarArg () {$/;"	f	class:POWERInterpreter
getOperandValue	POWERInterpreter.h	/^  llvm::GenericValue &getOperandValue(int n){$/;"	f	class:POWERInterpreter
getPointerToBasicBlock	POWERInterpreter.h	/^  virtual void *getPointerToBasicBlock(llvm::BasicBlock *BB) { return (void*)BB; }$/;"	f	class:POWERInterpreter
getPointerToFunction	POWERInterpreter.h	/^  void *getPointerToFunction(llvm::Function *F) { return (void*)F; }$/;"	f	class:POWERInterpreter
getPointerToNamedFunction	POWERInterpreter.h	/^  void *getPointerToNamedFunction(const std::string &Name,$/;"	f	class:POWERInterpreter
getPointerToNamedFunction	POWERInterpreter.h	/^  void *getPointerToNamedFunction(llvm::StringRef Name,$/;"	f	class:POWERInterpreter
initializeExecutionEngine	POWERInterpreter.h	/^  void initializeExecutionEngine() { }$/;"	f	class:POWERInterpreter
isAddr	POWERInterpreter.h	/^      bool isAddr() const { return 0 <= IsAddrOf; };$/;"	f	struct:POWERInterpreter::FetchedInstruction::Operand
isData	POWERInterpreter.h	/^      bool isData() const { return 0 <= IsDataOf; };$/;"	f	struct:POWERInterpreter::FetchedInstruction::Operand
isEvent	POWERInterpreter.h	/^    bool isEvent() const { return EventIndex; };$/;"	f	class:POWERInterpreter::FetchedInstruction
llvm	POWERInterpreter.h	/^namespace llvm{$/;"	n
move	POWERInterpreter.h	/^        VarArgs(std::move(O.VarArgs)) {}$/;"	f	struct:POWERInterpreter::ExecutionContext
noexcept	POWERInterpreter.h	/^    ExecutionContext(ExecutionContext &&O) noexcept$/;"	m	struct:POWERInterpreter::ExecutionContext
op_idx	POWERInterpreter.h	/^      int op_idx;$/;"	m	struct:POWERInterpreter::FetchedInstruction::Dependent
operator <	POWERInterpreter.h	/^      bool operator<(const Dependent &D) const {$/;"	f	struct:POWERInterpreter::FetchedInstruction::Dependent
operator =	POWERInterpreter.h	/^    AllocaHolder &operator=(AllocaHolder &&RHS) {$/;"	f	class:POWERInterpreter::AllocaHolder
operator =	POWERInterpreter.h	/^    ExecutionContext &operator=(ExecutionContext &&O) {$/;"	f	struct:POWERInterpreter::ExecutionContext
operator ==	POWERInterpreter.h	/^      bool operator==(const Dependent &D) const{$/;"	f	struct:POWERInterpreter::FetchedInstruction::Dependent
recompileAndRelinkFunction	POWERInterpreter.h	/^  virtual void *recompileAndRelinkFunction(llvm::Function *F) {$/;"	f	class:POWERInterpreter
status	POWERInterpreter.h	/^        status(T.status) {};$/;"	f	class:POWERInterpreter::Thread
status	POWERInterpreter.h	/^    uint8_t *status;$/;"	m	class:POWERInterpreter::Thread
visitCallInst	POWERInterpreter.h	/^  void visitCallInst(llvm::CallInst &I) { visitCallSite (llvm::CallSite (&I)); }$/;"	f	class:POWERInterpreter
visitInstruction	POWERInterpreter.h	/^  void visitInstruction(llvm::Instruction &I) {$/;"	f	class:POWERInterpreter
visitInvokeInst	POWERInterpreter.h	/^  void visitInvokeInst(llvm::InvokeInst &I) { visitCallSite (llvm::CallSite (&I)); }$/;"	f	class:POWERInterpreter
visitPHINode	POWERInterpreter.h	/^  void visitPHINode(llvm::PHINode &PN) {$/;"	f	class:POWERInterpreter
~AllocaHolder	POWERInterpreter.h	/^    ~AllocaHolder() {$/;"	f	class:POWERInterpreter::AllocaHolder
BOOST_AUTO_TEST_CASE	POWER_test.cpp	/^BOOST_AUTO_TEST_CASE(CoRW_1){$/;"	f
BOOST_AUTO_TEST_CASE	POWER_test.cpp	/^BOOST_AUTO_TEST_CASE(CoRW_2){$/;"	f
BOOST_AUTO_TEST_CASE	POWER_test.cpp	/^BOOST_AUTO_TEST_CASE(CoWR_1){$/;"	f
BOOST_AUTO_TEST_CASE	POWER_test.cpp	/^BOOST_AUTO_TEST_CASE(CoWR_2){$/;"	f
BOOST_AUTO_TEST_CASE	POWER_test.cpp	/^BOOST_AUTO_TEST_CASE(CoWW_1){$/;"	f
BOOST_AUTO_TEST_CASE	POWER_test.cpp	/^BOOST_AUTO_TEST_CASE(CoWW_2){$/;"	f
BOOST_AUTO_TEST_CASE	POWER_test.cpp	/^BOOST_AUTO_TEST_CASE(Commit_fences_1){$/;"	f
BOOST_AUTO_TEST_CASE	POWER_test.cpp	/^BOOST_AUTO_TEST_CASE(Commit_fences_2){$/;"	f
BOOST_AUTO_TEST_CASE	POWER_test.cpp	/^BOOST_AUTO_TEST_CASE(Ctrldep_1){ \/\/ LB+ctrls$/;"	f
BOOST_AUTO_TEST_CASE	POWER_test.cpp	/^BOOST_AUTO_TEST_CASE(Ctrldep_2){ \/\/ LB+ctrl+(ctrl without dep)$/;"	f
BOOST_AUTO_TEST_CASE	POWER_test.cpp	/^BOOST_AUTO_TEST_CASE(Disappearing_sleep_1){$/;"	f
BOOST_AUTO_TEST_CASE	POWER_test.cpp	/^BOOST_AUTO_TEST_CASE(IRIW){$/;"	f
BOOST_AUTO_TEST_CASE	POWER_test.cpp	/^BOOST_AUTO_TEST_CASE(IRIW_addrs){$/;"	f
BOOST_AUTO_TEST_CASE	POWER_test.cpp	/^BOOST_AUTO_TEST_CASE(IRIW_lwsyncs){$/;"	f
BOOST_AUTO_TEST_CASE	POWER_test.cpp	/^BOOST_AUTO_TEST_CASE(IRIW_syncs){$/;"	f
BOOST_AUTO_TEST_CASE	POWER_test.cpp	/^BOOST_AUTO_TEST_CASE(LB_1){$/;"	f
BOOST_AUTO_TEST_CASE	POWER_test.cpp	/^BOOST_AUTO_TEST_CASE(LB_addrpos){$/;"	f
BOOST_AUTO_TEST_CASE	POWER_test.cpp	/^BOOST_AUTO_TEST_CASE(LB_assume_1){$/;"	f
BOOST_AUTO_TEST_CASE	POWER_test.cpp	/^BOOST_AUTO_TEST_CASE(LB_assume_2){$/;"	f
BOOST_AUTO_TEST_CASE	POWER_test.cpp	/^BOOST_AUTO_TEST_CASE(LB_assume_3){$/;"	f
BOOST_AUTO_TEST_CASE	POWER_test.cpp	/^BOOST_AUTO_TEST_CASE(LB_data_1){$/;"	f
BOOST_AUTO_TEST_CASE	POWER_test.cpp	/^BOOST_AUTO_TEST_CASE(LB_data_2){$/;"	f
BOOST_AUTO_TEST_CASE	POWER_test.cpp	/^BOOST_AUTO_TEST_CASE(LB_datas){$/;"	f
BOOST_AUTO_TEST_CASE	POWER_test.cpp	/^BOOST_AUTO_TEST_CASE(LB_isyncs){$/;"	f
BOOST_AUTO_TEST_CASE	POWER_test.cpp	/^BOOST_AUTO_TEST_CASE(LB_lwsyncs){$/;"	f
BOOST_AUTO_TEST_CASE	POWER_test.cpp	/^BOOST_AUTO_TEST_CASE(LB_syncs){$/;"	f
BOOST_AUTO_TEST_CASE	POWER_test.cpp	/^BOOST_AUTO_TEST_CASE(Load_store_1){$/;"	f
BOOST_AUTO_TEST_CASE	POWER_test.cpp	/^BOOST_AUTO_TEST_CASE(Load_store_2){$/;"	f
BOOST_AUTO_TEST_CASE	POWER_test.cpp	/^BOOST_AUTO_TEST_CASE(Load_store_3){$/;"	f
BOOST_AUTO_TEST_CASE	POWER_test.cpp	/^BOOST_AUTO_TEST_CASE(MP3_lwsync_addrpo_addr){$/;"	f
BOOST_AUTO_TEST_CASE	POWER_test.cpp	/^BOOST_AUTO_TEST_CASE(MP3_lwsync_ctrl_addr){$/;"	f
BOOST_AUTO_TEST_CASE	POWER_test.cpp	/^BOOST_AUTO_TEST_CASE(MPWW_lwsyncs){$/;"	f
BOOST_AUTO_TEST_CASE	POWER_test.cpp	/^BOOST_AUTO_TEST_CASE(MPW_lwsyncs){$/;"	f
BOOST_AUTO_TEST_CASE	POWER_test.cpp	/^BOOST_AUTO_TEST_CASE(MP_addr){$/;"	f
BOOST_AUTO_TEST_CASE	POWER_test.cpp	/^BOOST_AUTO_TEST_CASE(MP_addr_1){$/;"	f
BOOST_AUTO_TEST_CASE	POWER_test.cpp	/^BOOST_AUTO_TEST_CASE(MP_lwsync_addr){$/;"	f
BOOST_AUTO_TEST_CASE	POWER_test.cpp	/^BOOST_AUTO_TEST_CASE(MP_lwsync_addrpo){$/;"	f
BOOST_AUTO_TEST_CASE	POWER_test.cpp	/^BOOST_AUTO_TEST_CASE(MP_lwsync_ctrl){$/;"	f
BOOST_AUTO_TEST_CASE	POWER_test.cpp	/^BOOST_AUTO_TEST_CASE(MP_lwsync_ctrlisync){$/;"	f
BOOST_AUTO_TEST_CASE	POWER_test.cpp	/^BOOST_AUTO_TEST_CASE(MP_lwsync_datarfiaddr){$/;"	f
BOOST_AUTO_TEST_CASE	POWER_test.cpp	/^BOOST_AUTO_TEST_CASE(MP_lwsync_isync){$/;"	f
BOOST_AUTO_TEST_CASE	POWER_test.cpp	/^BOOST_AUTO_TEST_CASE(MP_lwsync_isyncctrl){$/;"	f
BOOST_AUTO_TEST_CASE	POWER_test.cpp	/^BOOST_AUTO_TEST_CASE(MP_lwsyncs){$/;"	f
BOOST_AUTO_TEST_CASE	POWER_test.cpp	/^BOOST_AUTO_TEST_CASE(Minimal_computation){$/;"	f
BOOST_AUTO_TEST_CASE	POWER_test.cpp	/^BOOST_AUTO_TEST_CASE(PHI_delayed){$/;"	f
BOOST_AUTO_TEST_CASE	POWER_test.cpp	/^BOOST_AUTO_TEST_CASE(RRW_1){$/;"	f
BOOST_AUTO_TEST_CASE	POWER_test.cpp	/^BOOST_AUTO_TEST_CASE(Reordering_box_1){$/;"	f
BOOST_AUTO_TEST_CASE	POWER_test.cpp	/^BOOST_AUTO_TEST_CASE(Reordering_box_10){$/;"	f
BOOST_AUTO_TEST_CASE	POWER_test.cpp	/^BOOST_AUTO_TEST_CASE(Reordering_box_11){$/;"	f
BOOST_AUTO_TEST_CASE	POWER_test.cpp	/^BOOST_AUTO_TEST_CASE(Reordering_box_12){$/;"	f
BOOST_AUTO_TEST_CASE	POWER_test.cpp	/^BOOST_AUTO_TEST_CASE(Reordering_box_13){$/;"	f
BOOST_AUTO_TEST_CASE	POWER_test.cpp	/^BOOST_AUTO_TEST_CASE(Reordering_box_14){$/;"	f
BOOST_AUTO_TEST_CASE	POWER_test.cpp	/^BOOST_AUTO_TEST_CASE(Reordering_box_15){$/;"	f
BOOST_AUTO_TEST_CASE	POWER_test.cpp	/^BOOST_AUTO_TEST_CASE(Reordering_box_16){$/;"	f
BOOST_AUTO_TEST_CASE	POWER_test.cpp	/^BOOST_AUTO_TEST_CASE(Reordering_box_17){$/;"	f
BOOST_AUTO_TEST_CASE	POWER_test.cpp	/^BOOST_AUTO_TEST_CASE(Reordering_box_18){$/;"	f
BOOST_AUTO_TEST_CASE	POWER_test.cpp	/^BOOST_AUTO_TEST_CASE(Reordering_box_19){$/;"	f
BOOST_AUTO_TEST_CASE	POWER_test.cpp	/^BOOST_AUTO_TEST_CASE(Reordering_box_2){$/;"	f
BOOST_AUTO_TEST_CASE	POWER_test.cpp	/^BOOST_AUTO_TEST_CASE(Reordering_box_3){$/;"	f
BOOST_AUTO_TEST_CASE	POWER_test.cpp	/^BOOST_AUTO_TEST_CASE(Reordering_box_4){$/;"	f
BOOST_AUTO_TEST_CASE	POWER_test.cpp	/^BOOST_AUTO_TEST_CASE(Reordering_box_5){$/;"	f
BOOST_AUTO_TEST_CASE	POWER_test.cpp	/^BOOST_AUTO_TEST_CASE(Reordering_box_6){$/;"	f
BOOST_AUTO_TEST_CASE	POWER_test.cpp	/^BOOST_AUTO_TEST_CASE(Reordering_box_7){$/;"	f
BOOST_AUTO_TEST_CASE	POWER_test.cpp	/^BOOST_AUTO_TEST_CASE(Reordering_box_8){$/;"	f
BOOST_AUTO_TEST_CASE	POWER_test.cpp	/^BOOST_AUTO_TEST_CASE(Reordering_box_9){$/;"	f
BOOST_AUTO_TEST_CASE	POWER_test.cpp	/^BOOST_AUTO_TEST_CASE(SB){$/;"	f
BOOST_AUTO_TEST_CASE	POWER_test.cpp	/^BOOST_AUTO_TEST_CASE(SB_lwsyncs){$/;"	f
BOOST_AUTO_TEST_CASE	POWER_test.cpp	/^BOOST_AUTO_TEST_CASE(SB_syncs){$/;"	f
BOOST_AUTO_TEST_CASE	POWER_test.cpp	/^BOOST_AUTO_TEST_CASE(Store_load_1){$/;"	f
BOOST_AUTO_TEST_CASE	POWER_test.cpp	/^BOOST_AUTO_TEST_CASE(Store_load_2){$/;"	f
BOOST_AUTO_TEST_CASE	POWER_test.cpp	/^BOOST_AUTO_TEST_CASE(Store_load_3){$/;"	f
BOOST_AUTO_TEST_CASE	POWER_test.cpp	/^BOOST_AUTO_TEST_CASE(Store_store_1){$/;"	f
BOOST_AUTO_TEST_CASE	POWER_test.cpp	/^BOOST_AUTO_TEST_CASE(Store_store_2){$/;"	f
BOOST_AUTO_TEST_CASE	POWER_test.cpp	/^BOOST_AUTO_TEST_CASE(Store_store_3){$/;"	f
BOOST_AUTO_TEST_CASE	POWER_test.cpp	/^BOOST_AUTO_TEST_CASE(THREE_2W){$/;"	f
BOOST_AUTO_TEST_CASE	POWER_test.cpp	/^BOOST_AUTO_TEST_CASE(THREE_2W_lwsyncs){$/;"	f
BOOST_AUTO_TEST_CASE	POWER_test.cpp	/^BOOST_AUTO_TEST_CASE(TWO_2W){$/;"	f
BOOST_AUTO_TEST_CASE	POWER_test.cpp	/^BOOST_AUTO_TEST_CASE(TWO_2W_lwsync){$/;"	f
BOOST_AUTO_TEST_CASE	POWER_test.cpp	/^BOOST_AUTO_TEST_CASE(TWO_2W_lwsync_2){$/;"	f
BOOST_AUTO_TEST_CASE	POWER_test.cpp	/^BOOST_AUTO_TEST_CASE(TWO_2W_lwsyncs){$/;"	f
BOOST_AUTO_TEST_CASE	POWER_test.cpp	/^BOOST_AUTO_TEST_CASE(TWO_2W_rfi_datas_noise){$/;"	f
BOOST_AUTO_TEST_CASE	POWER_test.cpp	/^BOOST_AUTO_TEST_CASE(W_RW_2W){$/;"	f
BOOST_AUTO_TEST_CASE	POWER_test.cpp	/^BOOST_AUTO_TEST_CASE(W_RW_2W_lwsyncs){$/;"	f
BOOST_AUTO_TEST_CASE	POWER_test2.cpp	/^BOOST_AUTO_TEST_CASE(Assertion_abort){$/;"	f
BOOST_AUTO_TEST_CASE	POWER_test2.cpp	/^BOOST_AUTO_TEST_CASE(Compiler_fence_SB){$/;"	f
BOOST_AUTO_TEST_CASE	POWER_test2.cpp	/^BOOST_AUTO_TEST_CASE(Create_id_1){$/;"	f
BOOST_AUTO_TEST_CASE	POWER_test2.cpp	/^BOOST_AUTO_TEST_CASE(DETOUR0294){$/;"	f
BOOST_AUTO_TEST_CASE	POWER_test2.cpp	/^BOOST_AUTO_TEST_CASE(Data_rfi_sleepset){$/;"	f
BOOST_AUTO_TEST_CASE	POWER_test2.cpp	/^BOOST_AUTO_TEST_CASE(Fun_arg_1){$/;"	f
BOOST_AUTO_TEST_CASE	POWER_test2.cpp	/^BOOST_AUTO_TEST_CASE(Fun_arg_2){$/;"	f
BOOST_AUTO_TEST_CASE	POWER_test2.cpp	/^BOOST_AUTO_TEST_CASE(HH2){$/;"	f
BOOST_AUTO_TEST_CASE	POWER_test2.cpp	/^BOOST_AUTO_TEST_CASE(Join_1){$/;"	f
BOOST_AUTO_TEST_CASE	POWER_test2.cpp	/^BOOST_AUTO_TEST_CASE(Join_2){$/;"	f
BOOST_AUTO_TEST_CASE	POWER_test2.cpp	/^BOOST_AUTO_TEST_CASE(LB_datapoloc_lwsync){$/;"	f
BOOST_AUTO_TEST_CASE	POWER_test2.cpp	/^BOOST_AUTO_TEST_CASE(LB_polocrfiaddr_lwsync){$/;"	f
BOOST_AUTO_TEST_CASE	POWER_test2.cpp	/^BOOST_AUTO_TEST_CASE(MP_double_fence){$/;"	f
BOOST_AUTO_TEST_CASE	POWER_test2.cpp	/^BOOST_AUTO_TEST_CASE(MP_lwsync_overlap){$/;"	f
BOOST_AUTO_TEST_CASE	POWER_test2.cpp	/^BOOST_AUTO_TEST_CASE(MP_lwsync_overlap_2){$/;"	f
BOOST_AUTO_TEST_CASE	POWER_test2.cpp	/^BOOST_AUTO_TEST_CASE(Main_arg){$/;"	f
BOOST_AUTO_TEST_CASE	POWER_test2.cpp	/^BOOST_AUTO_TEST_CASE(Malloc_free_1){$/;"	f
BOOST_AUTO_TEST_CASE	POWER_test2.cpp	/^BOOST_AUTO_TEST_CASE(Mutex_1){$/;"	f
BOOST_AUTO_TEST_CASE	POWER_test2.cpp	/^BOOST_AUTO_TEST_CASE(Mutex_10){$/;"	f
BOOST_AUTO_TEST_CASE	POWER_test2.cpp	/^BOOST_AUTO_TEST_CASE(Mutex_11){$/;"	f
BOOST_AUTO_TEST_CASE	POWER_test2.cpp	/^BOOST_AUTO_TEST_CASE(Mutex_12){$/;"	f
BOOST_AUTO_TEST_CASE	POWER_test2.cpp	/^BOOST_AUTO_TEST_CASE(Mutex_3){$/;"	f
BOOST_AUTO_TEST_CASE	POWER_test2.cpp	/^BOOST_AUTO_TEST_CASE(Mutex_6){$/;"	f
BOOST_AUTO_TEST_CASE	POWER_test2.cpp	/^BOOST_AUTO_TEST_CASE(Mutex_7){$/;"	f
BOOST_AUTO_TEST_CASE	POWER_test2.cpp	/^BOOST_AUTO_TEST_CASE(Mutex_9){$/;"	f
BOOST_AUTO_TEST_CASE	POWER_test2.cpp	/^BOOST_AUTO_TEST_CASE(Prop_rf_ppo){$/;"	f
BOOST_AUTO_TEST_CASE	POWER_test2.cpp	/^BOOST_AUTO_TEST_CASE(Pthread_create_arg_1){$/;"	f
BOOST_AUTO_TEST_CASE	POWER_test2.cpp	/^BOOST_AUTO_TEST_CASE(Pthread_create_arg_2){$/;"	f
BOOST_AUTO_TEST_CASE	POWER_test2.cpp	/^BOOST_AUTO_TEST_CASE(Pthread_exit_1){$/;"	f
BOOST_AUTO_TEST_CASE	POWER_test2.cpp	/^BOOST_AUTO_TEST_CASE(Pthread_exit_2){$/;"	f
BOOST_AUTO_TEST_CASE	POWER_test2.cpp	/^BOOST_AUTO_TEST_CASE(Pthread_exit_3){$/;"	f
BOOST_AUTO_TEST_CASE	POWER_test2.cpp	/^BOOST_AUTO_TEST_CASE(Pthread_exit_4){$/;"	f
BOOST_AUTO_TEST_CASE	POWER_test2.cpp	/^BOOST_AUTO_TEST_CASE(RWW_1){$/;"	f
BOOST_AUTO_TEST_CASE	POWER_test2.cpp	/^BOOST_AUTO_TEST_CASE(TWO_2W_overlapping_1){$/;"	f
BOOST_AUTO_TEST_CASE	POWER_test2.cpp	/^BOOST_AUTO_TEST_CASE(TWO_2W_overlapping_2){$/;"	f
BOOST_AUTO_TEST_CASE	POWER_test2.cpp	/^BOOST_AUTO_TEST_CASE(TWO_2W_overlapping_3){$/;"	f
BOOST_AUTO_TEST_CASE	POWER_test2.cpp	/^BOOST_AUTO_TEST_CASE(TWO_2W_overlapping_4){$/;"	f
BOOST_AUTO_TEST_CASE	POWER_test2.cpp	/^BOOST_AUTO_TEST_CASE(TWO_W){$/;"	f
BOOST_AUTO_TEST_CASE	POWER_test2.cpp	/^BOOST_AUTO_TEST_CASE(TWO_W_2R){$/;"	f
BOOST_AUTO_TEST_CASE	POWER_test2.cpp	/^BOOST_AUTO_TEST_CASE(co7){$/;"	f
PSOInterpreter	PSOInterpreter.cpp	/^PSOInterpreter::PSOInterpreter(llvm::Module *M, PSOTraceBuilder &TB,$/;"	f	class:PSOInterpreter
SetValue	PSOInterpreter.cpp	/^static void SetValue(llvm::Value *V, llvm::GenericValue Val, llvm::ExecutionContext &SF) {$/;"	f	file:
checkRefuse	PSOInterpreter.cpp	/^bool PSOInterpreter::checkRefuse(llvm::Instruction &I){$/;"	f	class:PSOInterpreter
create	PSOInterpreter.cpp	/^llvm::ExecutionEngine *PSOInterpreter::create(llvm::Module *M, PSOTraceBuilder &TB,$/;"	f	class:PSOInterpreter
isFence	PSOInterpreter.cpp	/^bool PSOInterpreter::isFence(llvm::Instruction &I){$/;"	f	class:PSOInterpreter
newThread	PSOInterpreter.cpp	/^int PSOInterpreter::newThread(const CPid &cpid){$/;"	f	class:PSOInterpreter
readable	PSOInterpreter.cpp	/^bool PSOInterpreter::PSOThread::readable(const ConstMRef &ml) const {$/;"	f	class:PSOInterpreter::PSOThread
runAux	PSOInterpreter.cpp	/^void PSOInterpreter::runAux(int proc, int aux){$/;"	f	class:PSOInterpreter
terminate	PSOInterpreter.cpp	/^void PSOInterpreter::terminate(llvm::Type *RetTy, llvm::GenericValue Result){$/;"	f	class:PSOInterpreter
visitAtomicCmpXchgInst	PSOInterpreter.cpp	/^void PSOInterpreter::visitAtomicCmpXchgInst(llvm::AtomicCmpXchgInst &I){$/;"	f	class:PSOInterpreter
visitAtomicRMWInst	PSOInterpreter.cpp	/^void PSOInterpreter::visitAtomicRMWInst(llvm::AtomicRMWInst &I){$/;"	f	class:PSOInterpreter
visitFenceInst	PSOInterpreter.cpp	/^void PSOInterpreter::visitFenceInst(llvm::FenceInst &I){$/;"	f	class:PSOInterpreter
visitInlineAsm	PSOInterpreter.cpp	/^void PSOInterpreter::visitInlineAsm(llvm::CallSite &CS, const std::string &asmstr){$/;"	f	class:PSOInterpreter
visitLoadInst	PSOInterpreter.cpp	/^void PSOInterpreter::visitLoadInst(llvm::LoadInst &I){$/;"	f	class:PSOInterpreter
visitStoreInst	PSOInterpreter.cpp	/^void PSOInterpreter::visitStoreInst(llvm::StoreInst &I){$/;"	f	class:PSOInterpreter
~PSOInterpreter	PSOInterpreter.cpp	/^PSOInterpreter::~PSOInterpreter(){$/;"	f	class:PSOInterpreter
BFL_FULL	PSOInterpreter.h	/^      BFL_FULL,$/;"	e	enum:PSOInterpreter::PSOThread::BufferFlush
BFL_NO	PSOInterpreter.h	/^      BFL_NO,$/;"	e	enum:PSOInterpreter::PSOThread::BufferFlush
BFL_PARTIAL	PSOInterpreter.h	/^      BFL_PARTIAL$/;"	e	enum:PSOInterpreter::PSOThread::BufferFlush
BufferFlush	PSOInterpreter.h	/^    enum BufferFlush {$/;"	g	class:PSOInterpreter::PSOThread
PSOInterpreter	PSOInterpreter.h	/^class PSOInterpreter : public llvm::Interpreter{$/;"	c
PSOThread	PSOInterpreter.h	/^    PSOThread() : awaiting_buffer_flush(BFL_NO), buffer_flush_ml(0,1) {};$/;"	f	class:PSOInterpreter::PSOThread
PSOThread	PSOInterpreter.h	/^  class PSOThread{$/;"	c	class:PSOInterpreter
PendingStoreByte	PSOInterpreter.h	/^    PendingStoreByte(const ConstMRef &ml, uint8_t val) : ml(ml), val(val) {};$/;"	f	class:PSOInterpreter::PendingStoreByte
PendingStoreByte	PSOInterpreter.h	/^  class PendingStoreByte{$/;"	c	class:PSOInterpreter
__PSO_INTERPRETER_H__	PSOInterpreter.h	22;"	d
all_buffers_empty	PSOInterpreter.h	/^    bool all_buffers_empty() const{$/;"	f	class:PSOInterpreter::PSOThread
aux_to_byte	PSOInterpreter.h	/^    std::vector<void*> aux_to_byte;$/;"	m	class:PSOInterpreter::PSOThread
awaiting_buffer_flush	PSOInterpreter.h	/^    } awaiting_buffer_flush;$/;"	m	class:PSOInterpreter::PSOThread	typeref:enum:PSOInterpreter::PSOThread::BufferFlush
buffer_flush_ml	PSOInterpreter.h	/^    ConstMRef buffer_flush_ml;$/;"	m	class:PSOInterpreter::PSOThread
byte_to_aux	PSOInterpreter.h	/^    std::map<void const*,int> byte_to_aux;$/;"	m	class:PSOInterpreter::PSOThread
ml	PSOInterpreter.h	/^    ConstMRef ml;$/;"	m	class:PSOInterpreter::PendingStoreByte
pso_threads	PSOInterpreter.h	/^  std::vector<PSOThread> pso_threads;$/;"	m	class:PSOInterpreter
store_buffers	PSOInterpreter.h	/^    std::map<void const*,std::vector<PendingStoreByte> > store_buffers;$/;"	m	class:PSOInterpreter::PSOThread
val	PSOInterpreter.h	/^    uint8_t val;$/;"	m	class:PSOInterpreter::PendingStoreByte
PSOTraceBuilder	PSOTraceBuilder.cpp	/^PSOTraceBuilder::PSOTraceBuilder(const Configuration &conf) : TSOPSOTraceBuilder(conf) {$/;"	f	class:PSOTraceBuilder
add_branch	PSOTraceBuilder.cpp	/^void PSOTraceBuilder::add_branch(int i, int j){$/;"	f	class:PSOTraceBuilder
atomic_store	PSOTraceBuilder.cpp	/^void PSOTraceBuilder::atomic_store(const ConstMRef &ml){$/;"	f	class:PSOTraceBuilder
check_for_cycles	PSOTraceBuilder.cpp	/^bool PSOTraceBuilder::check_for_cycles(){$/;"	f	class:PSOTraceBuilder
cond_broadcast	PSOTraceBuilder.cpp	/^bool PSOTraceBuilder::cond_broadcast(const ConstMRef &ml){$/;"	f	class:PSOTraceBuilder
cond_destroy	PSOTraceBuilder.cpp	/^int PSOTraceBuilder::cond_destroy(const ConstMRef &ml){$/;"	f	class:PSOTraceBuilder
cond_init	PSOTraceBuilder.cpp	/^bool PSOTraceBuilder::cond_init(const ConstMRef &ml){$/;"	f	class:PSOTraceBuilder
cond_signal	PSOTraceBuilder.cpp	/^bool PSOTraceBuilder::cond_signal(const ConstMRef &ml){$/;"	f	class:PSOTraceBuilder
cond_wait	PSOTraceBuilder.cpp	/^bool PSOTraceBuilder::cond_wait(const ConstMRef &cond_ml, const ConstMRef &mutex_ml){$/;"	f	class:PSOTraceBuilder
debug_print	PSOTraceBuilder.cpp	/^void PSOTraceBuilder::debug_print() const {$/;"	f	class:PSOTraceBuilder
estimate_trace_count	PSOTraceBuilder.cpp	/^int PSOTraceBuilder::estimate_trace_count() const{$/;"	f	class:PSOTraceBuilder
estimate_trace_count	PSOTraceBuilder.cpp	/^int PSOTraceBuilder::estimate_trace_count(int idx) const{$/;"	f	class:PSOTraceBuilder
fence	PSOTraceBuilder.cpp	/^void PSOTraceBuilder::fence(){$/;"	f	class:PSOTraceBuilder
full_memory_conflict	PSOTraceBuilder.cpp	/^void PSOTraceBuilder::full_memory_conflict(){$/;"	f	class:PSOTraceBuilder
get_iid	PSOTraceBuilder.cpp	/^IID<CPid> PSOTraceBuilder::get_iid() const{$/;"	f	class:PSOTraceBuilder
get_trace	PSOTraceBuilder.cpp	/^Trace *PSOTraceBuilder::get_trace() const{$/;"	f	class:PSOTraceBuilder
has_cycle	PSOTraceBuilder.cpp	/^bool PSOTraceBuilder::has_cycle(IID<IPid> *loc) const{$/;"	f	class:PSOTraceBuilder
has_pending_store	PSOTraceBuilder.cpp	/^bool PSOTraceBuilder::has_pending_store(IPid pid, void const *ml) const {$/;"	f	class:PSOTraceBuilder
iid_string	PSOTraceBuilder.cpp	/^std::string PSOTraceBuilder::iid_string(const Event &evt) const{$/;"	f	class:PSOTraceBuilder
is_aux_at_head	PSOTraceBuilder.cpp	/^bool PSOTraceBuilder::is_aux_at_head(IPid pid) const{$/;"	f	class:PSOTraceBuilder
join	PSOTraceBuilder.cpp	/^void PSOTraceBuilder::join(int tgt_proc){$/;"	f	class:PSOTraceBuilder
load	PSOTraceBuilder.cpp	/^void PSOTraceBuilder::load(const ConstMRef &ml){$/;"	f	class:PSOTraceBuilder
mark_available	PSOTraceBuilder.cpp	/^void PSOTraceBuilder::mark_available(int proc, int aux){$/;"	f	class:PSOTraceBuilder
mark_available_ipid	PSOTraceBuilder.cpp	/^void PSOTraceBuilder::mark_available_ipid(IPid pid){$/;"	f	class:PSOTraceBuilder
mark_unavailable	PSOTraceBuilder.cpp	/^void PSOTraceBuilder::mark_unavailable(int proc, int aux){$/;"	f	class:PSOTraceBuilder
mark_unavailable_ipid	PSOTraceBuilder.cpp	/^void PSOTraceBuilder::mark_unavailable_ipid(IPid pid){$/;"	f	class:PSOTraceBuilder
metadata	PSOTraceBuilder.cpp	/^void PSOTraceBuilder::metadata(const llvm::MDNode *md){$/;"	f	class:PSOTraceBuilder
mutex_destroy	PSOTraceBuilder.cpp	/^void PSOTraceBuilder::mutex_destroy(const ConstMRef &ml){$/;"	f	class:PSOTraceBuilder
mutex_init	PSOTraceBuilder.cpp	/^void PSOTraceBuilder::mutex_init(const ConstMRef &ml){$/;"	f	class:PSOTraceBuilder
mutex_lock	PSOTraceBuilder.cpp	/^void PSOTraceBuilder::mutex_lock(const ConstMRef &ml){$/;"	f	class:PSOTraceBuilder
mutex_lock_fail	PSOTraceBuilder.cpp	/^void PSOTraceBuilder::mutex_lock_fail(const ConstMRef &ml){$/;"	f	class:PSOTraceBuilder
mutex_trylock	PSOTraceBuilder.cpp	/^void PSOTraceBuilder::mutex_trylock(const ConstMRef &ml){$/;"	f	class:PSOTraceBuilder
mutex_unlock	PSOTraceBuilder.cpp	/^void PSOTraceBuilder::mutex_unlock(const ConstMRef &ml){$/;"	f	class:PSOTraceBuilder
refuse_schedule	PSOTraceBuilder.cpp	/^void PSOTraceBuilder::refuse_schedule(){$/;"	f	class:PSOTraceBuilder
register_alternatives	PSOTraceBuilder.cpp	/^void PSOTraceBuilder::register_alternatives(int alt_count){$/;"	f	class:PSOTraceBuilder
reset	PSOTraceBuilder.cpp	/^bool PSOTraceBuilder::reset(){$/;"	f	class:PSOTraceBuilder
rpad	PSOTraceBuilder.cpp	/^static std::string rpad(std::string s, int n){$/;"	f	file:
schedule	PSOTraceBuilder.cpp	/^bool PSOTraceBuilder::schedule(int *proc, int *aux, int *alt, bool *dryrun){$/;"	f	class:PSOTraceBuilder
see_events	PSOTraceBuilder.cpp	/^void PSOTraceBuilder::see_events(const VecSet<int> &seen_accesses){$/;"	f	class:PSOTraceBuilder
sleep_set_at	PSOTraceBuilder.cpp	/^VecSet<PSOTraceBuilder::IPid> PSOTraceBuilder::sleep_set_at(int i){$/;"	f	class:PSOTraceBuilder
sleepset_is_empty	PSOTraceBuilder.cpp	/^bool PSOTraceBuilder::sleepset_is_empty() const{$/;"	f	class:PSOTraceBuilder
spawn	PSOTraceBuilder.cpp	/^void PSOTraceBuilder::spawn(){$/;"	f	class:PSOTraceBuilder
store	PSOTraceBuilder.cpp	/^void PSOTraceBuilder::store(const ConstMRef &ml){$/;"	f	class:PSOTraceBuilder
wakeup	PSOTraceBuilder.cpp	/^void PSOTraceBuilder::wakeup(Access::Type type, void const *ml){$/;"	f	class:PSOTraceBuilder
~PSOTraceBuilder	PSOTraceBuilder.cpp	/^PSOTraceBuilder::~PSOTraceBuilder(){$/;"	f	class:PSOTraceBuilder
Access	PSOTraceBuilder.h	/^    Access() : type(NA), ml(0) {};$/;"	f	class:PSOTraceBuilder::Access
Access	PSOTraceBuilder.h	/^    Access(Type t, const void *m) : type(t), ml(m) {};$/;"	f	class:PSOTraceBuilder::Access
Access	PSOTraceBuilder.h	/^  class Access{$/;"	c	class:PSOTraceBuilder
Branch	PSOTraceBuilder.h	/^  class Branch{$/;"	c	class:PSOTraceBuilder
ByteInfo	PSOTraceBuilder.h	/^    ByteInfo() : last_update(-1), last_update_ml(0,1) {};$/;"	f	class:PSOTraceBuilder::ByteInfo
ByteInfo	PSOTraceBuilder.h	/^  class ByteInfo{$/;"	c	class:PSOTraceBuilder
CPS	PSOTraceBuilder.h	/^  CPidSystem CPS;$/;"	m	class:PSOTraceBuilder
CondVar	PSOTraceBuilder.h	/^    CondVar() : last_signal(-1) {};$/;"	f	class:PSOTraceBuilder::CondVar
CondVar	PSOTraceBuilder.h	/^    CondVar(int init_idx) : last_signal(init_idx) {};$/;"	f	class:PSOTraceBuilder::CondVar
CondVar	PSOTraceBuilder.h	/^  class CondVar{$/;"	c	class:PSOTraceBuilder
Event	PSOTraceBuilder.h	/^    Event(const IID<IPid> &iid,$/;"	f	class:PSOTraceBuilder::Event
Event	PSOTraceBuilder.h	/^  class Event{$/;"	c	class:PSOTraceBuilder
IPid	PSOTraceBuilder.h	/^  typedef int IPid;$/;"	t	class:PSOTraceBuilder
Mutex	PSOTraceBuilder.h	/^    Mutex() : last_access(-1), last_lock(-1) {};$/;"	f	class:PSOTraceBuilder::Mutex
Mutex	PSOTraceBuilder.h	/^    Mutex(int lacc) : last_access(lacc), last_lock(-1) {};$/;"	f	class:PSOTraceBuilder::Mutex
Mutex	PSOTraceBuilder.h	/^  class Mutex{$/;"	c	class:PSOTraceBuilder
NA	PSOTraceBuilder.h	/^    enum Type {R, W, W_ALL_MEMORY, NA} type;$/;"	e	enum:PSOTraceBuilder::Access::Type
PSOTraceBuilder	PSOTraceBuilder.h	/^class PSOTraceBuilder : public TSOPSOTraceBuilder{$/;"	c
PendingStoreByte	PSOTraceBuilder.h	/^    PendingStoreByte(const ConstMRef &ml, const VClock<IPid> &clk, const llvm::MDNode *md)$/;"	f	class:PSOTraceBuilder::PendingStoreByte
PendingStoreByte	PSOTraceBuilder.h	/^  class PendingStoreByte{$/;"	c	class:PSOTraceBuilder
R	PSOTraceBuilder.h	/^    enum Type {R, W, W_ALL_MEMORY, NA} type;$/;"	e	enum:PSOTraceBuilder::Access::Type
Thread	PSOTraceBuilder.h	/^    Thread(int proc, const CPid &cpid, const VClock<IPid> &clk, IPid parent)$/;"	f	class:PSOTraceBuilder::Thread
Thread	PSOTraceBuilder.h	/^  class Thread{$/;"	c	class:PSOTraceBuilder
Type	PSOTraceBuilder.h	/^    enum Type {R, W, W_ALL_MEMORY, NA} type;$/;"	g	class:PSOTraceBuilder::Access
W	PSOTraceBuilder.h	/^    enum Type {R, W, W_ALL_MEMORY, NA} type;$/;"	e	enum:PSOTraceBuilder::Access::Type
W_ALL_MEMORY	PSOTraceBuilder.h	/^    enum Type {R, W, W_ALL_MEMORY, NA} type;$/;"	e	enum:PSOTraceBuilder::Access::Type
__PSO_TRACE_BUILDER_H__	PSOTraceBuilder.h	22;"	d
all_buffers_empty	PSOTraceBuilder.h	/^    bool all_buffers_empty() const{$/;"	f	class:PSOTraceBuilder::Thread
alt	PSOTraceBuilder.h	/^    int alt;$/;"	m	class:PSOTraceBuilder::Branch
alt	PSOTraceBuilder.h	/^    int alt;$/;"	m	class:PSOTraceBuilder::Event
aux_clock_sum	PSOTraceBuilder.h	/^    VClock<IPid> aux_clock_sum;$/;"	m	class:PSOTraceBuilder::Thread
aux_to_byte	PSOTraceBuilder.h	/^    std::vector<void const*> aux_to_byte;$/;"	m	class:PSOTraceBuilder::Thread
aux_to_ipid	PSOTraceBuilder.h	/^    std::vector<IPid> aux_to_ipid;$/;"	m	class:PSOTraceBuilder::Thread
available	PSOTraceBuilder.h	/^    bool available;$/;"	m	class:PSOTraceBuilder::Thread
available_auxs	PSOTraceBuilder.h	/^  VecSet<IPid> available_auxs;$/;"	m	class:PSOTraceBuilder
available_threads	PSOTraceBuilder.h	/^  VecSet<IPid> available_threads;$/;"	m	class:PSOTraceBuilder
begin	PSOTraceBuilder.h	/^      std::vector<int>::const_iterator begin() const { return v.begin(); };$/;"	f	struct:PSOTraceBuilder::ByteInfo::last_read_t
begin	PSOTraceBuilder.h	/^      std::vector<int>::iterator begin() { return v.begin(); };$/;"	f	struct:PSOTraceBuilder::ByteInfo::last_read_t
bound	PSOTraceBuilder.h	/^    int bound;$/;"	m	class:PSOTraceBuilder::Event
branch	PSOTraceBuilder.h	/^    VecSet<Branch> branch;$/;"	m	class:PSOTraceBuilder::Event
byte_to_aux	PSOTraceBuilder.h	/^    std::map<void const*,int> byte_to_aux;$/;"	m	class:PSOTraceBuilder::Thread
canRunThisInstruction	PSOTraceBuilder.h	/^  virtual bool canRunThisInstruction() {return true;};$/;"	f	class:PSOTraceBuilder
clock	PSOTraceBuilder.h	/^    VClock<IPid> clock;$/;"	m	class:PSOTraceBuilder::Event
clock	PSOTraceBuilder.h	/^    VClock<IPid> clock;$/;"	m	class:PSOTraceBuilder::PendingStoreByte
clock	PSOTraceBuilder.h	/^    VClock<IPid> clock;$/;"	m	class:PSOTraceBuilder::Thread
cond_vars	PSOTraceBuilder.h	/^  std::map<void const*,CondVar> cond_vars;$/;"	m	class:PSOTraceBuilder
cpid	PSOTraceBuilder.h	/^    CPid cpid;$/;"	m	class:PSOTraceBuilder::Thread
curnode	PSOTraceBuilder.h	/^  Event &curnode() {$/;"	f	class:PSOTraceBuilder
curnode	PSOTraceBuilder.h	/^  const Event &curnode() const {$/;"	f	class:PSOTraceBuilder
dry_sleepers	PSOTraceBuilder.h	/^  int dry_sleepers;$/;"	m	class:PSOTraceBuilder
dryrun	PSOTraceBuilder.h	/^  bool dryrun;$/;"	m	class:PSOTraceBuilder
end	PSOTraceBuilder.h	/^      std::vector<int>::const_iterator end() const { return v.end(); };$/;"	f	struct:PSOTraceBuilder::ByteInfo::last_read_t
end	PSOTraceBuilder.h	/^      std::vector<int>::iterator end() { return v.end(); };$/;"	f	struct:PSOTraceBuilder::ByteInfo::last_read_t
iid	PSOTraceBuilder.h	/^    IID<IPid> iid;$/;"	m	class:PSOTraceBuilder::Event
ipid	PSOTraceBuilder.h	/^  IPid ipid(int proc, int aux) const {$/;"	f	class:PSOTraceBuilder
last_access	PSOTraceBuilder.h	/^    int last_access;$/;"	m	class:PSOTraceBuilder::Mutex
last_full_memory_conflict	PSOTraceBuilder.h	/^  int last_full_memory_conflict;$/;"	m	class:PSOTraceBuilder
last_lock	PSOTraceBuilder.h	/^    int last_lock;$/;"	m	class:PSOTraceBuilder::Mutex
last_md	PSOTraceBuilder.h	/^  const llvm::MDNode *last_md;$/;"	m	class:PSOTraceBuilder
last_read	PSOTraceBuilder.h	/^    } last_read;$/;"	m	class:PSOTraceBuilder::ByteInfo	typeref:struct:PSOTraceBuilder::ByteInfo::last_read_t
last_read_t	PSOTraceBuilder.h	/^    struct last_read_t {$/;"	s	class:PSOTraceBuilder::ByteInfo
last_rowe	PSOTraceBuilder.h	/^    int last_rowe;$/;"	m	class:PSOTraceBuilder::PendingStoreByte
last_signal	PSOTraceBuilder.h	/^    int last_signal;$/;"	m	class:PSOTraceBuilder::CondVar
last_update	PSOTraceBuilder.h	/^    int last_update;$/;"	m	class:PSOTraceBuilder::ByteInfo
last_update_ml	PSOTraceBuilder.h	/^    ConstMRef last_update_ml;$/;"	m	class:PSOTraceBuilder::ByteInfo
may_conflict	PSOTraceBuilder.h	/^    bool may_conflict;$/;"	m	class:PSOTraceBuilder::Event
md	PSOTraceBuilder.h	/^    const llvm::MDNode *md;$/;"	m	class:PSOTraceBuilder::Event
md	PSOTraceBuilder.h	/^    const llvm::MDNode *md;$/;"	m	class:PSOTraceBuilder::PendingStoreByte
mem	PSOTraceBuilder.h	/^  std::map<const void*,ByteInfo> mem;$/;"	m	class:PSOTraceBuilder
ml	PSOTraceBuilder.h	/^    ConstMRef ml;$/;"	m	class:PSOTraceBuilder::PendingStoreByte
ml	PSOTraceBuilder.h	/^    const void *ml;$/;"	m	class:PSOTraceBuilder::Access
mutexes	PSOTraceBuilder.h	/^  std::map<void const*,Mutex> mutexes;$/;"	m	class:PSOTraceBuilder
operator <	PSOTraceBuilder.h	/^    bool operator<(const Access &a) const{$/;"	f	class:PSOTraceBuilder::Access
operator <	PSOTraceBuilder.h	/^    bool operator<(const Branch &b) const{$/;"	f	class:PSOTraceBuilder::Branch
operator ==	PSOTraceBuilder.h	/^    bool operator==(const Access &a) const{$/;"	f	class:PSOTraceBuilder::Access
operator ==	PSOTraceBuilder.h	/^    bool operator==(const Branch &b) const{$/;"	f	class:PSOTraceBuilder::Branch
operator []	PSOTraceBuilder.h	/^      int &operator[](int i) {$/;"	f	struct:PSOTraceBuilder::ByteInfo::last_read_t
operator []	PSOTraceBuilder.h	/^      int operator[](int i) const { return (i < int(v.size()) ? v[i] : -1); };$/;"	f	struct:PSOTraceBuilder::ByteInfo::last_read_t
origin_iid	PSOTraceBuilder.h	/^    IID<IPid> origin_iid;$/;"	m	class:PSOTraceBuilder::Event
parent	PSOTraceBuilder.h	/^    IPid parent;$/;"	m	class:PSOTraceBuilder::Thread
pid	PSOTraceBuilder.h	/^    IPid pid;$/;"	m	class:PSOTraceBuilder::Branch
prefix	PSOTraceBuilder.h	/^  std::vector<Event> prefix;$/;"	m	class:PSOTraceBuilder
prefix_idx	PSOTraceBuilder.h	/^  int prefix_idx;$/;"	m	class:PSOTraceBuilder
proc	PSOTraceBuilder.h	/^    int proc;$/;"	m	class:PSOTraceBuilder::Thread
proc_to_ipid	PSOTraceBuilder.h	/^  std::vector<IPid> proc_to_ipid;$/;"	m	class:PSOTraceBuilder
replay	PSOTraceBuilder.h	/^  bool replay;$/;"	m	class:PSOTraceBuilder
size	PSOTraceBuilder.h	/^    int size;$/;"	m	class:PSOTraceBuilder::Event
sleep	PSOTraceBuilder.h	/^    VecSet<IPid> sleep;$/;"	m	class:PSOTraceBuilder::Event
sleep_accesses_r	PSOTraceBuilder.h	/^    VecSet<void const *> sleep_accesses_r;$/;"	m	class:PSOTraceBuilder::Thread
sleep_accesses_w	PSOTraceBuilder.h	/^    VecSet<void const *> sleep_accesses_w;$/;"	m	class:PSOTraceBuilder::Thread
sleep_branch_trace_count	PSOTraceBuilder.h	/^    int sleep_branch_trace_count;$/;"	m	class:PSOTraceBuilder::Event
sleep_full_memory_conflict	PSOTraceBuilder.h	/^    bool sleep_full_memory_conflict;$/;"	m	class:PSOTraceBuilder::Thread
sleepers	PSOTraceBuilder.h	/^  VecSet<IPid> sleepers;$/;"	m	class:PSOTraceBuilder
sleeping	PSOTraceBuilder.h	/^    bool sleeping;$/;"	m	class:PSOTraceBuilder::Thread
store_buffers	PSOTraceBuilder.h	/^    std::map<void const*,std::vector<PendingStoreByte> > store_buffers;$/;"	m	class:PSOTraceBuilder::Thread
threads	PSOTraceBuilder.h	/^  std::vector<Thread> threads;$/;"	m	class:PSOTraceBuilder
type	PSOTraceBuilder.h	/^    enum Type {R, W, W_ALL_MEMORY, NA} type;$/;"	m	class:PSOTraceBuilder::Access	typeref:enum:PSOTraceBuilder::Access::Type
v	PSOTraceBuilder.h	/^      std::vector<int> v;$/;"	m	struct:PSOTraceBuilder::ByteInfo::last_read_t
waiters	PSOTraceBuilder.h	/^    std::vector<int> waiters;$/;"	m	class:PSOTraceBuilder::CondVar
wakeup	PSOTraceBuilder.h	/^    VecSet<IPid> wakeup;$/;"	m	class:PSOTraceBuilder::Event
BOOST_AUTO_TEST_CASE	PSO_test.cpp	/^BOOST_AUTO_TEST_CASE(Atomic_1){$/;"	f
BOOST_AUTO_TEST_CASE	PSO_test.cpp	/^BOOST_AUTO_TEST_CASE(Atomic_4){$/;"	f
BOOST_AUTO_TEST_CASE	PSO_test.cpp	/^BOOST_AUTO_TEST_CASE(Atomic_8){$/;"	f
BOOST_AUTO_TEST_CASE	PSO_test.cpp	/^BOOST_AUTO_TEST_CASE(Atomic_9){$/;"	f
BOOST_AUTO_TEST_CASE	PSO_test.cpp	/^BOOST_AUTO_TEST_CASE(Atomic_and_nonatomic_writes){$/;"	f
BOOST_AUTO_TEST_CASE	PSO_test.cpp	/^BOOST_AUTO_TEST_CASE(Atomic_store_1){$/;"	f
BOOST_AUTO_TEST_CASE	PSO_test.cpp	/^BOOST_AUTO_TEST_CASE(Atomic_store_2){$/;"	f
BOOST_AUTO_TEST_CASE	PSO_test.cpp	/^BOOST_AUTO_TEST_CASE(Atomic_store_3){$/;"	f
BOOST_AUTO_TEST_CASE	PSO_test.cpp	/^BOOST_AUTO_TEST_CASE(Bitcast_rowe_1){$/;"	f
BOOST_AUTO_TEST_CASE	PSO_test.cpp	/^BOOST_AUTO_TEST_CASE(Bitcast_rowe_2){$/;"	f
BOOST_AUTO_TEST_CASE	PSO_test.cpp	/^BOOST_AUTO_TEST_CASE(CMPXCHG_1){$/;"	f
BOOST_AUTO_TEST_CASE	PSO_test.cpp	/^BOOST_AUTO_TEST_CASE(CMPXCHG_2){$/;"	f
BOOST_AUTO_TEST_CASE	PSO_test.cpp	/^BOOST_AUTO_TEST_CASE(CMPXCHG_3){$/;"	f
BOOST_AUTO_TEST_CASE	PSO_test.cpp	/^BOOST_AUTO_TEST_CASE(CMPXCHG_4){$/;"	f
BOOST_AUTO_TEST_CASE	PSO_test.cpp	/^BOOST_AUTO_TEST_CASE(CMPXCHG_5){$/;"	f
BOOST_AUTO_TEST_CASE	PSO_test.cpp	/^BOOST_AUTO_TEST_CASE(Dealloc_buffer_id){$/;"	f
BOOST_AUTO_TEST_CASE	PSO_test.cpp	/^BOOST_AUTO_TEST_CASE(Full_conflict_1){$/;"	f
BOOST_AUTO_TEST_CASE	PSO_test.cpp	/^BOOST_AUTO_TEST_CASE(Full_conflict_10){$/;"	f
BOOST_AUTO_TEST_CASE	PSO_test.cpp	/^BOOST_AUTO_TEST_CASE(Full_conflict_2){$/;"	f
BOOST_AUTO_TEST_CASE	PSO_test.cpp	/^BOOST_AUTO_TEST_CASE(Full_conflict_3){$/;"	f
BOOST_AUTO_TEST_CASE	PSO_test.cpp	/^BOOST_AUTO_TEST_CASE(Full_conflict_4){$/;"	f
BOOST_AUTO_TEST_CASE	PSO_test.cpp	/^BOOST_AUTO_TEST_CASE(Full_conflict_6){$/;"	f
BOOST_AUTO_TEST_CASE	PSO_test.cpp	/^BOOST_AUTO_TEST_CASE(Full_conflict_7){$/;"	f
BOOST_AUTO_TEST_CASE	PSO_test.cpp	/^BOOST_AUTO_TEST_CASE(Full_conflict_8){$/;"	f
BOOST_AUTO_TEST_CASE	PSO_test.cpp	/^BOOST_AUTO_TEST_CASE(Full_conflict_9){$/;"	f
BOOST_AUTO_TEST_CASE	PSO_test.cpp	/^BOOST_AUTO_TEST_CASE(Join_1){$/;"	f
BOOST_AUTO_TEST_CASE	PSO_test.cpp	/^BOOST_AUTO_TEST_CASE(Join_2){$/;"	f
BOOST_AUTO_TEST_CASE	PSO_test.cpp	/^BOOST_AUTO_TEST_CASE(Join_3){$/;"	f
BOOST_AUTO_TEST_CASE	PSO_test.cpp	/^BOOST_AUTO_TEST_CASE(Malloc_1){$/;"	f
BOOST_AUTO_TEST_CASE	PSO_test.cpp	/^BOOST_AUTO_TEST_CASE(Malloc_2){$/;"	f
BOOST_AUTO_TEST_CASE	PSO_test.cpp	/^BOOST_AUTO_TEST_CASE(Mutex_1){$/;"	f
BOOST_AUTO_TEST_CASE	PSO_test.cpp	/^BOOST_AUTO_TEST_CASE(Mutex_10){$/;"	f
BOOST_AUTO_TEST_CASE	PSO_test.cpp	/^BOOST_AUTO_TEST_CASE(Mutex_11){$/;"	f
BOOST_AUTO_TEST_CASE	PSO_test.cpp	/^BOOST_AUTO_TEST_CASE(Mutex_12){$/;"	f
BOOST_AUTO_TEST_CASE	PSO_test.cpp	/^BOOST_AUTO_TEST_CASE(Mutex_2){$/;"	f
BOOST_AUTO_TEST_CASE	PSO_test.cpp	/^BOOST_AUTO_TEST_CASE(Mutex_3){$/;"	f
BOOST_AUTO_TEST_CASE	PSO_test.cpp	/^BOOST_AUTO_TEST_CASE(Mutex_4){$/;"	f
BOOST_AUTO_TEST_CASE	PSO_test.cpp	/^BOOST_AUTO_TEST_CASE(Mutex_5){$/;"	f
BOOST_AUTO_TEST_CASE	PSO_test.cpp	/^BOOST_AUTO_TEST_CASE(Mutex_6){$/;"	f
BOOST_AUTO_TEST_CASE	PSO_test.cpp	/^BOOST_AUTO_TEST_CASE(Mutex_7){$/;"	f
BOOST_AUTO_TEST_CASE	PSO_test.cpp	/^BOOST_AUTO_TEST_CASE(Mutex_8){$/;"	f
BOOST_AUTO_TEST_CASE	PSO_test.cpp	/^BOOST_AUTO_TEST_CASE(Mutex_9){$/;"	f
BOOST_AUTO_TEST_CASE	PSO_test.cpp	/^BOOST_AUTO_TEST_CASE(Overlapping_ROWE_1){$/;"	f
BOOST_AUTO_TEST_CASE	PSO_test.cpp	/^BOOST_AUTO_TEST_CASE(Overlapping_ROWE_2){$/;"	f
BOOST_AUTO_TEST_CASE	PSO_test.cpp	/^BOOST_AUTO_TEST_CASE(Overlapping_ROWE_3){$/;"	f
BOOST_AUTO_TEST_CASE	PSO_test.cpp	/^BOOST_AUTO_TEST_CASE(Overlapping_ROWE_4){$/;"	f
BOOST_AUTO_TEST_CASE	PSO_test.cpp	/^BOOST_AUTO_TEST_CASE(Overlapping_ROWE_5){$/;"	f
BOOST_AUTO_TEST_CASE	PSO_test.cpp	/^BOOST_AUTO_TEST_CASE(Peterson){$/;"	f
BOOST_AUTO_TEST_CASE	PSO_test.cpp	/^BOOST_AUTO_TEST_CASE(Peterson_nop){$/;"	f
BOOST_AUTO_TEST_CASE	PSO_test.cpp	/^BOOST_AUTO_TEST_CASE(Small_rowe){$/;"	f
BOOST_AUTO_TEST_CASE	PSO_test.cpp	/^BOOST_AUTO_TEST_CASE(Small_rowe_2){$/;"	f
BOOST_AUTO_TEST_CASE	PSO_test.cpp	/^BOOST_AUTO_TEST_CASE(Wakeup_bug_1){$/;"	f
BOOST_AUTO_TEST_CASE	PSO_test.cpp	/^BOOST_AUTO_TEST_CASE(Wakeup_bug_2){$/;"	f
BOOST_AUTO_TEST_CASE	PSO_test.cpp	/^BOOST_AUTO_TEST_CASE(fib_fragment){$/;"	f
BOOST_AUTO_TEST_CASE	PSO_test.cpp	/^BOOST_AUTO_TEST_CASE(fib_simple){$/;"	f
BOOST_AUTO_TEST_CASE	PSO_test.cpp	/^BOOST_AUTO_TEST_CASE(minimal){$/;"	f
BOOST_AUTO_TEST_CASE	PSO_test.cpp	/^BOOST_AUTO_TEST_CASE(mp){$/;"	f
BOOST_AUTO_TEST_CASE	PSO_test.cpp	/^BOOST_AUTO_TEST_CASE(mp_2){$/;"	f
BOOST_AUTO_TEST_CASE	PSO_test.cpp	/^BOOST_AUTO_TEST_CASE(mp_3){$/;"	f
BOOST_AUTO_TEST_CASE	PSO_test2.cpp	/^BOOST_AUTO_TEST_CASE(Compiler_fence_mp){$/;"	f
BOOST_AUTO_TEST_CASE	PSO_test2.cpp	/^BOOST_AUTO_TEST_CASE(Condvar_1){$/;"	f
BOOST_AUTO_TEST_CASE	PSO_test2.cpp	/^BOOST_AUTO_TEST_CASE(Condvar_10){$/;"	f
BOOST_AUTO_TEST_CASE	PSO_test2.cpp	/^BOOST_AUTO_TEST_CASE(Condvar_11){$/;"	f
BOOST_AUTO_TEST_CASE	PSO_test2.cpp	/^BOOST_AUTO_TEST_CASE(Condvar_12){$/;"	f
BOOST_AUTO_TEST_CASE	PSO_test2.cpp	/^BOOST_AUTO_TEST_CASE(Condvar_13){$/;"	f
BOOST_AUTO_TEST_CASE	PSO_test2.cpp	/^BOOST_AUTO_TEST_CASE(Condvar_14){$/;"	f
BOOST_AUTO_TEST_CASE	PSO_test2.cpp	/^BOOST_AUTO_TEST_CASE(Condvar_2){$/;"	f
BOOST_AUTO_TEST_CASE	PSO_test2.cpp	/^BOOST_AUTO_TEST_CASE(Condvar_3){$/;"	f
BOOST_AUTO_TEST_CASE	PSO_test2.cpp	/^BOOST_AUTO_TEST_CASE(Condvar_4){$/;"	f
BOOST_AUTO_TEST_CASE	PSO_test2.cpp	/^BOOST_AUTO_TEST_CASE(Condvar_5){$/;"	f
BOOST_AUTO_TEST_CASE	PSO_test2.cpp	/^BOOST_AUTO_TEST_CASE(Condvar_6){$/;"	f
BOOST_AUTO_TEST_CASE	PSO_test2.cpp	/^BOOST_AUTO_TEST_CASE(Condvar_7){$/;"	f
BOOST_AUTO_TEST_CASE	PSO_test2.cpp	/^BOOST_AUTO_TEST_CASE(Condvar_8){$/;"	f
BOOST_AUTO_TEST_CASE	PSO_test2.cpp	/^BOOST_AUTO_TEST_CASE(Condvar_9){$/;"	f
BOOST_AUTO_TEST_CASE	PSO_test2.cpp	/^BOOST_AUTO_TEST_CASE(Mutex_trylock_1){$/;"	f
BOOST_AUTO_TEST_CASE	PSO_test2.cpp	/^BOOST_AUTO_TEST_CASE(Overlapping_store_1){$/;"	f
BOOST_AUTO_TEST_CASE	PSO_test2.cpp	/^BOOST_AUTO_TEST_CASE(Overlapping_store_2){$/;"	f
BOOST_AUTO_TEST_CASE	PSO_test2.cpp	/^BOOST_AUTO_TEST_CASE(Overlapping_store_3){$/;"	f
BOOST_AUTO_TEST_CASE	RMW_test.cpp	/^BOOST_AUTO_TEST_CASE(RMW_add){$/;"	f
BOOST_AUTO_TEST_CASE	RMW_test.cpp	/^BOOST_AUTO_TEST_CASE(RMW_and){$/;"	f
BOOST_AUTO_TEST_CASE	RMW_test.cpp	/^BOOST_AUTO_TEST_CASE(RMW_max){$/;"	f
BOOST_AUTO_TEST_CASE	RMW_test.cpp	/^BOOST_AUTO_TEST_CASE(RMW_min){$/;"	f
BOOST_AUTO_TEST_CASE	RMW_test.cpp	/^BOOST_AUTO_TEST_CASE(RMW_nand){$/;"	f
BOOST_AUTO_TEST_CASE	RMW_test.cpp	/^BOOST_AUTO_TEST_CASE(RMW_or){$/;"	f
BOOST_AUTO_TEST_CASE	RMW_test.cpp	/^BOOST_AUTO_TEST_CASE(RMW_sub){$/;"	f
BOOST_AUTO_TEST_CASE	RMW_test.cpp	/^BOOST_AUTO_TEST_CASE(RMW_umax){$/;"	f
BOOST_AUTO_TEST_CASE	RMW_test.cpp	/^BOOST_AUTO_TEST_CASE(RMW_xchg){$/;"	f
BOOST_AUTO_TEST_CASE	RMW_test.cpp	/^BOOST_AUTO_TEST_CASE(RMW_xor){$/;"	f
MMs	RMW_test.cpp	/^static VecSet<Configuration::MemoryModel> MMs = {$/;"	v	file:
BOOST_AUTO_TEST_CASE	Robustness_test.cpp	/^BOOST_AUTO_TEST_CASE(Robustness_small_pso_1){$/;"	f
BOOST_AUTO_TEST_CASE	Robustness_test.cpp	/^BOOST_AUTO_TEST_CASE(Robustness_small_pso_2){$/;"	f
BOOST_AUTO_TEST_CASE	Robustness_test.cpp	/^BOOST_AUTO_TEST_CASE(Robustness_small_pso_3){$/;"	f
BOOST_AUTO_TEST_CASE	Robustness_test.cpp	/^BOOST_AUTO_TEST_CASE(Robustness_small_pso_4){$/;"	f
BOOST_AUTO_TEST_CASE	Robustness_test.cpp	/^BOOST_AUTO_TEST_CASE(Robustness_small_pso_5){$/;"	f
BOOST_AUTO_TEST_CASE	Robustness_test.cpp	/^BOOST_AUTO_TEST_CASE(Robustness_small_pso_6){$/;"	f
BOOST_AUTO_TEST_CASE	Robustness_test.cpp	/^BOOST_AUTO_TEST_CASE(Robustness_small_pso_7){$/;"	f
BOOST_AUTO_TEST_CASE	Robustness_test.cpp	/^BOOST_AUTO_TEST_CASE(Robustness_small_pso_8){$/;"	f
BOOST_AUTO_TEST_CASE	Robustness_test.cpp	/^BOOST_AUTO_TEST_CASE(Robustness_small_tso_1){$/;"	f
BOOST_AUTO_TEST_CASE	Robustness_test.cpp	/^BOOST_AUTO_TEST_CASE(Robustness_small_tso_2){$/;"	f
BOOST_AUTO_TEST_CASE	Robustness_test.cpp	/^BOOST_AUTO_TEST_CASE(Robustness_small_tso_3){$/;"	f
BOOST_AUTO_TEST_CASE	Robustness_test.cpp	/^BOOST_AUTO_TEST_CASE(Robustness_small_tso_4){$/;"	f
BOOST_AUTO_TEST_CASE	Robustness_test.cpp	/^BOOST_AUTO_TEST_CASE(Robustness_small_tso_5){$/;"	f
BOOST_AUTO_TEST_CASE	Robustness_test.cpp	/^BOOST_AUTO_TEST_CASE(Robustness_small_tso_6){$/;"	f
BOOST_AUTO_TEST_CASE	Robustness_test.cpp	/^BOOST_AUTO_TEST_CASE(Robustness_small_tso_7){$/;"	f
BOOST_AUTO_TEST_CASE	Robustness_test.cpp	/^BOOST_AUTO_TEST_CASE(Robustness_small_tso_8){$/;"	f
BOOST_AUTO_TEST_CASE	SC_test.cpp	/^BOOST_AUTO_TEST_CASE(Atexit_1){$/;"	f
BOOST_AUTO_TEST_CASE	SC_test.cpp	/^BOOST_AUTO_TEST_CASE(Atexit_2){$/;"	f
BOOST_AUTO_TEST_CASE	SC_test.cpp	/^BOOST_AUTO_TEST_CASE(Atexit_3){$/;"	f
BOOST_AUTO_TEST_CASE	SC_test.cpp	/^BOOST_AUTO_TEST_CASE(Atexit_4){$/;"	f
BOOST_AUTO_TEST_CASE	SC_test.cpp	/^BOOST_AUTO_TEST_CASE(Atexit_5){$/;"	f
BOOST_AUTO_TEST_CASE	SC_test.cpp	/^BOOST_AUTO_TEST_CASE(Atexit_6){$/;"	f
BOOST_AUTO_TEST_CASE	SC_test.cpp	/^BOOST_AUTO_TEST_CASE(Atexit_multithreaded){$/;"	f
BOOST_AUTO_TEST_CASE	SC_test.cpp	/^BOOST_AUTO_TEST_CASE(Atomic_1){$/;"	f
BOOST_AUTO_TEST_CASE	SC_test.cpp	/^BOOST_AUTO_TEST_CASE(Atomic_3){$/;"	f
BOOST_AUTO_TEST_CASE	SC_test.cpp	/^BOOST_AUTO_TEST_CASE(Atomic_5){$/;"	f
BOOST_AUTO_TEST_CASE	SC_test.cpp	/^BOOST_AUTO_TEST_CASE(Atomic_6){$/;"	f
BOOST_AUTO_TEST_CASE	SC_test.cpp	/^BOOST_AUTO_TEST_CASE(Atomic_7){$/;"	f
BOOST_AUTO_TEST_CASE	SC_test.cpp	/^BOOST_AUTO_TEST_CASE(Atomic_8){$/;"	f
BOOST_AUTO_TEST_CASE	SC_test.cpp	/^BOOST_AUTO_TEST_CASE(Atomic_9){$/;"	f
BOOST_AUTO_TEST_CASE	SC_test.cpp	/^BOOST_AUTO_TEST_CASE(Condvar_1){$/;"	f
BOOST_AUTO_TEST_CASE	SC_test.cpp	/^BOOST_AUTO_TEST_CASE(Condvar_10){$/;"	f
BOOST_AUTO_TEST_CASE	SC_test.cpp	/^BOOST_AUTO_TEST_CASE(Condvar_11){$/;"	f
BOOST_AUTO_TEST_CASE	SC_test.cpp	/^BOOST_AUTO_TEST_CASE(Condvar_12){$/;"	f
BOOST_AUTO_TEST_CASE	SC_test.cpp	/^BOOST_AUTO_TEST_CASE(Condvar_13){$/;"	f
BOOST_AUTO_TEST_CASE	SC_test.cpp	/^BOOST_AUTO_TEST_CASE(Condvar_14){$/;"	f
BOOST_AUTO_TEST_CASE	SC_test.cpp	/^BOOST_AUTO_TEST_CASE(Condvar_2){$/;"	f
BOOST_AUTO_TEST_CASE	SC_test.cpp	/^BOOST_AUTO_TEST_CASE(Condvar_3){$/;"	f
BOOST_AUTO_TEST_CASE	SC_test.cpp	/^BOOST_AUTO_TEST_CASE(Condvar_4){$/;"	f
BOOST_AUTO_TEST_CASE	SC_test.cpp	/^BOOST_AUTO_TEST_CASE(Condvar_5){$/;"	f
BOOST_AUTO_TEST_CASE	SC_test.cpp	/^BOOST_AUTO_TEST_CASE(Condvar_6){$/;"	f
BOOST_AUTO_TEST_CASE	SC_test.cpp	/^BOOST_AUTO_TEST_CASE(Condvar_7){$/;"	f
BOOST_AUTO_TEST_CASE	SC_test.cpp	/^BOOST_AUTO_TEST_CASE(Condvar_8){$/;"	f
BOOST_AUTO_TEST_CASE	SC_test.cpp	/^BOOST_AUTO_TEST_CASE(Condvar_9){$/;"	f
BOOST_AUTO_TEST_CASE	SC_test.cpp	/^BOOST_AUTO_TEST_CASE(Double_free_1){$/;"	f
BOOST_AUTO_TEST_CASE	SC_test.cpp	/^BOOST_AUTO_TEST_CASE(Free_global_1){$/;"	f
BOOST_AUTO_TEST_CASE	SC_test.cpp	/^BOOST_AUTO_TEST_CASE(Free_null_1){$/;"	f
BOOST_AUTO_TEST_CASE	SC_test.cpp	/^BOOST_AUTO_TEST_CASE(Free_stack_1){$/;"	f
BOOST_AUTO_TEST_CASE	SC_test.cpp	/^BOOST_AUTO_TEST_CASE(Full_conflict_1){$/;"	f
BOOST_AUTO_TEST_CASE	SC_test.cpp	/^BOOST_AUTO_TEST_CASE(Full_conflict_10){$/;"	f
BOOST_AUTO_TEST_CASE	SC_test.cpp	/^BOOST_AUTO_TEST_CASE(Full_conflict_2){$/;"	f
BOOST_AUTO_TEST_CASE	SC_test.cpp	/^BOOST_AUTO_TEST_CASE(Full_conflict_3){$/;"	f
BOOST_AUTO_TEST_CASE	SC_test.cpp	/^BOOST_AUTO_TEST_CASE(Full_conflict_4){$/;"	f
BOOST_AUTO_TEST_CASE	SC_test.cpp	/^BOOST_AUTO_TEST_CASE(Full_conflict_6){$/;"	f
BOOST_AUTO_TEST_CASE	SC_test.cpp	/^BOOST_AUTO_TEST_CASE(Full_conflict_7){$/;"	f
BOOST_AUTO_TEST_CASE	SC_test.cpp	/^BOOST_AUTO_TEST_CASE(Full_conflict_8){$/;"	f
BOOST_AUTO_TEST_CASE	SC_test.cpp	/^BOOST_AUTO_TEST_CASE(Full_conflict_9){$/;"	f
BOOST_AUTO_TEST_CASE	SC_test.cpp	/^BOOST_AUTO_TEST_CASE(Intrinsic_2){$/;"	f
BOOST_AUTO_TEST_CASE	SC_test.cpp	/^BOOST_AUTO_TEST_CASE(Intrinsic_first){$/;"	f
BOOST_AUTO_TEST_CASE	SC_test.cpp	/^BOOST_AUTO_TEST_CASE(Memory_leak_1){$/;"	f
BOOST_AUTO_TEST_CASE	SC_test.cpp	/^BOOST_AUTO_TEST_CASE(Mutex_trylock_1){$/;"	f
BOOST_AUTO_TEST_CASE	SC_test.cpp	/^BOOST_AUTO_TEST_CASE(fib_simple_n2_sc){$/;"	f
BOOST_AUTO_TEST_CASE	SC_test2.cpp	/^BOOST_AUTO_TEST_CASE(CAS_load){$/;"	f
BOOST_AUTO_TEST_CASE	SC_test2.cpp	/^BOOST_AUTO_TEST_CASE(Compiler_fence_dekker){$/;"	f
BOOST_AUTO_TEST_CASE	SC_test2.cpp	/^BOOST_AUTO_TEST_CASE(Thread_local_1){$/;"	f
BOOST_AUTO_TEST_CASE	SC_test2.cpp	/^BOOST_AUTO_TEST_CASE(Thread_local_2){$/;"	f
BOOST_AUTO_TEST_CASE	SC_test2.cpp	/^BOOST_AUTO_TEST_CASE(Thread_local_3){ \/\/ Initialization$/;"	f
SigSegvHandler	SigSegvHandler.cpp	/^namespace SigSegvHandler {$/;"	n	file:
env	SigSegvHandler.cpp	/^  sigjmp_buf env;$/;"	m	namespace:SigSegvHandler	file:
env_is_enabled	SigSegvHandler.cpp	/^  bool env_is_enabled = false;$/;"	m	namespace:SigSegvHandler	file:
original_action	SigSegvHandler.cpp	/^  static struct sigaction original_action;$/;"	m	namespace:SigSegvHandler	typeref:struct:SigSegvHandler::sigaction	file:
reset_signal_handler	SigSegvHandler.cpp	/^  void reset_signal_handler(){$/;"	f	namespace:SigSegvHandler
setenv	SigSegvHandler.cpp	/^  bool setenv(){$/;"	f	namespace:SigSegvHandler
setup_signal_handler	SigSegvHandler.cpp	/^  void setup_signal_handler(){$/;"	f	namespace:SigSegvHandler
sigsegv_handler	SigSegvHandler.cpp	/^  void sigsegv_handler(int signum){$/;"	f	namespace:SigSegvHandler
unsetenv	SigSegvHandler.cpp	/^  void unsetenv(){$/;"	f	namespace:SigSegvHandler
SigSegvHandler	SigSegvHandler.h	/^namespace SigSegvHandler {$/;"	n
__SIGSEGV_HANDLER_H__	SigSegvHandler.h	23;"	d
ID	SpinAssumePass.cpp	/^char DeclareAssumePass::ID = 0;$/;"	m	class:DeclareAssumePass	file:
ID	SpinAssumePass.cpp	/^char SpinAssumePass::ID = 0;$/;"	m	class:SpinAssumePass	file:
assumify_loop	SpinAssumePass.cpp	/^bool SpinAssumePass::assumify_loop(llvm::Loop *l,llvm::LPPassManager &LPM){$/;"	f	class:SpinAssumePass
getAnalysisUsage	SpinAssumePass.cpp	/^void SpinAssumePass::getAnalysisUsage(llvm::AnalysisUsage &AU) const{$/;"	f	class:SpinAssumePass
is_assume	SpinAssumePass.cpp	/^bool SpinAssumePass::is_assume(llvm::Instruction &I) const {$/;"	f	class:SpinAssumePass
is_spin	SpinAssumePass.cpp	/^bool SpinAssumePass::is_spin(const llvm::Loop *l) const{$/;"	f	class:SpinAssumePass
remove_disconnected	SpinAssumePass.cpp	/^void SpinAssumePass::remove_disconnected(llvm::Loop *l){$/;"	f	class:SpinAssumePass
runOnLoop	SpinAssumePass.cpp	/^bool SpinAssumePass::runOnLoop(llvm::Loop *L, llvm::LPPassManager &LPM){$/;"	f	class:SpinAssumePass
runOnModule	SpinAssumePass.cpp	/^bool DeclareAssumePass::runOnModule(llvm::Module &M){$/;"	f	class:DeclareAssumePass
DeclareAssumePass	SpinAssumePass.h	/^  DeclareAssumePass() : llvm::ModulePass(ID) {};$/;"	f	class:DeclareAssumePass
DeclareAssumePass	SpinAssumePass.h	/^class DeclareAssumePass : public llvm::ModulePass {$/;"	c
F_assume	SpinAssumePass.h	/^  llvm::Function *F_assume;$/;"	m	class:SpinAssumePass
ID	SpinAssumePass.h	/^  static char ID;$/;"	m	class:DeclareAssumePass
ID	SpinAssumePass.h	/^  static char ID;$/;"	m	class:SpinAssumePass
SpinAssumePass	SpinAssumePass.h	/^  SpinAssumePass() : llvm::LoopPass(ID) {};$/;"	f	class:SpinAssumePass
SpinAssumePass	SpinAssumePass.h	/^class SpinAssumePass : public llvm::LoopPass{$/;"	c
__SPIN_ASSUME_PASS_H__	SpinAssumePass.h	21;"	d
getPassName	SpinAssumePass.h	/^  virtual const char *getPassName() const { return "SpinAssumePass"; };$/;"	f	class:SpinAssumePass
StrModule	StrModule.cpp	/^namespace StrModule {$/;"	n	file:
portasm	StrModule.cpp	/^  std::string portasm(std::string s){$/;"	f	namespace:StrModule
read_module	StrModule.cpp	/^  llvm::Module *read_module(std::string infile){$/;"	f	namespace:StrModule
read_module_src	StrModule.cpp	/^  llvm::Module *read_module_src(const std::string &src){$/;"	f	namespace:StrModule
write_module	StrModule.cpp	/^  void write_module(llvm::Module *mod, std::string outfile){$/;"	f	namespace:StrModule
write_module_str	StrModule.cpp	/^  std::string write_module_str(llvm::Module *mod){$/;"	f	namespace:StrModule
StrModule	StrModule.h	/^namespace StrModule {$/;"	n
__STR_MODULE_H__	StrModule.h	21;"	d
SetValue	TSOInterpreter.cpp	/^static void SetValue(llvm::Value *V, llvm::GenericValue Val, llvm::ExecutionContext &SF) {$/;"	f	file:
TSOInterpreter	TSOInterpreter.cpp	/^TSOInterpreter::TSOInterpreter(llvm::Module *M, TSOTraceBuilder &TB,$/;"	f	class:TSOInterpreter
checkRefuse	TSOInterpreter.cpp	/^bool TSOInterpreter::checkRefuse(llvm::Instruction &I){$/;"	f	class:TSOInterpreter
create	TSOInterpreter.cpp	/^llvm::ExecutionEngine *TSOInterpreter::create(llvm::Module *M, TSOTraceBuilder &TB,$/;"	f	class:TSOInterpreter
isFence	TSOInterpreter.cpp	/^bool TSOInterpreter::isFence(llvm::Instruction &I){$/;"	f	class:TSOInterpreter
newThread	TSOInterpreter.cpp	/^int TSOInterpreter::newThread(const CPid &cpid){$/;"	f	class:TSOInterpreter
runAux	TSOInterpreter.cpp	/^void TSOInterpreter::runAux(int proc, int aux){$/;"	f	class:TSOInterpreter
terminate	TSOInterpreter.cpp	/^void TSOInterpreter::terminate(llvm::Type *RetTy, llvm::GenericValue Result){$/;"	f	class:TSOInterpreter
visitAtomicCmpXchgInst	TSOInterpreter.cpp	/^void TSOInterpreter::visitAtomicCmpXchgInst(llvm::AtomicCmpXchgInst &I){$/;"	f	class:TSOInterpreter
visitAtomicRMWInst	TSOInterpreter.cpp	/^void TSOInterpreter::visitAtomicRMWInst(llvm::AtomicRMWInst &I){$/;"	f	class:TSOInterpreter
visitFenceInst	TSOInterpreter.cpp	/^void TSOInterpreter::visitFenceInst(llvm::FenceInst &I){$/;"	f	class:TSOInterpreter
visitInlineAsm	TSOInterpreter.cpp	/^void TSOInterpreter::visitInlineAsm(llvm::CallSite &CS, const std::string &asmstr){$/;"	f	class:TSOInterpreter
visitLoadInst	TSOInterpreter.cpp	/^void TSOInterpreter::visitLoadInst(llvm::LoadInst &I){$/;"	f	class:TSOInterpreter
visitStoreInst	TSOInterpreter.cpp	/^void TSOInterpreter::visitStoreInst(llvm::StoreInst &I){$/;"	f	class:TSOInterpreter
~TSOInterpreter	TSOInterpreter.cpp	/^TSOInterpreter::~TSOInterpreter(){$/;"	f	class:TSOInterpreter
TSOInterpreter	TSOInterpreter.h	/^class TSOInterpreter : public llvm::Interpreter{$/;"	c
TSOThread	TSOInterpreter.h	/^    TSOThread() : partial_buffer_flush(-1) {};$/;"	f	class:TSOInterpreter::TSOThread
TSOThread	TSOInterpreter.h	/^  class TSOThread{$/;"	c	class:TSOInterpreter
__TSO_INTERPRETER_H__	TSOInterpreter.h	22;"	d
partial_buffer_flush	TSOInterpreter.h	/^    int partial_buffer_flush;$/;"	m	class:TSOInterpreter::TSOThread
store_buffer	TSOInterpreter.h	/^    std::vector<MBlock> store_buffer;$/;"	m	class:TSOInterpreter::TSOThread
tso_threads	TSOInterpreter.h	/^  std::vector<TSOThread> tso_threads;$/;"	m	class:TSOInterpreter
TSOPSOTraceBuilder	TSOPSOTraceBuilder.h	/^  TSOPSOTraceBuilder(const Configuration &conf = Configuration::default_conf)$/;"	f	class:TSOPSOTraceBuilder
TSOPSOTraceBuilder	TSOPSOTraceBuilder.h	/^class TSOPSOTraceBuilder : public TraceBuilder{$/;"	c
__TSO_PSO_TRACE_BUILDER_H__	TSOPSOTraceBuilder.h	23;"	d
~TSOPSOTraceBuilder	TSOPSOTraceBuilder.h	/^  virtual ~TSOPSOTraceBuilder() {};$/;"	f	class:TSOPSOTraceBuilder
TSOTraceBuilder	TSOTraceBuilder.cpp	/^TSOTraceBuilder::TSOTraceBuilder(const Configuration &conf) : TSOPSOTraceBuilder(conf) {$/;"	f	class:TSOTraceBuilder
add_branch	TSOTraceBuilder.cpp	/^void TSOTraceBuilder::add_branch(int i, int j){$/;"	f	class:TSOTraceBuilder
atomic_store	TSOTraceBuilder.cpp	/^void TSOTraceBuilder::atomic_store(const ConstMRef &ml){$/;"	f	class:TSOTraceBuilder
canRunThisInstruction	TSOTraceBuilder.cpp	/^bool TSOTraceBuilder::canRunThisInstruction(){$/;"	f	class:TSOTraceBuilder
check_for_cycles	TSOTraceBuilder.cpp	/^bool TSOTraceBuilder::check_for_cycles(){$/;"	f	class:TSOTraceBuilder
cond_broadcast	TSOTraceBuilder.cpp	/^bool TSOTraceBuilder::cond_broadcast(const ConstMRef &ml){$/;"	f	class:TSOTraceBuilder
cond_destroy	TSOTraceBuilder.cpp	/^int TSOTraceBuilder::cond_destroy(const ConstMRef &ml){$/;"	f	class:TSOTraceBuilder
cond_init	TSOTraceBuilder.cpp	/^bool TSOTraceBuilder::cond_init(const ConstMRef &ml){$/;"	f	class:TSOTraceBuilder
cond_signal	TSOTraceBuilder.cpp	/^bool TSOTraceBuilder::cond_signal(const ConstMRef &ml){$/;"	f	class:TSOTraceBuilder
cond_wait	TSOTraceBuilder.cpp	/^bool TSOTraceBuilder::cond_wait(const ConstMRef &cond_ml, const ConstMRef &mutex_ml){$/;"	f	class:TSOTraceBuilder
debug_print	TSOTraceBuilder.cpp	/^void TSOTraceBuilder::debug_print() const {$/;"	f	class:TSOTraceBuilder
estimate_trace_count	TSOTraceBuilder.cpp	/^int TSOTraceBuilder::estimate_trace_count() const{$/;"	f	class:TSOTraceBuilder
estimate_trace_count	TSOTraceBuilder.cpp	/^int TSOTraceBuilder::estimate_trace_count(int idx) const{$/;"	f	class:TSOTraceBuilder
fence	TSOTraceBuilder.cpp	/^void TSOTraceBuilder::fence(){$/;"	f	class:TSOTraceBuilder
full_memory_conflict	TSOTraceBuilder.cpp	/^void TSOTraceBuilder::full_memory_conflict(){$/;"	f	class:TSOTraceBuilder
get_iid	TSOTraceBuilder.cpp	/^IID<CPid> TSOTraceBuilder::get_iid() const{$/;"	f	class:TSOTraceBuilder
get_trace	TSOTraceBuilder.cpp	/^Trace *TSOTraceBuilder::get_trace() const{$/;"	f	class:TSOTraceBuilder
has_cycle	TSOTraceBuilder.cpp	/^bool TSOTraceBuilder::has_cycle(IID<IPid> *loc) const{$/;"	f	class:TSOTraceBuilder
has_pending_store	TSOTraceBuilder.cpp	/^bool TSOTraceBuilder::has_pending_store(IPid pid, void const *ml) const {$/;"	f	class:TSOTraceBuilder
iid_string	TSOTraceBuilder.cpp	/^std::string TSOTraceBuilder::iid_string(const Event &evt) const{$/;"	f	class:TSOTraceBuilder
join	TSOTraceBuilder.cpp	/^void TSOTraceBuilder::join(int tgt_proc){$/;"	f	class:TSOTraceBuilder
load	TSOTraceBuilder.cpp	/^void TSOTraceBuilder::load(const ConstMRef &ml){$/;"	f	class:TSOTraceBuilder
mark_available	TSOTraceBuilder.cpp	/^void TSOTraceBuilder::mark_available(int proc, int aux){$/;"	f	class:TSOTraceBuilder
mark_unavailable	TSOTraceBuilder.cpp	/^void TSOTraceBuilder::mark_unavailable(int proc, int aux){$/;"	f	class:TSOTraceBuilder
metadata	TSOTraceBuilder.cpp	/^void TSOTraceBuilder::metadata(const llvm::MDNode *md){$/;"	f	class:TSOTraceBuilder
mutex_destroy	TSOTraceBuilder.cpp	/^void TSOTraceBuilder::mutex_destroy(const ConstMRef &ml){$/;"	f	class:TSOTraceBuilder
mutex_init	TSOTraceBuilder.cpp	/^void TSOTraceBuilder::mutex_init(const ConstMRef &ml){$/;"	f	class:TSOTraceBuilder
mutex_lock	TSOTraceBuilder.cpp	/^void TSOTraceBuilder::mutex_lock(const ConstMRef &ml){$/;"	f	class:TSOTraceBuilder
mutex_lock_fail	TSOTraceBuilder.cpp	/^void TSOTraceBuilder::mutex_lock_fail(const ConstMRef &ml){$/;"	f	class:TSOTraceBuilder
mutex_trylock	TSOTraceBuilder.cpp	/^void TSOTraceBuilder::mutex_trylock(const ConstMRef &ml){$/;"	f	class:TSOTraceBuilder
mutex_unlock	TSOTraceBuilder.cpp	/^void TSOTraceBuilder::mutex_unlock(const ConstMRef &ml){$/;"	f	class:TSOTraceBuilder
refuse_schedule	TSOTraceBuilder.cpp	/^void TSOTraceBuilder::refuse_schedule(){$/;"	f	class:TSOTraceBuilder
register_alternatives	TSOTraceBuilder.cpp	/^void TSOTraceBuilder::register_alternatives(int alt_count){$/;"	f	class:TSOTraceBuilder
reset	TSOTraceBuilder.cpp	/^bool TSOTraceBuilder::reset(){$/;"	f	class:TSOTraceBuilder
rpad	TSOTraceBuilder.cpp	/^static std::string rpad(std::string s, int n){$/;"	f	file:
schedule	TSOTraceBuilder.cpp	/^bool TSOTraceBuilder::schedule(int *proc, int *aux, int *alt, bool *dryrun){$/;"	f	class:TSOTraceBuilder
see_events	TSOTraceBuilder.cpp	/^void TSOTraceBuilder::see_events(const VecSet<int> &seen_accesses){\/\/ Finding I set or WI $/;"	f	class:TSOTraceBuilder
sleep_set_at	TSOTraceBuilder.cpp	/^VecSet<TSOTraceBuilder::IPid> TSOTraceBuilder::sleep_set_at(int i){$/;"	f	class:TSOTraceBuilder
sleepset_is_empty	TSOTraceBuilder.cpp	/^bool TSOTraceBuilder::sleepset_is_empty() const{$/;"	f	class:TSOTraceBuilder
spawn	TSOTraceBuilder.cpp	/^void TSOTraceBuilder::spawn(){$/;"	f	class:TSOTraceBuilder
store	TSOTraceBuilder.cpp	/^void TSOTraceBuilder::store(const ConstMRef &ml){$/;"	f	class:TSOTraceBuilder
wakeup	TSOTraceBuilder.cpp	/^void TSOTraceBuilder::wakeup(Access::Type type, void const *ml){$/;"	f	class:TSOTraceBuilder
~TSOTraceBuilder	TSOTraceBuilder.cpp	/^TSOTraceBuilder::~TSOTraceBuilder(){$/;"	f	class:TSOTraceBuilder
Access	TSOTraceBuilder.h	/^    Access() : type(NA), ml(0) {};$/;"	f	class:TSOTraceBuilder::Access
Access	TSOTraceBuilder.h	/^    Access(Type t, const void *m) : type(t), ml(m) {};$/;"	f	class:TSOTraceBuilder::Access
Access	TSOTraceBuilder.h	/^  class Access{$/;"	c	class:TSOTraceBuilder
Branch	TSOTraceBuilder.h	/^  class Branch{$/;"	c	class:TSOTraceBuilder
ByteInfo	TSOTraceBuilder.h	/^    ByteInfo() : last_update(-1), last_update_ml(0,1) {};$/;"	f	class:TSOTraceBuilder::ByteInfo
ByteInfo	TSOTraceBuilder.h	/^  class ByteInfo{$/;"	c	class:TSOTraceBuilder
CPS	TSOTraceBuilder.h	/^  CPidSystem CPS;$/;"	m	class:TSOTraceBuilder
CondVar	TSOTraceBuilder.h	/^    CondVar() : last_signal(-1) {};$/;"	f	class:TSOTraceBuilder::CondVar
CondVar	TSOTraceBuilder.h	/^    CondVar(int init_idx) : last_signal(init_idx) {};$/;"	f	class:TSOTraceBuilder::CondVar
CondVar	TSOTraceBuilder.h	/^  class CondVar{$/;"	c	class:TSOTraceBuilder
Event	TSOTraceBuilder.h	/^    Event(const IID<IPid> &iid,$/;"	f	class:TSOTraceBuilder::Event
Event	TSOTraceBuilder.h	/^  class Event{$/;"	c	class:TSOTraceBuilder
IPid	TSOTraceBuilder.h	/^  typedef int IPid;$/;"	t	class:TSOTraceBuilder
Mutex	TSOTraceBuilder.h	/^    Mutex() : last_access(-1), last_lock(-1) {};$/;"	f	class:TSOTraceBuilder::Mutex
Mutex	TSOTraceBuilder.h	/^    Mutex(int lacc) : last_access(lacc), last_lock(-1) {};$/;"	f	class:TSOTraceBuilder::Mutex
Mutex	TSOTraceBuilder.h	/^  class Mutex{$/;"	c	class:TSOTraceBuilder
NA	TSOTraceBuilder.h	/^    enum Type {R, W, W_ALL_MEMORY, NA} type;$/;"	e	enum:TSOTraceBuilder::Access::Type
PendingStore	TSOTraceBuilder.h	/^    PendingStore(const ConstMRef &ml, const VClock<IPid> &clk, const llvm::MDNode *md)$/;"	f	class:TSOTraceBuilder::PendingStore
PendingStore	TSOTraceBuilder.h	/^  class PendingStore{$/;"	c	class:TSOTraceBuilder
R	TSOTraceBuilder.h	/^    enum Type {R, W, W_ALL_MEMORY, NA} type;$/;"	e	enum:TSOTraceBuilder::Access::Type
TSOTraceBuilder	TSOTraceBuilder.h	/^class TSOTraceBuilder : public TSOPSOTraceBuilder{$/;"	c
Thread	TSOTraceBuilder.h	/^    Thread(const CPid &cpid, const VClock<IPid> &clk)$/;"	f	class:TSOTraceBuilder::Thread
Thread	TSOTraceBuilder.h	/^  class Thread{$/;"	c	class:TSOTraceBuilder
Type	TSOTraceBuilder.h	/^    enum Type {R, W, W_ALL_MEMORY, NA} type;$/;"	g	class:TSOTraceBuilder::Access
W	TSOTraceBuilder.h	/^    enum Type {R, W, W_ALL_MEMORY, NA} type;$/;"	e	enum:TSOTraceBuilder::Access::Type
W_ALL_MEMORY	TSOTraceBuilder.h	/^    enum Type {R, W, W_ALL_MEMORY, NA} type;$/;"	e	enum:TSOTraceBuilder::Access::Type
__TSO_TRACE_BUILDER_H__	TSOTraceBuilder.h	22;"	d
alt	TSOTraceBuilder.h	/^    int alt;$/;"	m	class:TSOTraceBuilder::Branch
alt	TSOTraceBuilder.h	/^    int alt;$/;"	m	class:TSOTraceBuilder::Event
available	TSOTraceBuilder.h	/^    bool available;$/;"	m	class:TSOTraceBuilder::Thread
begin	TSOTraceBuilder.h	/^      std::vector<int>::const_iterator begin() const { return v.begin(); };$/;"	f	struct:TSOTraceBuilder::ByteInfo::last_read_t
begin	TSOTraceBuilder.h	/^      std::vector<int>::iterator begin() { return v.begin(); };$/;"	f	struct:TSOTraceBuilder::ByteInfo::last_read_t
branch	TSOTraceBuilder.h	/^    VecSet<Branch> branch;$/;"	m	class:TSOTraceBuilder::Event
clock	TSOTraceBuilder.h	/^    VClock<IPid> clock;$/;"	m	class:TSOTraceBuilder::Event
clock	TSOTraceBuilder.h	/^    VClock<IPid> clock;$/;"	m	class:TSOTraceBuilder::PendingStore
clock	TSOTraceBuilder.h	/^    VClock<IPid> clock;$/;"	m	class:TSOTraceBuilder::Thread
cond_vars	TSOTraceBuilder.h	/^  std::map<void const*,CondVar> cond_vars;$/;"	m	class:TSOTraceBuilder
cpid	TSOTraceBuilder.h	/^    CPid cpid;$/;"	m	class:TSOTraceBuilder::Thread
curnode	TSOTraceBuilder.h	/^  Event &curnode() {$/;"	f	class:TSOTraceBuilder
curnode	TSOTraceBuilder.h	/^  const Event &curnode() const {$/;"	f	class:TSOTraceBuilder
current_cnt	TSOTraceBuilder.h	/^    int current_cnt;$/;"	m	class:TSOTraceBuilder::Event
dry_sleepers	TSOTraceBuilder.h	/^  int dry_sleepers;$/;"	m	class:TSOTraceBuilder
dryrun	TSOTraceBuilder.h	/^  bool dryrun;$/;"	m	class:TSOTraceBuilder
end	TSOTraceBuilder.h	/^      std::vector<int>::const_iterator end() const { return v.end(); };$/;"	f	struct:TSOTraceBuilder::ByteInfo::last_read_t
end	TSOTraceBuilder.h	/^      std::vector<int>::iterator end() { return v.end(); };$/;"	f	struct:TSOTraceBuilder::ByteInfo::last_read_t
iid	TSOTraceBuilder.h	/^    IID<IPid> iid;$/;"	m	class:TSOTraceBuilder::Event
ipid	TSOTraceBuilder.h	/^  IPid ipid(int proc, int aux) const {$/;"	f	class:TSOTraceBuilder
last_access	TSOTraceBuilder.h	/^    int last_access;$/;"	m	class:TSOTraceBuilder::Mutex
last_full_memory_conflict	TSOTraceBuilder.h	/^  int last_full_memory_conflict;$/;"	m	class:TSOTraceBuilder
last_lock	TSOTraceBuilder.h	/^    int last_lock;$/;"	m	class:TSOTraceBuilder::Mutex
last_md	TSOTraceBuilder.h	/^  const llvm::MDNode *last_md;$/;"	m	class:TSOTraceBuilder
last_read	TSOTraceBuilder.h	/^    } last_read;$/;"	m	class:TSOTraceBuilder::ByteInfo	typeref:struct:TSOTraceBuilder::ByteInfo::last_read_t
last_read_t	TSOTraceBuilder.h	/^    struct last_read_t {$/;"	s	class:TSOTraceBuilder::ByteInfo
last_rowe	TSOTraceBuilder.h	/^    int last_rowe;$/;"	m	class:TSOTraceBuilder::PendingStore
last_signal	TSOTraceBuilder.h	/^    int last_signal;$/;"	m	class:TSOTraceBuilder::CondVar
last_update	TSOTraceBuilder.h	/^    int last_update;$/;"	m	class:TSOTraceBuilder::ByteInfo
last_update_ml	TSOTraceBuilder.h	/^    ConstMRef last_update_ml;$/;"	m	class:TSOTraceBuilder::ByteInfo
may_conflict	TSOTraceBuilder.h	/^    bool may_conflict;$/;"	m	class:TSOTraceBuilder::Event
md	TSOTraceBuilder.h	/^    const llvm::MDNode *md;$/;"	m	class:TSOTraceBuilder::Event
md	TSOTraceBuilder.h	/^    const llvm::MDNode *md;$/;"	m	class:TSOTraceBuilder::PendingStore
mem	TSOTraceBuilder.h	/^  std::map<const void*,ByteInfo> mem;$/;"	m	class:TSOTraceBuilder
ml	TSOTraceBuilder.h	/^    ConstMRef ml;$/;"	m	class:TSOTraceBuilder::PendingStore
ml	TSOTraceBuilder.h	/^    const void *ml;$/;"	m	class:TSOTraceBuilder::Access
mutexes	TSOTraceBuilder.h	/^  std::map<void const*,Mutex> mutexes;$/;"	m	class:TSOTraceBuilder
operator <	TSOTraceBuilder.h	/^    bool operator<(const Access &a) const{$/;"	f	class:TSOTraceBuilder::Access
operator <	TSOTraceBuilder.h	/^    bool operator<(const Branch &b) const{$/;"	f	class:TSOTraceBuilder::Branch
operator ==	TSOTraceBuilder.h	/^    bool operator==(const Access &a) const{$/;"	f	class:TSOTraceBuilder::Access
operator ==	TSOTraceBuilder.h	/^    bool operator==(const Branch &b) const{$/;"	f	class:TSOTraceBuilder::Branch
operator []	TSOTraceBuilder.h	/^      int &operator[](int i) {$/;"	f	struct:TSOTraceBuilder::ByteInfo::last_read_t
operator []	TSOTraceBuilder.h	/^      int operator[](int i) const { return (i < int(v.size()) ? v[i] : -1); };$/;"	f	struct:TSOTraceBuilder::ByteInfo::last_read_t
origin_iid	TSOTraceBuilder.h	/^    IID<IPid> origin_iid;$/;"	m	class:TSOTraceBuilder::Event
pid	TSOTraceBuilder.h	/^    IPid pid;$/;"	m	class:TSOTraceBuilder::Branch
prefix	TSOTraceBuilder.h	/^  std::vector<Event> prefix;$/;"	m	class:TSOTraceBuilder
prefix_idx	TSOTraceBuilder.h	/^  int prefix_idx;$/;"	m	class:TSOTraceBuilder
replay	TSOTraceBuilder.h	/^  bool replay;$/;"	m	class:TSOTraceBuilder
size	TSOTraceBuilder.h	/^    int size;$/;"	m	class:TSOTraceBuilder::Event
sleep	TSOTraceBuilder.h	/^    VecSet<IPid> sleep;$/;"	m	class:TSOTraceBuilder::Event
sleep_accesses_r	TSOTraceBuilder.h	/^    VecSet<void const *> sleep_accesses_r;$/;"	m	class:TSOTraceBuilder::Thread
sleep_accesses_w	TSOTraceBuilder.h	/^    VecSet<void const *> sleep_accesses_w;$/;"	m	class:TSOTraceBuilder::Thread
sleep_branch_trace_count	TSOTraceBuilder.h	/^    int sleep_branch_trace_count;$/;"	m	class:TSOTraceBuilder::Event
sleep_full_memory_conflict	TSOTraceBuilder.h	/^    bool sleep_full_memory_conflict;$/;"	m	class:TSOTraceBuilder::Thread
sleeping	TSOTraceBuilder.h	/^    bool sleeping;$/;"	m	class:TSOTraceBuilder::Thread
spawned_thread	TSOTraceBuilder.h	/^    IPid spawned_thread;$/;"	m	class:TSOTraceBuilder::Event
store_buffer	TSOTraceBuilder.h	/^    std::vector<PendingStore> store_buffer;$/;"	m	class:TSOTraceBuilder::Thread
threads	TSOTraceBuilder.h	/^  std::vector<Thread> threads;$/;"	m	class:TSOTraceBuilder
type	TSOTraceBuilder.h	/^    enum Type {R, W, W_ALL_MEMORY, NA} type;$/;"	m	class:TSOTraceBuilder::Access	typeref:enum:TSOTraceBuilder::Access::Type
v	TSOTraceBuilder.h	/^      std::vector<int> v;$/;"	m	struct:TSOTraceBuilder::ByteInfo::last_read_t
waiters	TSOTraceBuilder.h	/^    std::vector<int> waiters;$/;"	m	class:TSOTraceBuilder::CondVar
wakeup	TSOTraceBuilder.h	/^    VecSet<IPid> wakeup;$/;"	m	class:TSOTraceBuilder::Event
BOOST_AUTO_TEST_CASE	TSO_test.cpp	/^BOOST_AUTO_TEST_CASE(Assume_1){$/;"	f
BOOST_AUTO_TEST_CASE	TSO_test.cpp	/^BOOST_AUTO_TEST_CASE(Assume_2){$/;"	f
BOOST_AUTO_TEST_CASE	TSO_test.cpp	/^BOOST_AUTO_TEST_CASE(Atomic_2){$/;"	f
BOOST_AUTO_TEST_CASE	TSO_test.cpp	/^BOOST_AUTO_TEST_CASE(Atomic_4){$/;"	f
BOOST_AUTO_TEST_CASE	TSO_test.cpp	/^BOOST_AUTO_TEST_CASE(Atomic_store_1){$/;"	f
BOOST_AUTO_TEST_CASE	TSO_test.cpp	/^BOOST_AUTO_TEST_CASE(Atomic_store_2){$/;"	f
BOOST_AUTO_TEST_CASE	TSO_test.cpp	/^BOOST_AUTO_TEST_CASE(Atomic_store_3){$/;"	f
BOOST_AUTO_TEST_CASE	TSO_test.cpp	/^BOOST_AUTO_TEST_CASE(Bitcast_rowe_1){$/;"	f
BOOST_AUTO_TEST_CASE	TSO_test.cpp	/^BOOST_AUTO_TEST_CASE(Bitcast_rowe_2){$/;"	f
BOOST_AUTO_TEST_CASE	TSO_test.cpp	/^BOOST_AUTO_TEST_CASE(Branch_sleep){$/;"	f
BOOST_AUTO_TEST_CASE	TSO_test.cpp	/^BOOST_AUTO_TEST_CASE(CMPXCHG_1){$/;"	f
BOOST_AUTO_TEST_CASE	TSO_test.cpp	/^BOOST_AUTO_TEST_CASE(CMPXCHG_2){$/;"	f
BOOST_AUTO_TEST_CASE	TSO_test.cpp	/^BOOST_AUTO_TEST_CASE(CMPXCHG_3){$/;"	f
BOOST_AUTO_TEST_CASE	TSO_test.cpp	/^BOOST_AUTO_TEST_CASE(CMPXCHG_4){$/;"	f
BOOST_AUTO_TEST_CASE	TSO_test.cpp	/^BOOST_AUTO_TEST_CASE(Disappearing_conflict){$/;"	f
BOOST_AUTO_TEST_CASE	TSO_test.cpp	/^BOOST_AUTO_TEST_CASE(Full_conflict_5){$/;"	f
BOOST_AUTO_TEST_CASE	TSO_test.cpp	/^BOOST_AUTO_TEST_CASE(Intrinsic){$/;"	f
BOOST_AUTO_TEST_CASE	TSO_test.cpp	/^BOOST_AUTO_TEST_CASE(Join_1){$/;"	f
BOOST_AUTO_TEST_CASE	TSO_test.cpp	/^BOOST_AUTO_TEST_CASE(Join_2){$/;"	f
BOOST_AUTO_TEST_CASE	TSO_test.cpp	/^BOOST_AUTO_TEST_CASE(Join_3){$/;"	f
BOOST_AUTO_TEST_CASE	TSO_test.cpp	/^BOOST_AUTO_TEST_CASE(Malloc_1){$/;"	f
BOOST_AUTO_TEST_CASE	TSO_test.cpp	/^BOOST_AUTO_TEST_CASE(Malloc_2){$/;"	f
BOOST_AUTO_TEST_CASE	TSO_test.cpp	/^BOOST_AUTO_TEST_CASE(Minimal_computation){$/;"	f
BOOST_AUTO_TEST_CASE	TSO_test.cpp	/^BOOST_AUTO_TEST_CASE(Mutex_1){$/;"	f
BOOST_AUTO_TEST_CASE	TSO_test.cpp	/^BOOST_AUTO_TEST_CASE(Mutex_10){$/;"	f
BOOST_AUTO_TEST_CASE	TSO_test.cpp	/^BOOST_AUTO_TEST_CASE(Mutex_11){$/;"	f
BOOST_AUTO_TEST_CASE	TSO_test.cpp	/^BOOST_AUTO_TEST_CASE(Mutex_12){$/;"	f
BOOST_AUTO_TEST_CASE	TSO_test.cpp	/^BOOST_AUTO_TEST_CASE(Mutex_2){$/;"	f
BOOST_AUTO_TEST_CASE	TSO_test.cpp	/^BOOST_AUTO_TEST_CASE(Mutex_3){$/;"	f
BOOST_AUTO_TEST_CASE	TSO_test.cpp	/^BOOST_AUTO_TEST_CASE(Mutex_4){$/;"	f
BOOST_AUTO_TEST_CASE	TSO_test.cpp	/^BOOST_AUTO_TEST_CASE(Mutex_5){$/;"	f
BOOST_AUTO_TEST_CASE	TSO_test.cpp	/^BOOST_AUTO_TEST_CASE(Mutex_6){$/;"	f
BOOST_AUTO_TEST_CASE	TSO_test.cpp	/^BOOST_AUTO_TEST_CASE(Mutex_7){$/;"	f
BOOST_AUTO_TEST_CASE	TSO_test.cpp	/^BOOST_AUTO_TEST_CASE(Mutex_8){$/;"	f
BOOST_AUTO_TEST_CASE	TSO_test.cpp	/^BOOST_AUTO_TEST_CASE(Mutex_9){$/;"	f
BOOST_AUTO_TEST_CASE	TSO_test.cpp	/^BOOST_AUTO_TEST_CASE(Nasty_bitcast){$/;"	f
BOOST_AUTO_TEST_CASE	TSO_test.cpp	/^BOOST_AUTO_TEST_CASE(Non_fences){$/;"	f
BOOST_AUTO_TEST_CASE	TSO_test.cpp	/^BOOST_AUTO_TEST_CASE(Overlapping_ROWE_1){$/;"	f
BOOST_AUTO_TEST_CASE	TSO_test.cpp	/^BOOST_AUTO_TEST_CASE(Overlapping_ROWE_2){$/;"	f
BOOST_AUTO_TEST_CASE	TSO_test.cpp	/^BOOST_AUTO_TEST_CASE(Overlapping_ROWE_3){$/;"	f
BOOST_AUTO_TEST_CASE	TSO_test.cpp	/^BOOST_AUTO_TEST_CASE(Overlapping_ROWE_4){$/;"	f
BOOST_AUTO_TEST_CASE	TSO_test.cpp	/^BOOST_AUTO_TEST_CASE(Overlapping_ROWE_5){$/;"	f
BOOST_AUTO_TEST_CASE	TSO_test.cpp	/^BOOST_AUTO_TEST_CASE(Propagate){$/;"	f
BOOST_AUTO_TEST_CASE	TSO_test.cpp	/^BOOST_AUTO_TEST_CASE(ROWE_1){$/;"	f
BOOST_AUTO_TEST_CASE	TSO_test.cpp	/^BOOST_AUTO_TEST_CASE(ROWE_2){$/;"	f
BOOST_AUTO_TEST_CASE	TSO_test.cpp	/^BOOST_AUTO_TEST_CASE(Refuse_1){$/;"	f
BOOST_AUTO_TEST_CASE	TSO_test.cpp	/^BOOST_AUTO_TEST_CASE(Small_dekker){$/;"	f
BOOST_AUTO_TEST_CASE	TSO_test.cpp	/^BOOST_AUTO_TEST_CASE(Small_peterson){$/;"	f
BOOST_AUTO_TEST_CASE	TSO_test.cpp	/^BOOST_AUTO_TEST_CASE(before_update){$/;"	f
BOOST_AUTO_TEST_CASE	TSO_test.cpp	/^BOOST_AUTO_TEST_CASE(blacken_change_clock){$/;"	f
BOOST_AUTO_TEST_CASE	TSO_test.cpp	/^BOOST_AUTO_TEST_CASE(fib_simple){$/;"	f
BOOST_AUTO_TEST_CASE	TSO_test.cpp	/^BOOST_AUTO_TEST_CASE(fib_simple_n2){$/;"	f
BOOST_AUTO_TEST_CASE	TSO_test.cpp	/^BOOST_AUTO_TEST_CASE(fib_simple_n2_true){$/;"	f
BOOST_AUTO_TEST_CASE	TSO_test.cpp	/^BOOST_AUTO_TEST_CASE(own_black_read){$/;"	f
BOOST_AUTO_TEST_CASE	TSO_test.cpp	/^BOOST_AUTO_TEST_CASE(own_black_read_2){$/;"	f
BOOST_AUTO_TEST_CASE	TSO_test.cpp	/^BOOST_AUTO_TEST_CASE(own_black_read_3){$/;"	f
BOOST_AUTO_TEST_CASE	TSO_test.cpp	/^BOOST_AUTO_TEST_CASE(read_read_write_1){$/;"	f
BOOST_AUTO_TEST_CASE	TSO_test.cpp	/^BOOST_AUTO_TEST_CASE(read_read_write_2){$/;"	f
BOOST_AUTO_TEST_CASE	TSO_test.cpp	/^BOOST_AUTO_TEST_CASE(rruu){$/;"	f
BOOST_AUTO_TEST_CASE	TSO_test.cpp	/^BOOST_AUTO_TEST_CASE(small_dekker_checker){$/;"	f
BOOST_AUTO_TEST_CASE	TSO_test2.cpp	/^BOOST_AUTO_TEST_CASE(Compiler_fenced_dekker){$/;"	f
BOOST_AUTO_TEST_CASE	TSO_test2.cpp	/^BOOST_AUTO_TEST_CASE(Condvar_1){$/;"	f
BOOST_AUTO_TEST_CASE	TSO_test2.cpp	/^BOOST_AUTO_TEST_CASE(Condvar_10){$/;"	f
BOOST_AUTO_TEST_CASE	TSO_test2.cpp	/^BOOST_AUTO_TEST_CASE(Condvar_11){$/;"	f
BOOST_AUTO_TEST_CASE	TSO_test2.cpp	/^BOOST_AUTO_TEST_CASE(Condvar_12){$/;"	f
BOOST_AUTO_TEST_CASE	TSO_test2.cpp	/^BOOST_AUTO_TEST_CASE(Condvar_13){$/;"	f
BOOST_AUTO_TEST_CASE	TSO_test2.cpp	/^BOOST_AUTO_TEST_CASE(Condvar_14){$/;"	f
BOOST_AUTO_TEST_CASE	TSO_test2.cpp	/^BOOST_AUTO_TEST_CASE(Condvar_2){$/;"	f
BOOST_AUTO_TEST_CASE	TSO_test2.cpp	/^BOOST_AUTO_TEST_CASE(Condvar_3){$/;"	f
BOOST_AUTO_TEST_CASE	TSO_test2.cpp	/^BOOST_AUTO_TEST_CASE(Condvar_4){$/;"	f
BOOST_AUTO_TEST_CASE	TSO_test2.cpp	/^BOOST_AUTO_TEST_CASE(Condvar_5){$/;"	f
BOOST_AUTO_TEST_CASE	TSO_test2.cpp	/^BOOST_AUTO_TEST_CASE(Condvar_6){$/;"	f
BOOST_AUTO_TEST_CASE	TSO_test2.cpp	/^BOOST_AUTO_TEST_CASE(Condvar_7){$/;"	f
BOOST_AUTO_TEST_CASE	TSO_test2.cpp	/^BOOST_AUTO_TEST_CASE(Condvar_8){$/;"	f
BOOST_AUTO_TEST_CASE	TSO_test2.cpp	/^BOOST_AUTO_TEST_CASE(Condvar_9){$/;"	f
BOOST_AUTO_TEST_CASE	TSO_test2.cpp	/^BOOST_AUTO_TEST_CASE(Mutex_13_no_req_init){$/;"	f
BOOST_AUTO_TEST_CASE	TSO_test2.cpp	/^BOOST_AUTO_TEST_CASE(Mutex_14_no_req_init){$/;"	f
BOOST_AUTO_TEST_CASE	TSO_test2.cpp	/^BOOST_AUTO_TEST_CASE(Mutex_15_no_req_init){$/;"	f
BOOST_AUTO_TEST_CASE	TSO_test2.cpp	/^BOOST_AUTO_TEST_CASE(Mutex_16_no_req_init){$/;"	f
BOOST_AUTO_TEST_CASE	TSO_test2.cpp	/^BOOST_AUTO_TEST_CASE(Mutex_17_req_init){$/;"	f
BOOST_AUTO_TEST_CASE	TSO_test2.cpp	/^BOOST_AUTO_TEST_CASE(Mutex_18_no_req_init){$/;"	f
BOOST_AUTO_TEST_CASE	TSO_test2.cpp	/^BOOST_AUTO_TEST_CASE(Mutex_trylock_1){$/;"	f
IIDSeqTrace	Trace.cpp	/^IIDSeqTrace::IIDSeqTrace(const std::vector<IID<CPid> > &cmp,$/;"	f	class:IIDSeqTrace
Trace	Trace.cpp	/^Trace::Trace(const std::vector<Error*> &errors, bool blk)$/;"	f	class:Trace
basename	Trace.cpp	/^std::string Trace::basename(const std::string &fname){$/;"	f	class:Trace
clone	Trace.cpp	/^Error *AssertionError::clone() const{$/;"	f	class:AssertionError
clone	Trace.cpp	/^Error *MemoryError::clone() const{$/;"	f	class:MemoryError
clone	Trace.cpp	/^Error *PthreadsError::clone() const{$/;"	f	class:PthreadsError
clone	Trace.cpp	/^Error *RobustnessError::clone() const{$/;"	f	class:RobustnessError
clone	Trace.cpp	/^Error *SegmentationFaultError::clone() const{$/;"	f	class:SegmentationFaultError
get_location	Trace.cpp	/^bool Trace::get_location(const llvm::MDNode *m,$/;"	f	class:Trace
get_src_line_verbatim	Trace.cpp	/^std::string Trace::get_src_line_verbatim(const llvm::MDNode *m){$/;"	f	class:Trace
is_absolute_path	Trace.cpp	/^bool Trace::is_absolute_path(const std::string &fname){$/;"	f	class:Trace
to_string	Trace.cpp	/^std::string AssertionError::to_string() const{$/;"	f	class:AssertionError
to_string	Trace.cpp	/^std::string IIDSeqTrace::to_string(int _ind) const{$/;"	f	class:IIDSeqTrace
to_string	Trace.cpp	/^std::string MemoryError::to_string() const{$/;"	f	class:MemoryError
to_string	Trace.cpp	/^std::string PthreadsError::to_string() const{$/;"	f	class:PthreadsError
to_string	Trace.cpp	/^std::string RobustnessError::to_string() const{$/;"	f	class:RobustnessError
to_string	Trace.cpp	/^std::string SegmentationFaultError::to_string() const{$/;"	f	class:SegmentationFaultError
to_string	Trace.cpp	/^std::string Trace::to_string(int _ind) const{$/;"	f	class:Trace
~IIDSeqTrace	Trace.cpp	/^IIDSeqTrace::~IIDSeqTrace(){$/;"	f	class:IIDSeqTrace
~Trace	Trace.cpp	/^Trace::~Trace(){$/;"	f	class:Trace
AssertionError	Trace.h	/^  AssertionError(const IID<CPid> &loc, std::string assert_condition)$/;"	f	class:AssertionError
AssertionError	Trace.h	/^class AssertionError : public Error{$/;"	c
Error	Trace.h	/^  Error(const IID<CPid> &loc) : loc(loc) {};$/;"	f	class:Error
Error	Trace.h	/^class Error{$/;"	c
IIDSeqTrace	Trace.h	/^class IIDSeqTrace : public Trace {$/;"	c
MemoryError	Trace.h	/^  MemoryError(const IID<CPid> &loc, std::string msg)$/;"	f	class:MemoryError
MemoryError	Trace.h	/^class MemoryError : public Error{$/;"	c
PthreadsError	Trace.h	/^  PthreadsError(const IID<CPid> &loc, std::string msg)$/;"	f	class:PthreadsError
PthreadsError	Trace.h	/^class PthreadsError : public Error{$/;"	c
RobustnessError	Trace.h	/^  RobustnessError(const IID<CPid> &loc)$/;"	f	class:RobustnessError
RobustnessError	Trace.h	/^class RobustnessError : public Error{$/;"	c
SegmentationFaultError	Trace.h	/^  SegmentationFaultError(const IID<CPid> &loc)$/;"	f	class:SegmentationFaultError
SegmentationFaultError	Trace.h	/^class SegmentationFaultError : public Error{$/;"	c
Trace	Trace.h	/^class Trace{$/;"	c
__TRACE_H__	Trace.h	28;"	d
blocked	Trace.h	/^  bool blocked;$/;"	m	class:Trace
computation	Trace.h	/^  std::vector<IID<CPid> > computation;$/;"	m	class:IIDSeqTrace
computation_md	Trace.h	/^  std::vector<const llvm::MDNode*> computation_md;$/;"	m	class:IIDSeqTrace
condition	Trace.h	/^  std::string condition;$/;"	m	class:AssertionError
errors	Trace.h	/^  std::vector<Error*> errors;$/;"	m	class:Trace
get_computation	Trace.h	/^  virtual const std::vector<IID<CPid> > &get_computation() const { return computation; };$/;"	f	class:IIDSeqTrace
get_computation_metadata	Trace.h	/^  virtual const std::vector<const llvm::MDNode*> &get_computation_metadata() const{$/;"	f	class:IIDSeqTrace
get_errors	Trace.h	/^  const std::vector<Error*> &get_errors() const { return errors; };$/;"	f	class:Trace
get_location	Trace.h	/^  virtual IID<CPid> get_location() const { return loc; };$/;"	f	class:Error
has_errors	Trace.h	/^  bool has_errors() const { return errors.size(); };$/;"	f	class:Trace
is_blocked	Trace.h	/^  virtual bool is_blocked() const { return blocked; };$/;"	f	class:Trace
loc	Trace.h	/^  IID<CPid> loc;$/;"	m	class:Error
msg	Trace.h	/^  std::string msg;$/;"	m	class:MemoryError
msg	Trace.h	/^  std::string msg;$/;"	m	class:PthreadsError
set_blocked	Trace.h	/^  virtual void set_blocked(bool b = true) { blocked = b; };$/;"	f	class:Trace
~Error	Trace.h	/^  virtual ~Error() {};$/;"	f	class:Error
TraceBuilder	TraceBuilder.cpp	/^TraceBuilder::TraceBuilder(const Configuration &C) : conf(C) {$/;"	f	class:TraceBuilder
assertion_error	TraceBuilder.cpp	/^void TraceBuilder::assertion_error(std::string cond, const IID<CPid> &loc){$/;"	f	class:TraceBuilder
memory_error	TraceBuilder.cpp	/^void TraceBuilder::memory_error(std::string msg, const IID<CPid> &loc){$/;"	f	class:TraceBuilder
pthreads_error	TraceBuilder.cpp	/^void TraceBuilder::pthreads_error(std::string msg, const IID<CPid> &loc){$/;"	f	class:TraceBuilder
segmentation_fault_error	TraceBuilder.cpp	/^void TraceBuilder::segmentation_fault_error(const IID<CPid> &loc){$/;"	f	class:TraceBuilder
~TraceBuilder	TraceBuilder.cpp	/^TraceBuilder::~TraceBuilder(){$/;"	f	class:TraceBuilder
TraceBuilder	TraceBuilder.h	/^class TraceBuilder{$/;"	c
__TRACE_BUILDER_H__	TraceBuilder.h	23;"	d
bound_cnt	TraceBuilder.h	/^  int bound_cnt;$/;"	m	class:TraceBuilder
bound_limit	TraceBuilder.h	/^  int bound_limit;$/;"	m	class:TraceBuilder
bound_reset	TraceBuilder.h	/^  bool bound_reset;$/;"	m	class:TraceBuilder
conf	TraceBuilder.h	/^  const Configuration &conf;$/;"	m	class:TraceBuilder
debug_print	TraceBuilder.h	/^  virtual void debug_print() const {};$/;"	f	class:TraceBuilder
errors	TraceBuilder.h	/^  std::vector<Error*> errors;$/;"	m	class:TraceBuilder
estimate_trace_count	TraceBuilder.h	/^  virtual int estimate_trace_count() const { return 1; };$/;"	f	class:TraceBuilder
hard_reset_allowed	TraceBuilder.h	/^  int hard_reset_allowed;$/;"	m	class:TraceBuilder
has_error	TraceBuilder.h	/^  virtual bool has_error() const { return errors.size(); };$/;"	f	class:TraceBuilder
Transform	Transform.cpp	/^namespace Transform {$/;"	n	file:
transform	Transform.cpp	/^  bool transform(llvm::Module &mod, const Configuration &conf){$/;"	f	namespace:Transform
transform	Transform.cpp	/^  std::string transform(const std::string &src, const Configuration &conf){$/;"	f	namespace:Transform
transform	Transform.cpp	/^  void transform(std::string infile, std::string outfile, const Configuration &conf){$/;"	f	namespace:Transform
Transform	Transform.h	/^namespace Transform {$/;"	n
__TRANSFORM_H__	Transform.h	23;"	d
BOOST_AUTO_TEST_CASE	Unroll_test.cpp	/^BOOST_AUTO_TEST_CASE(Global_spin_1){$/;"	f
BOOST_AUTO_TEST_CASE	Unroll_test.cpp	/^BOOST_AUTO_TEST_CASE(PHI_counter_1){$/;"	f
BOOST_AUTO_TEST_CASE	Unroll_test.cpp	/^BOOST_AUTO_TEST_CASE(PHI_exit){$/;"	f
BOOST_AUTO_TEST_CASE	Unroll_test.cpp	/^BOOST_AUTO_TEST_CASE(PHI_exit_2){$/;"	f
BOOST_AUTO_TEST_CASE	Unroll_test.cpp	/^BOOST_AUTO_TEST_CASE(PHI_exit_3){$/;"	f
BOOST_AUTO_TEST_CASE	Unroll_test.cpp	/^BOOST_AUTO_TEST_CASE(Termination_1){$/;"	f
BOOST_AUTO_TEST_CASE	Unroll_test.cpp	/^BOOST_AUTO_TEST_CASE(Termination_2){$/;"	f
BOOST_AUTO_TEST_CASE	Unroll_test.cpp	/^BOOST_AUTO_TEST_CASE(Unroll_4){$/;"	f
VClock	VClock.cpp	/^VClock<int>::VClock(){}$/;"	f	class:VClock
VClock	VClock.cpp	/^VClock<int>::VClock(const VClock &vc) : vec(vc.vec) {}$/;"	f	class:VClock
VClock	VClock.cpp	/^VClock<int>::VClock(const std::initializer_list<int> &il) : vec(il) {$/;"	f	class:VClock
VClock	VClock.cpp	/^VClock<int>::VClock(const std::vector<int> &v) : vec(v) {$/;"	f	class:VClock
geq	VClock.cpp	/^bool VClock<int>::geq(const VClock<int> &vc) const{$/;"	f	class:VClock
gt	VClock.cpp	/^bool VClock<int>::gt(const VClock<int> &vc) const{$/;"	f	class:VClock
leq	VClock.cpp	/^bool VClock<int>::leq(const VClock<int> &vc) const{$/;"	f	class:VClock
lt	VClock.cpp	/^bool VClock<int>::lt(const VClock<int> &vc) const{$/;"	f	class:VClock
operator !=	VClock.cpp	/^bool VClock<int>::operator!=(const VClock<int> &vc) const{$/;"	f	class:VClock
operator +	VClock.cpp	/^VClock<int> VClock<int>::operator+(const VClock<int> &vc) const{$/;"	f	class:VClock
operator +=	VClock.cpp	/^VClock<int> &VClock<int>::operator+=(const VClock<int> &vc){$/;"	f	class:VClock
operator <	VClock.cpp	/^bool VClock<int>::operator<(const VClock<int> &vc) const{$/;"	f	class:VClock
operator <=	VClock.cpp	/^bool VClock<int>::operator<=(const VClock<int> &vc) const{$/;"	f	class:VClock
operator =	VClock.cpp	/^VClock<int> &VClock<int>::operator=(const VClock<int> &vc){$/;"	f	class:VClock
operator ==	VClock.cpp	/^bool VClock<int>::operator==(const VClock<int> &vc) const{$/;"	f	class:VClock
operator >	VClock.cpp	/^bool VClock<int>::operator>(const VClock<int> &vc) const{$/;"	f	class:VClock
operator >=	VClock.cpp	/^bool VClock<int>::operator>=(const VClock<int> &vc) const{$/;"	f	class:VClock
operator []	VClock.cpp	/^int &VClock<int>::operator[](int i){$/;"	f	class:VClock
operator []	VClock.cpp	/^int VClock<int>::operator[](int i) const{$/;"	f	class:VClock
to_string	VClock.cpp	/^std::string VClock<int>::to_string() const{$/;"	f	class:VClock
~VClock	VClock.cpp	/^VClock<int>::~VClock(){}$/;"	f	class:VClock
VClock	VClock.h	/^class VClock {$/;"	c
VClock	VClock.h	/^class VClock<int> {$/;"	c
__VCLOCK_H__	VClock.h	23;"	d
clocks	VClock.h	/^  std::map<DOM,int> clocks;$/;"	m	class:VClock
includes	VClock.h	/^  bool includes(const IID<DOM> &iid) const {$/;"	f	class:VClock
includes	VClock.h	/^  bool includes(const IID<int> &iid) const {$/;"	f	class:VClock
operator <<	VClock.h	/^llvm::raw_ostream &operator<<(llvm::raw_ostream &os, const VClock<DOM> &vc){$/;"	f
operator <<	VClock.h	/^std::ostream &operator<<(std::ostream &os, const VClock<DOM> &vc){$/;"	f
vec	VClock.h	/^  std::vector<int> vec;$/;"	m	class:VClock
BOOST_AUTO_TEST_CASE	VClock_CPid_test.cpp	/^BOOST_AUTO_TEST_CASE(Addition){$/;"	f
BOOST_AUTO_TEST_CASE	VClock_CPid_test.cpp	/^BOOST_AUTO_TEST_CASE(Addition_2){$/;"	f
BOOST_AUTO_TEST_CASE	VClock_CPid_test.cpp	/^BOOST_AUTO_TEST_CASE(Assignment_1){$/;"	f
BOOST_AUTO_TEST_CASE	VClock_CPid_test.cpp	/^BOOST_AUTO_TEST_CASE(Assignment_2){$/;"	f
BOOST_AUTO_TEST_CASE	VClock_CPid_test.cpp	/^BOOST_AUTO_TEST_CASE(Assignment_3){$/;"	f
BOOST_AUTO_TEST_CASE	VClock_CPid_test.cpp	/^BOOST_AUTO_TEST_CASE(Equality){$/;"	f
BOOST_AUTO_TEST_CASE	VClock_CPid_test.cpp	/^BOOST_AUTO_TEST_CASE(Init_default){$/;"	f
BOOST_AUTO_TEST_CASE	VClock_CPid_test.cpp	/^BOOST_AUTO_TEST_CASE(Init_initializer_list){$/;"	f
BOOST_AUTO_TEST_CASE	VClock_CPid_test.cpp	/^BOOST_AUTO_TEST_CASE(Init_map){$/;"	f
BOOST_AUTO_TEST_CASE	VClock_CPid_test.cpp	/^BOOST_AUTO_TEST_CASE(Less){$/;"	f
BOOST_AUTO_TEST_CASE	VClock_int_test.cpp	/^BOOST_AUTO_TEST_CASE(Addition){$/;"	f
BOOST_AUTO_TEST_CASE	VClock_int_test.cpp	/^BOOST_AUTO_TEST_CASE(Addition_2){$/;"	f
BOOST_AUTO_TEST_CASE	VClock_int_test.cpp	/^BOOST_AUTO_TEST_CASE(Assignment_1){$/;"	f
BOOST_AUTO_TEST_CASE	VClock_int_test.cpp	/^BOOST_AUTO_TEST_CASE(Assignment_2){$/;"	f
BOOST_AUTO_TEST_CASE	VClock_int_test.cpp	/^BOOST_AUTO_TEST_CASE(Assignment_3){$/;"	f
BOOST_AUTO_TEST_CASE	VClock_int_test.cpp	/^BOOST_AUTO_TEST_CASE(Equality){$/;"	f
BOOST_AUTO_TEST_CASE	VClock_int_test.cpp	/^BOOST_AUTO_TEST_CASE(Init_default){$/;"	f
BOOST_AUTO_TEST_CASE	VClock_int_test.cpp	/^BOOST_AUTO_TEST_CASE(Init_initializer_list){$/;"	f
BOOST_AUTO_TEST_CASE	VClock_int_test.cpp	/^BOOST_AUTO_TEST_CASE(Init_vector){$/;"	f
BOOST_AUTO_TEST_CASE	VClock_int_test.cpp	/^BOOST_AUTO_TEST_CASE(Less){$/;"	f
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
EXIT_OK	main.cpp	54;"	d	file:
VERIFICATION_FAILURE	main.cpp	56;"	d	file:
main	main.cpp	/^int main(int argc, char *argv[]){$/;"	f
print_version	main.cpp	/^void print_version(){$/;"	f
CLANG	nidhuggc.py	/^CLANG='%%CLANG%%'$/;"	v
CLANGXX	nidhuggc.py	/^CLANGXX='%%CLANGXX%%'$/;"	v
NIDHUGG	nidhuggc.py	/^NIDHUGG='%%NIDHUGGPATH%%'$/;"	v
canonize	nidhuggc.py	/^    def canonize(arg):$/;"	f	function:get_args
destroy_tmpdir	nidhuggc.py	/^def destroy_tmpdir():$/;"	f
get_IR	nidhuggc.py	/^def get_IR(nidhuggcargs,compilerargs):$/;"	f
get_args	nidhuggc.py	/^def get_args():$/;"	f
get_lang	nidhuggc.py	/^def get_lang(nidhuggcargs):$/;"	f
help_indent	nidhuggc.py	/^def help_indent(s,n):$/;"	f
init_tmpdir	nidhuggc.py	/^def init_tmpdir():$/;"	f
main	nidhuggc.py	/^def main():$/;"	f
nidhuggcparamaliases	nidhuggc.py	/^nidhuggcparamaliases = {$/;"	v
nidhuggcparams	nidhuggc.py	/^nidhuggcparams = [$/;"	v
print_help	nidhuggc.py	/^def print_help():$/;"	f
print_version	nidhuggc.py	/^def print_version():$/;"	f
run	nidhuggc.py	/^def run(cmd,ignoreret=False):$/;"	f
run_nidhugg	nidhuggc.py	/^def run_nidhugg(nidhuggcargs,nidhuggargs,irfname):$/;"	f
tmpdir	nidhuggc.py	/^tmpdir=None$/;"	v
transform	nidhuggc.py	/^def transform(nidhuggcargs,transformargs,irfname):$/;"	f
nregex	nregex.cpp	/^namespace nregex{$/;"	n	file:
regex_replace	nregex.cpp	/^  std::string regex_replace(std::string tgt, std::string regex, std::string format){$/;"	f	namespace:nregex
regex_replace_format	nregex.cpp	/^  static std::string regex_replace_format(std::string format, regmatch_t *pmatch, int nmatch,$/;"	f	namespace:nregex
nregex	nregex.h	/^namespace nregex{$/;"	n
BOOST_AUTO_TEST_CASE	nregex_test.cpp	/^BOOST_AUTO_TEST_CASE(No_match_1){$/;"	f
BOOST_AUTO_TEST_CASE	nregex_test.cpp	/^BOOST_AUTO_TEST_CASE(No_match_2){$/;"	f
BOOST_AUTO_TEST_CASE	nregex_test.cpp	/^BOOST_AUTO_TEST_CASE(Replace_1){$/;"	f
BOOST_AUTO_TEST_CASE	nregex_test.cpp	/^BOOST_AUTO_TEST_CASE(Replace_2){$/;"	f
BOOST_AUTO_TEST_CASE	nregex_test.cpp	/^BOOST_AUTO_TEST_CASE(Replace_3){$/;"	f
BOOST_AUTO_TEST_CASE	nregex_test.cpp	/^BOOST_AUTO_TEST_CASE(Replace_4){$/;"	f
BOOST_AUTO_TEST_CASE	nregex_test.cpp	/^BOOST_AUTO_TEST_CASE(Replace_5){$/;"	f
BOOST_AUTO_TEST_CASE	nregex_test.cpp	/^BOOST_AUTO_TEST_CASE(Replace_6){$/;"	f
BOOST_AUTO_TEST_CASE	nregex_test.cpp	/^BOOST_AUTO_TEST_CASE(Replace_7){$/;"	f
BOOST_AUTO_TEST_CASE	nregex_test.cpp	/^BOOST_AUTO_TEST_CASE(Replace_fmt_1){$/;"	f
BOOST_AUTO_TEST_CASE	nregex_test.cpp	/^BOOST_AUTO_TEST_CASE(Replace_fmt_2){$/;"	f
BOOST_AUTO_TEST_CASE	nregex_test.cpp	/^BOOST_AUTO_TEST_CASE(Replace_fmt_3){$/;"	f
BOOST_AUTO_TEST_CASE	unittest.cpp	/^BOOST_AUTO_TEST_CASE(Testing_testing){$/;"	f
BOOST_TEST_DYN_LINK	unittest.cpp	28;"	d	file:
BOOST_TEST_MODULE	unittest.cpp	29;"	d	file:
Fixture	unittest.cpp	/^  Fixture(){$/;"	f	struct:Fixture
Fixture	unittest.cpp	/^BOOST_GLOBAL_FIXTURE(Fixture);$/;"	v
Fixture	unittest.cpp	/^struct Fixture{$/;"	s	file:
boost	unittest.cpp	/^namespace boost{ namespace unit_test { namespace ut_detail{$/;"	n	file:
normalize_test_case_name	unittest.cpp	/^      std::string normalize_test_case_name(const_string name) {$/;"	f	namespace:boost::unit_test::ut_detail
unit_test	unittest.cpp	/^namespace boost{ namespace unit_test { namespace ut_detail{$/;"	n	namespace:boost	file:
ut_detail	unittest.cpp	/^namespace boost{ namespace unit_test { namespace ut_detail{$/;"	n	namespace:boost::unit_test	file:
~Fixture	unittest.cpp	/^  ~Fixture(){$/;"	f	struct:Fixture
VecSet	vecset.h	/^  VecSet() {};$/;"	f	class:VecSet
VecSet	vecset.h	/^  VecSet(const std::vector<T> &v)$/;"	f	class:VecSet
VecSet	vecset.h	/^  VecSet(std::vector<T> &&v)$/;"	f	class:VecSet
VecSet	vecset.h	/^template<class T> class VecSet{$/;"	c
__VECSET_H__	vecset.h	23;"	d
back	vecset.h	/^  const T &back() const { return vec.back(); };$/;"	f	class:VecSet
begin	vecset.h	/^  const_iterator begin() const { return const_iterator(0,vec); };$/;"	f	class:VecSet
clear	vecset.h	/^  void clear() { vec.clear(); };$/;"	f	class:VecSet
const_iterator	vecset.h	/^    const_iterator(int i, const std::vector<T> &vec)$/;"	f	class:VecSet::const_iterator
const_iterator	vecset.h	/^  class const_iterator{$/;"	c	class:VecSet
difference_type	vecset.h	/^    typedef unsigned difference_type;$/;"	t	class:VecSet::const_iterator
empty	vecset.h	/^  bool empty() const { return vec.empty();};$/;"	f	class:VecSet
end	vecset.h	/^  const_iterator end() const { return const_iterator(vec.size(),vec); };$/;"	f	class:VecSet
get_vector	vecset.h	/^  const std::vector<T> &get_vector() const { return vec; };$/;"	f	class:VecSet
i	vecset.h	/^    int i;$/;"	m	class:VecSet::const_iterator
iterator_category	vecset.h	/^    typedef std::bidirectional_iterator_tag iterator_category;$/;"	t	class:VecSet::const_iterator
operator !=	vecset.h	/^    bool operator!=(const const_iterator &it) const { return i != it.i; };$/;"	f	class:VecSet::const_iterator
operator !=	vecset.h	/^  bool operator!=(const VecSet<T> &s) const { return vec != s.vec; };$/;"	f	class:VecSet
operator *	vecset.h	/^    const T &operator*() const{$/;"	f	class:VecSet::const_iterator
operator ++	vecset.h	/^    const_iterator &operator++(){$/;"	f	class:VecSet::const_iterator
operator ++	vecset.h	/^    const_iterator operator++(int) {$/;"	f	class:VecSet::const_iterator
operator --	vecset.h	/^    const_iterator &operator--(){$/;"	f	class:VecSet::const_iterator
operator --	vecset.h	/^    const_iterator operator--(int) {$/;"	f	class:VecSet::const_iterator
operator ->	vecset.h	/^    const T *operator->() const{$/;"	f	class:VecSet::const_iterator
operator <	vecset.h	/^    bool operator<(const const_iterator &it) const { return i < it.i; };$/;"	f	class:VecSet::const_iterator
operator <	vecset.h	/^  bool operator<(const VecSet<T> &s) const { return vec < s.vec; };$/;"	f	class:VecSet
operator <=	vecset.h	/^    bool operator<=(const const_iterator &it) const { return i <= it.i; };$/;"	f	class:VecSet::const_iterator
operator <=	vecset.h	/^  bool operator<=(const VecSet<T> &s) const { return vec <= s.vec; };$/;"	f	class:VecSet
operator ==	vecset.h	/^    bool operator==(const const_iterator &it) const { return i == it.i; };$/;"	f	class:VecSet::const_iterator
operator ==	vecset.h	/^  bool operator==(const VecSet<T> &s) const { return vec == s.vec; };$/;"	f	class:VecSet
operator >	vecset.h	/^    bool operator>(const const_iterator &it) const { return i > it.i; };$/;"	f	class:VecSet::const_iterator
operator >	vecset.h	/^  bool operator>(const VecSet<T> &s) const { return vec > s.vec; };$/;"	f	class:VecSet
operator >=	vecset.h	/^    bool operator>=(const const_iterator &it) const { return i >= it.i; };$/;"	f	class:VecSet::const_iterator
operator >=	vecset.h	/^  bool operator>=(const VecSet<T> &s) const { return vec >= s.vec; };$/;"	f	class:VecSet
operator []	vecset.h	/^  const T &operator[](int i) const { return vec[i]; };$/;"	f	class:VecSet
pointer	vecset.h	/^    typedef T* pointer;$/;"	t	class:VecSet::const_iterator
pop_back	vecset.h	/^  void pop_back() { vec.pop_back(); };$/;"	f	class:VecSet
reference	vecset.h	/^    typedef T& reference;$/;"	t	class:VecSet::const_iterator
reserve	vecset.h	/^  void reserve(int n) { vec.reserve(n); };$/;"	f	class:VecSet
singleton	vecset.h	/^  static VecSet singleton(const T &t){$/;"	f	class:VecSet
size	vecset.h	/^  int size() const { return vec.size(); };$/;"	f	class:VecSet
value_type	vecset.h	/^    typedef T value_type;$/;"	t	class:VecSet::const_iterator
vec	vecset.h	/^    const std::vector<T> &vec;$/;"	m	class:VecSet::const_iterator
vec	vecset.h	/^  std::vector<T> vec;$/;"	m	class:VecSet
~VecSet	vecset.h	/^  virtual ~VecSet() {};$/;"	f	class:VecSet
